[
  {
    "url": "https://en.wikipedia.org/wiki/Software_engineering",
    "title": "Software engineering - Wikipedia",
    "content": "Software engineering - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Terminology Toggle Terminology subsection 2.1 Definition 2.2 Suitability 3 Workload Toggle Workload subsection 3.1 Requirements analysis 3.2 Design 3.3 Construction 3.4 Testing 3.5 Program analysis 3.6 Maintenance 4 Education Toggle Education subsection 4.1 Software engineering degree programs 5 Profession Toggle Profession subsection 5.1 Employment 5.1.1 United States 5.2 Certification 5.3 Impact of globalization 5.4 Prizes 6 Criticism 7 See also Toggle See also subsection 7.1 Study and practice 7.2 Roles 7.3 Professional aspects 8 References Toggle References subsection 8.1 Citations 8.2 Sources 9 Further reading 10 External links Toggle the table of contents Software engineering 84 languages Afrikaans \u12a0\u121b\u122d\u129b \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Asturianu Az\u0259rbaycanca \u09ac\u09be\u0982\u09b2\u09be \u092d\u094b\u091c\u092a\u0941\u0930\u0940 \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Bosanski Catal\u00e0 \u010ce\u0161tina Cymraeg Dansk Deutsch \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac Espa\u00f1ol Esperanto Euskara \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais Gaeilge Gaelg Galego \u06af\u06cc\u0644\u06a9\u06cc \ud55c\uad6d\uc5b4 Hausa \u0939\u093f\u0928\u094d\u0926\u0940 Hrvatski Ido Bahasa Indonesia \u00cdslenska Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Kiswahili Kurd\u00ee \u0ea5\u0eb2\u0ea7 Latina Latvie\u0161u Lietuvi\u0173 \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 \u0d2e\u0d32\u0d2f\u0d3e\u0d33\u0d02 Bahasa Melayu Mirand\u00e9s \u041c\u043e\u043d\u0433\u043e\u043b Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Norsk nynorsk \u0b13\u0b21\u0b3c\u0b3f\u0b06 O\u02bbzbekcha / \u045e\u0437\u0431\u0435\u043a\u0447\u0430 \u067e\u069a\u062a\u0648 \u1797\u17b6\u179f\u17b6\u1781\u17d2\u1798\u17c2\u179a Piemont\u00e8is Polski Portugu\u00eas Qaraqalpaqsha Rom\u00e2n\u0103 Runa Simi \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Scots Shqip \u0dc3\u0dd2\u0d82\u0dc4\u0dbd Simple English \u0633\u0646\u068c\u064a Sloven\u010dina \u06a9\u0648\u0631\u062f\u06cc \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Srpskohrvatski / \u0441\u0440\u043f\u0441\u043a\u043e\u0445\u0440\u0432\u0430\u0442\u0441\u043a\u0438 Sunda Suomi Svenska Tagalog \u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0e44\u0e17\u0e22 \u1275\u130d\u122d\u129b T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0627\u0631\u062f\u0648 Ti\u1ebfng Vi\u1ec7t Winaray \u5434\u8bed \u05d9\u05d9\u05b4\u05d3\u05d9\u05e9 \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikibooks Wikiquote Wikiversity Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Engineering approach to software development Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e This article is part of a series on Engineering Engineering branches Aerospace engineering Agricultural engineering Architectural engineering Biomedical engineering Chemical engineering Civil engineering Computer engineering Data engineering Design engineer Electrical engineering Electronics engineering Energy engineering Environmental engineering Industrial engineering Manufacturing engineering Marine engineering Materials engineering Mechanical engineering Mechatronics engineering Mining engineering Nuclear engineering Petroleum engineering Process engineering Robotics engineering Software engineering Structural engineering Systems engineering Lists of engineering software Additive manufacturing software Aerospace engineering software Automotive engineering software Bioinformatics software Building information modeling software Chemical engineering software Chemical process simulators EDA software Electromagnetic simulation software Computer-aided engineering software Computer-aided manufacturing software Computational chemistry software Computational fluid dynamics software Data science software Discrete event simulation software Finite element analysis software Free electronics circuits software Gene prediction software Genetic engineering software Geotechnical engineering software Hardware description languages simulators Hydrology software Mathematical software Molecular design software Molecular mechanics modeling software Nanostructures software Nuclear engineering software Nucleic acid simulation software Numerical analysis software Numerical libraries Open-source AI software Open-source libraries Optimization software Power engineering software Programming tools Protein structure prediction software RNA structure prediction software Robotics simulation software Scientific simulation software Sequence alignment software Structural alignment software Structural engineering software System dynamics software Wind energy software Glossary of engineering Glossary of aerospace engineering Glossary of civil engineering Glossary of electrical and electronics engineering Glossary of mechanical engineering Glossary of structural engineering See also Engineering education Engineering ethics Engineering management History of engineering List of engineering awards List of engineering branches List of engineering journals and magazines List of engineering schools List of engineering societies Lists of engineers Outline of engineering Engineering portal Engineering books on Wikibooks v t e Software engineering is a branch of both computer science and engineering focused on designing, developing, testing, and maintaining software applications . [ 1 ] It involves applying engineering principles and computer programming expertise to develop software systems that meet user needs. [ 2 ] [ 3 ] [ 4 ] [ 5 ] In the tech industry, the title software engineer is often used aspirationally, even though many such roles are fundamentally programming positions and lack the formal regulation associated with traditional engineering. [ 6 ] A software engineer applies a software development process , [ 2 ] [ 7 ] that involves defining, implementing, testing , managing , and maintaining software systems, as well as developing the software development process itself. History [ edit ] Main article: History of software engineering Beginning in the 1960s, software engineering was recognized as a separate field of engineering . [ 8 ] The development of software engineering was seen as a struggle. Problems included software that was over budget, exceeded deadlines, required extensive debugging and maintenance, and unsuccessfully met the needs of consumers or was never even completed. In 1968, NATO organized the first conference on software engineering, which addressed emerging challenges in software development. The event played a key role in formalizing guidelines and best practices for creating reliable and maintainable software. [ 9 ] The origins of the term software engineering have been attributed to various sources. The term appeared in a list of services offered by companies in the June 1965 issue of \"Computers and Automation\" [ 10 ] and was used more formally in the August 1966 issue of Communications of the ACM (Volume 9, number 8) in \"President's Letter to the ACM Membership\" by Anthony A. Oettinger. [ 11 ] [ 12 ] [ 13 ] It is also associated with the title of a NATO conference in 1968 by Professor Friedrich L. Bauer . [ 14 ] Margaret Hamilton described the discipline of \"software engineering\" during the Apollo missions to give what they were doing legitimacy. [ 15 ] At the time, there was perceived to be a \" software crisis \". [ 16 ] [ 17 ] [ 18 ] The 40th International Conference on Software Engineering (ICSE 2018) celebrates 50 years of \"Software Engineering\" with the Plenary Sessions' keynotes of Frederick Brooks [ 19 ] and Margaret Hamilton . [ 20 ] In 1984, the Software Engineering Institute (SEI) was established as a federally funded research and development center headquartered on the campus of Carnegie Mellon University in Pittsburgh, Pennsylvania , United States. [ 21 ] Watts Humphrey founded the SEI Software Process Program, aimed at understanding and managing the software engineering process. [ 21 ] The Process Maturity Levels introduced became the Capability Maturity Model Integration for Development (CMMI-DEV), which defined how the US Government evaluates the abilities of a software development team. Modern, generally accepted best practices for software engineering have been collected by the ISO/IEC JTC 1/SC 7 subcommittee and published as the Software Engineering Body of Knowledge (SWEBOK). [ 7 ] Software engineering is considered one of the major computing disciplines. [ 22 ] In modern systems, where concepts such as Edge Computing , Internet of Things and Cyber-physical Systems are prevalent, software is a critical factor. Thus, software engineering is closely related to the Systems Engineering discipline. The Systems Engineering Body of Knowledge claims: Software is prominent in most modern systems architectures and is often the primary means for integrating complex system components. Software engineering and systems engineering are not merely related disciplines; they are intimately intertwined....Good systems engineering is a key factor in enabling good software engineering. Terminology [ edit ] Definition [ edit ] Notable definitions of software engineering include: \"The systematic application of scientific and technological knowledge, methods, and experience to the design, implementation, testing, and documentation of software.\"\u2014The Bureau of Labor Statistics\u2014 IEEE Systems and software engineering \u2013 Vocabulary [ 23 ] \"The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.\"\u2014 IEEE Standard Glossary of Software Engineering Terminology [ 24 ] \"An engineering discipline concerned with all aspects of software production.\" \u2014 Ian Sommerville [ 25 ] \"The establishment and use of sound engineering principles in order to economically obtain software that is reliable and works efficiently on real machines.\"\u2014 Fritz Bauer [ 26 ] \"A branch of computer science that deals with the design, implementation, and maintenance of complex computer programs .\"\u2014 Merriam-Webster [ 27 ] \" 'Software engineering' encompasses not just the act of writing code, but all of the tools and processes an organization uses to build and maintain that code over time. [...] Software engineering can be thought of as 'programming integrated over time. ' \"\u2014Software Engineering at Google [ 28 ] The term has also been used less formally: As the informal contemporary term for the broad range of activities that were formerly called computer programming and systems analysis [ 29 ] As the broad term for all aspects of the practice of computer programming, as opposed to the theory of computer programming, which is formally studied as a sub-discipline of computer science [ 30 ] As the term embodying the advocacy of a specific approach to computer programming, one that urges that it be treated as an engineering discipline rather than an art or a craft, and advocates the codification of recommended practices [ 31 ] Suitability [ edit ] Individual commentators have disagreed sharply on how to define software engineering or its legitimacy as an engineering discipline. David Parnas has said that software engineering is, in fact, a form of engineering. [ 32 ] [ 33 ] Steve McConnell has said that it is not, but that it should be. [ 34 ] Donald Knuth has said that programming is an art and a science. [ 35 ] Edsger W. Dijkstra claimed that the terms software engineering and software engineer have been misused in the United States. [ 36 ] Workload [ edit ] Main article: Outline of software engineering Requirements analysis [ edit ] Main article: Software requirements Requirements engineering is about elicitation, analysis, specification, and validation of requirements for software . Software requirements can be functional , non-functional or domain. Functional requirements describe expected behaviors (i.e. outputs). Non-functional requirements specify issues like portability, security, maintainability, reliability, scalability, performance, reusability, and flexibility. They are classified into the following types: interface constraints, performance constraints (such as response time, security, storage space, etc.), operating constraints, life cycle constraints (maintainability, portability, etc.), and economic constraints. Knowledge of how the system or software works is needed when it comes to specifying non-functional requirements. Domain requirements have to do with the characteristic of a certain category or domain of projects. [ 37 ] Design [ edit ] Main article: Software design Software design is the process of making high-level plans for the software. Design is sometimes divided into levels: Interface design plans the interaction between a system and its environment as well as the inner workings of the system. Architectural design plans the major components of a system, including their responsibilities, properties, and interfaces between them. Detailed design plans internal elements, including their properties, relationships, algorithms and data structures . [ 38 ] Construction [ edit ] Main article: Software construction Software construction typically involves programming (a.k.a. coding), unit testing , integration testing , and debugging so as to implement the design. [ 2 ] [ 7 ] \"Software testing is related to, but different from, ... debugging\". [ 7 ] Testing [ edit ] Main article: Software testing Software testing is an empirical, technical investigation conducted to provide stakeholders with information about the quality of the software under test. [ 2 ] [ 7 ] Software testing can be viewed as a risk based activity. When described separately from construction, testing typically is performed by test engineers or quality assurance instead of the programmers who wrote it. It is performed at the system level and is considered an aspect of software quality . The testers' goals during the testing process are to minimize the overall number of tests to a manageable set and make well-informed decisions regarding which risks should be prioritized for testing and which can wait. [ 39 ] Program analysis [ edit ] Main article: Program analysis Program analysis is the process of analyzing computer programs with respect to an aspect such as performance , robustness , and security . Maintenance [ edit ] Main article: Software maintenance Software maintenance refers to supporting the software after release. It may include but is not limited to: error correction , optimization, deletion of unused and discarded features, and enhancement of existing features. [ 2 ] [ 7 ] Usually, maintenance takes up 40% to 80% of project cost. [ 40 ] Education [ edit ] The examples and perspective in this article may not represent a worldwide view of the subject . You may improve this article , discuss the issue on the talk page , or create a new article , as appropriate. ( November 2010 ) ( Learn how and when to remove this message ) See also: List of software programming journals Top computer science colleges in North America Knowledge of computer programming is a prerequisite for becoming a software engineer. In 2004, the IEEE Computer Society produced the SWEBOK , which has been published as ISO/IEC Technical Report 1979:2005, describing the body of knowledge that they recommend to be mastered by a graduate software engineer with four years of experience. [ 41 ] Many software engineers enter the profession by obtaining a university degree or training at a vocational school. One standard international curriculum for undergraduate software engineering degrees was defined by the Joint Task Force on Computing Curricula of the IEEE Computer Society and the Association for Computing Machinery , and updated in 2014. [ 22 ] A number of universities have Software Engineering degree programs; as of 2010 [update] , there were 244 Campus Bachelor of Software Engineering programs, 70 Online programs, 230 Masters-level programs, 41 Doctorate-level programs, and 69 Certificate-level programs in the United States. In addition to university education, many companies sponsor internships for students wishing to pursue careers in information technology. These internships can introduce the student to real-world tasks that typical software engineers encounter every day. Similar experience can be gained through military service in software engineering. Software engineering degree programs [ edit ] A small but growing number of practitioners have software engineering degrees. In 1987, the Department of Computing at Imperial College London introduced the first three-year software engineering bachelor's degree in the world; in the following year, the University of Sheffield established a similar program. [ 42 ] In 1996, the Rochester Institute of Technology established the first software engineering bachelor's degree program in the United States; however, it did not obtain ABET accreditation until 2003, the same year as Rice University , Clarkson University , Milwaukee School of Engineering , and Mississippi State University . [ 43 ] Since then, software engineering undergraduate degrees have been established at many universities. A standard international curriculum for undergraduate software engineering degrees, SE2004 , was defined by a steering committee between 2001 and 2004 with funding from the Association for Computing Machinery and the IEEE Computer Society . As of 2004 [update] , about 50 universities in the U.S. offer software engineering degrees, which teach both computer science and engineering principles and practices. The first software engineering master's degree was established at Seattle University in 1979. Since then, graduate software engineering degrees have been made available from many more universities. Likewise in Canada, the Canadian Engineering Accreditation Board (CEAB) of the Canadian Council of Professional Engineers has recognized several software engineering programs. Additionally, many online advanced degrees in Software Engineering have appeared such as the Master of Science in Software Engineering (MSE) degree offered through the Computer Science and Engineering Department at California State University, Fullerton . Steve McConnell opines that because most universities teach computer science rather than software engineering, there is a shortage of true software engineers. [ 44 ] ETS (\u00c9cole de technologie sup\u00e9rieure) University and UQAM (Universit\u00e9 du Qu\u00e9bec \u00e0 Montr\u00e9al) were mandated by IEEE to develop the Software Engineering Body of Knowledge ( SWEBOK ), which has become an ISO standard describing the body of knowledge covered by a software engineer. [ 7 ] Profession [ edit ] Main articles: Software engineering professionalism and Regulation and licensure in engineering Legal requirements for the licensing or certification of professional software engineers vary around the world. In the UK, there is no licensing or legal requirement to assume or use the job title Software Engineer. In some areas of Canada, such as Alberta, British Columbia, Ontario, [ 45 ] and Quebec, software engineers can hold the Professional Engineer (P.Eng) designation and/or the Information Systems Professional (I.S.P.) designation. In Europe, Software Engineers can obtain the European Engineer (EUR ING) professional title. Software Engineers can also become professionally qualified as a Chartered Engineer through the British Computer Society . In the United States, the NCEES began offering a Professional Engineer exam for Software Engineering in 2013, thereby allowing Software Engineers to be licensed and recognized. [ 46 ] NCEES ended the exam after April 2019 due to lack of participation. [ 47 ] Mandatory licensing is currently still largely debated, and perceived as controversial. [ 48 ] [ 49 ] The IEEE Computer Society and the ACM , the two main US-based professional organizations of software engineering, publish guides to the profession of software engineering. The IEEE's Guide to the Software Engineering Body of Knowledge \u2013 2004 Version , or SWEBOK , defines the field and describes the knowledge the IEEE expects a practicing software engineer to have. The most current version is SWEBOK v4. [ 7 ] The IEEE also promulgates a \"Software Engineering Code of Ethics\". [ 50 ] Employment [ edit ] The examples and perspective in this United States may not represent a worldwide view of the subject . You may improve this United States , discuss the issue on the talk page , or create a new United States, as appropriate. ( September 2021 ) ( Learn how and when to remove this message ) See also: Software engineering demographics There are an estimated 26.9 million professional software engineers in the world as of 2022, up from 21 million in 2016. [ 51 ] [ 52 ] Many software engineers work as employees or contractors. Software engineers work with businesses, government agencies (civilian or military), and non-profit organizations. Some software engineers work for themselves as freelancers . Some organizations have specialists to perform each of the tasks in the software development process . Other organizations require software engineers to do many or all of them. In large projects, people may specialize in only one role. In small projects, people may fill several or all roles at the same time. Many companies hire interns , often university or college students during a summer break, or externships . Specializations include analysts , architects , developers , testers , technical support , middleware analysts, project managers , software product managers , educators , and researchers . Most software engineers and programmers work 40 hours a week, but about 15 percent of software engineers and 11 percent of programmers worked more than 50 hours a week in 2008. [ 53 ] Potential injuries in these occupations are possible because like other workers who spend long periods sitting in front of a computer terminal typing at a keyboard, engineers and programmers are susceptible to eyestrain, back discomfort, Thrombosis , Obesity , and hand and wrist problems such as carpal tunnel syndrome . [ 54 ] United States [ edit ] The U. S. Bureau of Labor Statistics (BLS) counted 1,365,500 software developers holding jobs in the U.S. in 2018. [ 55 ] Due to its relative newness as a field of study, formal education in software engineering is often taught as part of a computer science curriculum, and many software engineers hold computer science degrees. [ 56 ] The BLS estimates 2024 to 2034 the growth for software engineers is 15% which is lesser than their prediction from 2023 to 2033 that computer software engineering would increase by 17%. [ 57 ] This is down from the 2022 to 2032 BLS estimate of 25% for software engineering. [ 57 ] [ 58 ] And, is further down from their 30% 2010 to 2020 BLS estimate. [ 59 ] Due to this trend, job growth may not be as fast as during the last decade, as jobs that would have gone to computer software engineers in the United States would instead be outsourced to computer software engineers in countries such as India and other foreign countries. [ 60 ] [ 53 ] In addition, the BLS Job Outlook for Computer Programmers, the U.S. Bureau of Labor Statistics (BLS) Occupational Outlook predicts a decline of -7 percent from 2016 to 2026, a further decline of -9 percent from 2019 to 2029, a decline of -10 percent from 2021 to 2031. [ 60 ] and then a decline of -11 percent from 2022 to 2032. [ 60 ] Currently their prediction for 2024 to 2034 is a decline of -6 percent. Since computer programming can be done from anywhere in the world, companies sometimes hire programmers in countries where wages are lower. [ 60 ] [ 61 ] [ 62 ] Furthermore, the ratio of women in many software fields has also been declining over the years as compared to other engineering fields. [ 63 ] Then there is the additional concern that recent advances in Artificial Intelligence might impact the demand for future generations of Software Engineers. [ 64 ] [ 65 ] [ 66 ] [ 67 ] [ 68 ] [ 69 ] [ 70 ] However, this trend may change or slow in the future as many current software engineers in the U.S. market flee the profession or age out of the market in the next few decades. [ 60 ] [ 71 ] Certification [ edit ] The Software Engineering Institute offers certifications on specific topics like security , process improvement and software architecture . [ 72 ] IBM , Microsoft and other companies also sponsor their own certification examinations. Many IT certification programs are oriented toward specific technologies, and managed by the vendors of these technologies. [ 73 ] These certification programs are tailored to the institutions that would employ people who use these technologies. Broader certification of general software engineering skills is available through various professional societies. As of 2006 [update] , the IEEE had certified over 575 software professionals as a Certified Software Development Professional (CSDP). [ 74 ] In 2008 they added an entry-level certification known as the Certified Software Development Associate (CSDA). [ 75 ] The ACM and the IEEE Computer Society together examined the possibility of licensing of software engineers as Professional Engineers in the 1990s,\nbut eventually decided that such licensing was inappropriate for the professional industrial practice of software engineering. [ 48 ] John C. Knight and Nancy G. Leveson presented a more balanced analysis of the licensing issue in 2002. [ 49 ] In the U.K. the British Computer Society has developed a legally recognized professional certification called Chartered IT Professional (CITP) , available to fully qualified members ( MBCS ). Software engineers may be eligible for membership of the British Computer Society or Institution of Engineering and Technology and so qualify to be considered for Chartered Engineer status through either of those institutions. In Canada the Canadian Information Processing Society has developed a legally recognized professional certification called Information Systems Professional (ISP) . [ 76 ] In Ontario, Canada, Software Engineers who graduate from a Canadian Engineering Accreditation Board (CEAB) accredited program, successfully complete PEO's ( Professional Engineers Ontario ) Professional Practice Examination (PPE) and have at least 48 months of acceptable engineering experience are eligible to be licensed through the Professional Engineers Ontario and can become Professional Engineers P.Eng. [ 77 ] The PEO does not recognize any online or distance education however; and does not consider Computer Science programs to be equivalent to software engineering programs despite the tremendous overlap between the two. This has sparked controversy and a certification war. It has also held the number of P.Eng holders for the profession exceptionally low. The vast majority of working professionals in the field hold a degree in CS, not SE. Given the difficult certification path for holders of non-SE degrees, most never bother to pursue the license. Impact of globalization [ edit ] The initial impact of outsourcing, and the relatively lower cost of international human resources in developing third world countries led to a massive migration of software development activities from corporations in North America and Europe to India and later: China, Russia, and other developing countries. This approach had some flaws, mainly the distance / time zone difference that prevented human interaction between clients and developers and the massive job transfer. This had a negative impact on many aspects of the software engineering profession. For example, some students in the developed world avoid education related to software engineering because of the fear of offshore outsourcing (importing software products or services from other countries) and of being displaced by foreign visa workers . [ 78 ] Additionally, the glut of high-tech workers has led to a wider adoption of the 996 working hour system and \u2018007\u2019 schedules as the expected work load. [ 79 ] Although statistics do not currently show a threat to software engineering itself; a related career, computer programming does appear to have been affected. [ 80 ] Nevertheless, the ability to smartly leverage offshore and near-shore resources via the follow-the-sun workflow has improved the overall operational capability of many organizations. [ 81 ] When North Americans leave work, Asians are just arriving to work. When Asians are leaving work, Europeans arrive to work. This provides a continuous ability to have human oversight on business-critical processes 24 hours per day, without paying overtime compensation or disrupting a key human resource, sleep patterns. While global outsourcing has several advantages, global \u2013 and generally distributed \u2013 development can run into serious difficulties resulting from the distance between developers. This is due to the key elements of this type of distance that have been identified as geographical, temporal, cultural and communication (that includes the use of different languages and dialects of English in different locations). [ 82 ] Research has been carried out in the area of global software development over the last 15 years and an extensive body of relevant work published that highlights the benefits and problems associated with the complex activity. As with other aspects of software engineering research is ongoing in this and related areas. Prizes [ edit ] There are various prizes in the field of software engineering: ACM-AAAI Allen Newell Award - USA. Awarded to career contributions that have breadth within computer science, or that bridge computer science and other disciplines. BCS Lovelace Medal . Awarded to individuals who have made outstanding contributions to the understanding or advancement of computing. ACM SIGSOFT Outstanding Research Award, selected for individual(s) who have made \" significant and lasting research contributions to the theory or practice of software engineering.\" [ 83 ] More ACM SIGSOFT Awards. [ 84 ] The Codie award , a yearly award issued by the Software and Information Industry Association for excellence in software development within the software industry. Harlan Mills Award for \"contributions to the theory and practice of the information sciences, focused on software engineering\". ICSE Most Influential Paper Award. [ 85 ] Jolt Award , also for the software industry. Stevens Award given in memory of Wayne Stevens. Criticism [ edit ] Some call for licensing, certification and codified bodies of knowledge as mechanisms for spreading the engineering knowledge and maturing the field. [ 86 ] Some claim that the concept of software engineering is so new that it is rarely understood, and it is widely misinterpreted, including in software engineering textbooks, papers, and among the communities of programmers and crafters. [ 87 ] Some claim that a core issue with software engineering is that its approaches are not empirical enough because a real-world validation of approaches is usually absent, or very limited and hence software engineering is often misinterpreted as feasible only in a \"theoretical environment.\" [ 87 ] Edsger Dijkstra , a founder of many of the concepts in software development today, rejected the idea of \"software engineering\" up until his death in 2002, arguing that those terms were poor analogies for what he called the \"radical novelty\" of computer science : A number of these phenomena have been bundled under the name \"Software Engineering\". As economics is known as \"The Miserable Science\", software engineering should be known as \"The Doomed Discipline\", doomed because it cannot even approach its goal since its goal is self-contradictory. Software engineering, of course, presents itself as another worthy cause, but that is eyewash: if you carefully read its literature and analyse what its devotees actually do, you will discover that software engineering has accepted as its charter \"How to program if you cannot.\" [ 88 ] See also [ edit ] Wikimedia Commons has media related to Software engineers . Study and practice [ edit ] Computer science Computer engineering Data engineering Software craftsmanship Software development Release engineering Roles [ edit ] Programmer Systems analyst Systems architect Professional aspects [ edit ] Bachelor of Science in Information Technology Bachelor of Software Engineering List of software engineering conferences List of computer science journals (including software engineering journals) List of software programming journals Lists of programming software development tools Software Engineering Institute References [ edit ] Citations [ edit ] ^ \"What is Software Engineering?\" . Michigan Technological University . Retrieved 2025-06-29 . ^ a b c d e Abran et al. 2004 harvnb error: no target: CITEREFAbranMooreBourqueDupuis2004 ( help ) ^ ACM (2007). \"Computing Degrees & Careers\" . ACM. Archived from the original on 2011-06-17 . Retrieved 2010-11-23 . ^ Laplante, Phillip (2007). What Every Engineer Should Know about Software Engineering . Boca Raton: CRC. ISBN 978-0-8493-7228-5 . Retrieved 2011-01-21 . ^ \"What Does a Software Engineer Do?\" . coursera . Oct 31, 2022. ^ Bogost, Ian (5 November 2015). \"Programmers: Stop Calling Yourselves Engineers\" . The Atlantic . ^ a b c d e f g h Bourque, Pierre; Fairley, Richard E. (Dick), eds. (2014). Guide to the Software Engineering Body of Knowledge Version 3.0 (SWEBOK) . IEEE Computer Society . ^ Farone, Alison (2020-08-04). \"The history of coding and software engineering\" . Hack Reactor . Retrieved 2025-06-29 . ^ \"The history of coding and software engineering\" . Hack Reactor . Archived from the original on 2022-03-24 . Retrieved 2021-05-06 . ^ \"Computers and Automation: The Computer Directory and Buyers' Guide, 1965\" (PDF) . bitsavers.org . Retrieved 15 July 2023 . ^ \"President's Letter to the ACM Membership\" (PDF) . Retrieved 27 February 2025 . We must recognize ourselves -- not necessarily all of us, and not necessarily any one of us all the time -- as members of an engineering profession, be it hardware engineering or software engineering, a profession without artificial and irrelevant boundaries like that between \"scientific\" and \"business\" applications. ^ Oettinger, A. G. (1966). \"President's Letter to the ACM Membership\" . Commun. ACM . 9 (8). Association for Computing Machinery: 545\u2013 546. doi : 10.1145/365758.3291288 . ISSN 0001-0782 . S2CID 53432801 . ^ \"The origin of \"software engineering\" \" . 4 April 2013 . Retrieved 17 November 2017 . ^ Randall, Brian. \"The 1968/69 NATO Software Engineering Reports\" . Retrieved 17 November 2017 . ^ Lori Cameron (October 5, 2008). \"Margaret Hamilton: First Software Engineer\" . Tech News . IEEE Computer Society . ^ Ian Sommerville (March 24, 2015). Software Engineering (10th\u00a0ed.). Pearson Education Limited. ISBN 978-0-13-394303-0 . ^ Peter, Naur; Randell, Brian (7\u201311 October 1968). Software Engineering: Report of a conference sponsored by the NATO Science Committee (PDF) . Garmisch, Germany: Scientific Affairs Division, NATO . Retrieved 2008-12-26 . ^ Randell, Brian (10 August 2001). \"The 1968/69 NATO Software Engineering Reports\" . Brian Randell's University Homepage . The School of the Computer Sciences, Newcastle University . Retrieved 2008-10-11 . The idea for the first NATO Software Engineering Conference, and in particular that of adopting the then practically unknown term \"software engineering\" as its (deliberately provocative) title, I believe came originally from Professor Fritz Bauer . ^ 2018 International Conference on Software Engineering celebrating its 40th anniversary, and 50 years of Software engineering (31 May 2018). \"ICSE 2018 \u2013 Plenary Sessions \u2013 Fred Brooks\" . YouTube . Retrieved 9 August 2018 . {{ cite web }} :  CS1 maint: numeric names: authors list ( link ) ^ 2018 International Conference on Software Engineering celebrating its 40th anniversary, and 50 years of Software engineering (31 May 2018). \"ICSE 2018 \u2013 Plenary Sessions \u2013 Margaret Hamilton\" . YouTube . Retrieved 9 August 2018 . {{ cite web }} :  CS1 maint: numeric names: authors list ( link ) ^ a b Linda Hutz Pesante (January 1, 2003). Anthony Ralston; Edwin D. Reilly (eds.). \"Software engineering institute (SEI)\" . Encyclopedia of Computer Science . Chichester , West Sussex, UK: John Wiley and Sons Ltd. : 1611\u2013 1613. ISBN 978-0-470-86412-8 . (1) The institute was competitively awarded to Carnegie Mellon in December 1984 by the US Department of Defense (DoD) to improve the state of the practice of software engineering. ... (2) the SEI moves mature solutions of proven value into widespread use; examples include the Capability Maturity Model (CMM) ... ^ a b Joint Task Force on Computing Curricula, IEEE Computer Society , Association for Computing Machinery (23 February 2015). Software Engineering 2014: Curriculum Guidelines for Undergraduate Degree Programs in Software Engineering (PDF) . A Volume of the Computing Curricula Series. IEEE Computer Society and Association for Computing Machinery . {{ cite book }} :  CS1 maint: multiple names: authors list ( link ) ^ Systems and software engineering \u2013 Vocabulary , ISO / IEC / IEEE std 24765:2010(E), 2010. ^ IEEE Standard Glossary of Software Engineering Terminology , IEEE std 610.12-1990, 1990. ^ Sommerville, Ian (2007) [1982]. \"1.1.2 What is software engineering?\" . Software Engineering (8th\u00a0ed.). Harlow, England: Pearson Education. p.\u00a07. ISBN 978-0-321-31379-9 . Software engineering is an engineering discipline that is concerned with all aspects of software production, from the early stages of system specification to maintaining the system after it has gone into use. The definition highlights two key ideas: (1) engineering discipline \u2014the application of theories, methods, and tools within organizational and financial constraints; and (2) all aspects of software production \u2014including technical development processes, project management, and the creation of supporting tools, methods, and theories. ^ \"Software Engineering\". Information Processing . 71 : 530\u2013 538. ^ \"Definition of SOFTWARE ENGINEERING\" . www.merriam-webster.com . Retrieved 2019-11-25 . ^ Winters, Titus; Manshrec, Tom; Wright, Hyrum (2020). \"Preface, Programming Over Time\". Software Engineering at Google . O'Reilly Media, Inc. pp. xix\u2013 xx, 6\u2013 7. ISBN 978-1-492-08279-8 . We propose that \"software engineering\" encompasses not just the act of writing code, but all of the tools and processes an organization uses to build and maintain that code over time. What practices can a software organization introduce that will best keep its code valuable over the long term? How can engineers make a codebase more sustainable and the software engineering discipline itself more rigorous? ^ Akram I. Salah (2002-04-05). \"Engineering an Academic Program in Software Engineering\" (PDF) . 35th Annual Midwest Instruction and Computing Symposium . Retrieved 2006-09-13 . : \"For some, software engineering is just a glorified name for programming. If you are a programmer, you might put 'software engineer' on your business card\u2014never 'programmer' though.\" ^ Mills, Harlan D., J. R. Newman, and C. B. Engle, Jr., \"An Undergraduate Curriculum in Software Engineering,\" in Deimel, Lionel E. (1990). Software Engineering Education: SEI Conference 1990, Pittsburgh, Pennsylvania, USA, April 2\u20133,.. . Springer. ISBN 978-0-387-97274-9 . , p. 26 : \"As a practical matter, we regard software engineering as the necessary preparation for the practicing, software development and maintenance professional. The Computer Scientist is preparing for further theoretical studies...\" ^ Barbara Kitchevnham; David Budgen; Pearl Brereton; Stephen Linkman (2005). \"Realising evidence-based software engineering\". ACM SIGSOFT Software Engineering Notes . 30 (4): 1\u2013 3. doi : 10.1145/1082983.1083175 . We believe that software engineering can only advance as an engineering discipline by moving away from its current dependence upon advocacy and analysis, ... ^ Parnas, David L. (1998). \"Software Engineering Programmes are not Computer Science Programmes\" . Annals of Software Engineering . 6 ( 1\u2013 4): 19\u2013 37. doi : 10.1023/A:1018949113292 . S2CID 35786237 . , p. 19: \"Rather than treat software engineering as a subfield of computer science, I treat it as an element of the set, {Civil Engineering, Mechanical Engineering, Chemical Engineering, Electrical Engineering,....}.\" ^ Parnas, David L. (1998). \"Software Engineering Programmes are not Computer Science Programmes\" . Annals of Software Engineering . 6 ( 1\u2013 4): 19\u2013 37. doi : 10.1023/A:1018949113292 . S2CID 35786237 . , p. 20: \"This paper argues that the introduction of accredited professional programs in software engineering, programmes that are modelled on programmes in traditional engineering disciplines will help to increase both the quality and quantity of graduates who are well prepared, by their education, to develop trustworthy software products.\" ^ McConnell, Steve (August 2003). Professional Software Development: Shorter Schedules, Better Projects, Superior Products, Enhanced Careers . Boston, MA: Addison-Wesley. ISBN 0-321-19367-9 . , p. 39: \"In my opinion, the answer to that question is clear: Professional software development should be engineering. Is it? No. But should it be? Unquestionably, yes. \" ^ Knuth, Donald (1974). \"Computer Programming as an Art\" (PDF) . Communications of the ACM . 17 (12): 667\u2013 673. doi : 10.1145/361604.361612 . S2CID 207685720 . Transcript of the 1974 Turing Award lecture. ^ Dijkstra, Edsger W ; transcribed by Mario B\u00e9land (November 23, 2004) [First published December 3, 1993]. \"There is still a war going on (manuscript Austin, 3 December 1993)\" . E. W. Dijkstra Archive . The University of Texas at Austin, Department of Computer Sciences . Retrieved February 17, 2007 . When the term was coined in 1968 by F.L. Bauer of the Technological University of Munich, I welcomed it. [. . .] I interpreted the introduction of the term \"software engineering\" as an apt reflection of the fact that the design of software systems was an activity par excellence for the mathematical engineer. [. . .]. As soon the term arrived in the USA, it was relieved of all its technical content. It had to be so for in its original meaning it was totally unacceptable [. . .] In the meantime, software engineering has become an almost empty term, as was nicely demonstrated by Data General who overnight promoted all its programmers to the exalted rank of \"software engineer\"! ^ \"Software Engineering | Classification of Software Requirements\" . GeeksforGeeks . 2018-06-19 . Retrieved 2021-05-06 . ^ \"Software Engineering | Software Design Process\" . GeeksforGeeks . 2019-05-24 . Retrieved 2021-05-06 . ^ Jamil, Muhammad Abid; Arif, Muhammad; Abubakar, Normi Sham Awang; Ahmad, Akhlaq (November 2016). \"Software Testing Techniques: A Literature Review\". 2016 6th International Conference on Information and Communication Technology for the Muslim World (ICT4M) . pp. 177\u2013 182. doi : 10.1109/ICT4M.2016.045 . ISBN 978-1-5090-4521-1 . ^ \"What is Software Maintenance? Definition of Software Maintenance, Software Maintenance Meaning\" . The Economic Times . Retrieved 2021-05-06 . ^ Alain Abran; James W. Moore; Pierre Bourque; Robert Dupuis; Leonard L. Tripp, eds. (2005) [2004]. \"Chapter 1: Introduction to the Guide\" . Guide to the Software Engineering Body of Knowledge . IEEE Computer Society . Archived from the original on 2016-05-09 . Retrieved 2010-09-13 . The total volume of cited literature is intended to be suitable for mastery through the completion of an undergraduate education plus four years of experience. ^ Cowling, A. J. 1999. The first decade of an undergraduate degree program in software engineering. Ann. Softw. Eng. 6, 1\u20134 (Apr. 1999), 61\u201390. ^ \"ABET Accredited Engineering Programs\" . April 3, 2007. Archived from the original on June 19, 2010 . Retrieved April 3, 2007 . ^ McConnell, Steve (July 10, 2003). Professional Software Development: Shorter Schedules, Higher Quality Products, More Successful Projects, Enhanced Careers . ISBN 978-0-321-19367-4 . ^ Williams, N.S.W. (19\u201321 February 2001). \"Professional Engineers Ontario's approach to licensing software engineering practitioners\". Software Engineering Education and Training, 2001 Proceedings. 14th Conference on . Charlotte, NC: IEEE . pp. 77\u2013 78. ^ \"NCEES Software Engineering Exam Specifications\" (PDF) . Archived from the original (PDF) on 2013-08-27 . Retrieved 2012-04-01 . ^ \"NCEES discontinuing PE Software Engineering exam\" . National Council of Examiners for Engineering and Surveying. 13 March 2018 . Retrieved 6 August 2018 . ^ a b Barbara Simons. \"Past ACM Presidents Reflect on Their Service to ACM\" . Celebrating 75 Years of Advancing Computing as a Science & Profession. Association for Computing Machinery . Retrieved May 18, 2024 . After the panels' recommendations were submitted, ACM Council concluded that the framework of a licensed professional engineer, originally developed for civil engineers, does not match the professional industrial practice of software engineering and would preclude many of the most qualified software engineers from becoming licensed. ^ a b John C. Knight; Nancy G. Leveson (November 1, 2002). \"Should software engineers be licensed?\". Communications of the ACM . 45 (11): 87\u2013 90. doi : 10.1145/581571.581601 . ^ \" Software Engineering Code of Ethics \" (PDF) . Archived from the original (PDF) on 2015-01-23 . Retrieved 2012-03-25 . ^ Labs, Qubit (29 November 2022). \"How Many Programmers are there in the World and in the US? [2023]\" . Qubit Labs . Retrieved 7 February 2023 . ^ \"Global Developer Population and Demographic Study 2016 V2\" . Evans Data Corporation . Retrieved 19 January 2017 . ^ a b Rosenthal, Rachel (August 4, 2020). \"Tech Companies Want You to Believe America Has a Skills Gap\" . Bloomberg . Retrieved October 8, 2021 . ^ \"Computer Software Engineers and Computer Programmers\" . Retrieved 2009-12-17 . ^ \"Software Developers\" . Occupational Outlook Handbook . U. S. Bureau of labor Statistics. 4 September 2019 . Retrieved 11 December 2019 . ^ \"Computing Disciplines and Majors\" (PDF) . Association for Computing Machinery . Retrieved 6 September 2019 . ^ a b \"Software Developers: Occupational Outlook Handbook\" . U.S. Bureau of Labor Statistics. ^ \"Computer Software Engineer\" . Bureau of Labor Statistics. March 19, 2010. Archived from the original on July 26, 2013 . Retrieved July 20, 2012 . ^ \"Software Developers\" . Bureau of Labor Statistics. January 8, 2014 . Retrieved July 21, 2012 . ^ a b c d e \"Computer Programmers\u00a0: Occupational Outlook Handbook:\u00a0: U.S. Bureau of Labor Statistics\" . Archived from the original on 3 May 2019 . Retrieved 17 January 2017 . ^ \"Archive By Publication\u00a0: Beyond the Numbers: U.S. Bureau of Labor Statistics\" . www.bls.gov . ^ \"The Soon-to-Be-Extinct Embedded Software Engineer\" . designnews.com . May 10, 2018. ^ \"hp's Developer Portal | HP International Women's Week: Women in Computer Science dropping since 1980s\" . developers.hp.com . ^ \"Software engineer jobs in danger due to ChatGPT-like tools? Here's what Google CEO Sundar Pichai has to say\" . Business Today . 2023-04-06 . Retrieved 2023-05-12 . ^ \"ChatGPT could make these jobs obsolete\" . 2023-01-25 . Retrieved 2023-05-12 . ^ Kay, Grace. \"Software engineers are panicking about being replaced by AI\" . Business Insider . Retrieved 2023-05-12 . ^ Fowler, Gary. \"Council Post: How Will ChatGPT Affect Jobs?\" . Forbes . Retrieved 2023-05-12 . ^ Ito, Aki. \"ChatGPT spells the end of coding as we know it\" . Business Insider . Retrieved 2023-05-12 . ^ Zinkula, Aaron Mok, Jacob. \"ChatGPT may be coming for our jobs. Here are the 10 roles that AI is most likely to replace\" . Business Insider . Retrieved 2023-05-12 . {{ cite web }} :  CS1 maint: multiple names: authors list ( link ) ^ Cohen, Mikaela (15 April 2023). \"These are the tech jobs most threatened by ChatGPT and A.I.\" CNBC . Retrieved 2023-05-12 . ^ \" \"Learn to Code\" Backfires Spectacularly as Comp-Sci Majors Suddenly Have Sky-High Unemployment\" . 31 May 2025. ^ \"SEI certification page\" . Sei.cmu.edu . Retrieved 2012-03-25 . ^ Wyrostek, Warren (March 14, 2008). \"The Top 10 Problems with IT Certification in 2008\" . InformIT . Retrieved 2009-03-03 . ^ IEEE Computer Society . \"2006 IEEE computer society report to the IFIP General Assembly\" (PDF) . Retrieved 2007-04-10 . ^ IEEE (12 November 2008). \"CSDA\" . Retrieved 2010-04-20 . ^ Canadian Information Processing Society. \"I.S.P. Designation\" . Retrieved 2007-03-15 . ^ \"Professional Engineers Ontario: Welcome to PEO's website\" . Peo.on.ca . Retrieved 2012-03-25 . ^ Thibodaux, Patrick (2006-05-05). \"As outsourcing gathers steam, computer science interest wanes\" . Computerworld.com . Retrieved 2016-12-06 . ^ \"Work weeks are getting more intense for AI startups\" . ^ Robert Mullins (March 13, 2007). \"Software developer growth slows in North America: Study shows Asia will lead in software developer jobs by 2010\" . InfoWorld . Software Development. ^ \"Gartner Magic Quadrant\" (PDF) . Cognizant.com. Archived from the original (PDF) on 2008-09-20 . Retrieved 2012-03-25 . ^ Casey, Valentine (2010-08-20). \"Virtual software team project management\" . Journal of the Brazilian Computer Society . 16 (2): 83\u2013 96. doi : 10.1007/s13173-010-0013-3 . S2CID 14383734 . ^ \"Outstanding Research Award\" . SIGSOFT . Retrieved 1 April 2024 . ^ David Lo ( SIGSOFT Awards Chair); Thomas Zimmermann ( SIGSOFT Chair) (17 January 2024). \"SIGSOFT Awards 2024\" . ACM SIGSOFT Blog . Retrieved 1 April 2024 . ^ \"ICSE Most Influential Paper Award\" . ACM SIGSOFT . ^ Donald J. Bagert (April 1999). \"Viewpoint: taking the lead in licensing software engineers\". Communications of the ACM . 42 (4): 27\u2013 29. doi : 10.1145/299157.299163 . ^ a b Barry Boehm (September\u2013October 2002). \"Software engineering is a value-based contact sport\". IEEE Software . 19 (5): 95\u2013 96. doi : 10.1109/MS.2002.1032863 . ^ Dijkstra, E. W. (1988). \"On the cruelty of really teaching computing science\" . Retrieved 2014-01-10 . Sources [ edit ] Pierre Bourque; Richard E. (Dick) Fairley, eds. (2014). Guide to the Software Engineering Body of Knowledge Version 3.0 (SWEBOK) . IEEE Computer Society . Alain Abran; James W. Moore; Pierre Bourque; Robert Dupuis; Leonard L. Tripp, eds. (2004). Guide to the Software Engineering Body of Knowledge . IEEE Computer Society . Archived from the original on 2016-05-09 . Retrieved 2010-09-13 . Ian Sommerville (March 24, 2015). Software Engineering (10th\u00a0ed.). Pearson Education Limited. ISBN 978-0-13-394303-0 . Further reading [ edit ] Pierre Bourque; Richard E. (Dick) Fairley, eds. (2014). Guide to the Software Engineering Body of Knowledge Version 3.0 (SWEBOK) . IEEE Computer Society . Roger S. Pressman; Bruce Maxim (January 23, 2014). Software Engineering: A Practitioner's Approach (8th\u00a0ed.). McGraw-Hill. ISBN 978-0-07-802212-8 . Ian Sommerville (March 24, 2015). Software Engineering (10th\u00a0ed.). Pearson Education Limited. ISBN 978-0-13-394303-0 . Jalote, Pankaj (2005) [1991]. An Integrated Approach to Software Engineering (3rd\u00a0ed.). Springer. ISBN 978-0-387-20881-7 . Bruegge, Bernd ; Dutoit, Allen (2009). Object-oriented software engineering\u00a0: using UML, patterns, and Java (3rd\u00a0ed.). Prentice Hall. ISBN 978-0-13-606125-0 . Oshana, Robert (2019-06-21). Software engineering for embedded systems\u00a0: methods, practical techniques, and applications (Second\u00a0ed.). Kidlington, Oxford, United Kingdom. ISBN 978-0-12-809433-4 . External links [ edit ] Wikimedia Commons has media related to Rekayasa Perangkat Lunak . Wikiversity has learning resources about Software engineering Pierre Bourque; Richard E. Fairley, eds. (2004). Guide to the Software Engineering Body of Knowledge Version 3.0 (SWEBOK) , https://www.computer.org/web/swebok/v3 . IEEE Computer Society . The Open Systems Engineering and Software Development Life Cycle Framework Archived 2010-07-18 at the Wayback Machine OpenSDLC.org the integrated Creative Commons SDLC Software Engineering Institute Carnegie Mellon v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons v t e Systems engineering Subfields Aerospace engineering Biological systems engineering Cognitive systems engineering Configuration management Earth systems engineering and management Electrical engineering Enterprise systems engineering Health systems engineering Performance engineering Reliability engineering Safety engineering Sociocultural Systems Engineering Processes Requirements engineering Functional Analysis and Allocation System integration Verification and validation Design review System of systems engineering Concepts Business process Fault tolerance System System lifecycle V-Model Systems development life cycle Tools Decision-making Function modelling IDEF Optimization Quality function deployment Spare part System dynamics Systems Modeling Language Systems analysis Systems modeling Work breakdown structure People James S. Albus Ruzena Bajcsy Benjamin S. Blanchard Wernher von Braun Kathleen Carley Harold Chestnut Wolt Fabrycky Barbara Grosz Arthur David Hall III Derek Hitchins Robert E. Machol Radhika Nagpal Simon Ramo Joseph Francis Shea Katia Sycara Manuela M. Veloso John N. Warfield Related fields Control engineering Computer engineering Industrial engineering Operations research Project management Quality management Risk management Software engineering Category v t e Engineering History Outline List of engineering branches Specialties and interdisciplinarity Civil Architectural Coastal Construction Earthquake Ecological Environmental Sanitary Geological Geotechnical Hydraulic Mining Municipal/urban Offshore River Structural Transportation Traffic Railway Mechanical Acoustic Aerospace Automotive Biomechanical Energy Manufacturing Marine Naval architecture Railway Sports Thermal Tribology Electrical Broadcast outline Control Electromechanics Electronics Microwaves Optical Power Radio-frequency Signal processing Telecommunications Chemical Biochemical/bioprocess Biological Bioresource Genetic Tissue Chemical reaction Electrochemical Food Molecular Paper Petroleum Process Reaction Materials Biomaterial Ceramics Corrosion Metallurgy Molecular Nanotechnology Polymers Semiconductors Surfaces Computer AI Computer Cybersecurity Data Networks Robotics Software Engineering education Bachelor of Engineering Bachelor of Science Master's degree Doctorate Graduate certificate Engineer's degree Licensed engineer Related topics Engineer Glossaries Engineering A\u2013L M\u2013Z Aerospace engineering Civil engineering Electrical and electronics engineering Mechanical engineering Structural engineering Other Agricultural Audio Automation Biomedical Bioinformatics Clinical Health technology Pharmaceutical Rehabilitation Building services MEP Design Explosives Facilities Fire Forensic Climate Geomatics Graphics Industrial Information Instrumentation Instrumentation and control Logistics Management Mathematics Mechatronics Military Nuclear Ontology Packaging Physics Privacy Safety Security Survey Sustainability Systems Textile Category Commons Wikiproject Portal v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control flow Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Computational problem Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human-centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human\u2013computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Specialized Platform\nDevelopment Thermodynamic computing Category Outline Glossaries Authority control databases International GND FAST National United States France BnF data Japan Czech Republic 2 Spain Israel Other Yale LUX Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_engineering&oldid=1328155502 \" Categories : Software engineering Engineering disciplines Hidden categories: Harv and Sfn no-target errors CS1 maint: numeric names: authors list CS1 maint: multiple names: authors list Articles with short description Short description is different from Wikidata Articles with limited geographic scope from November 2010 Articles containing potentially dated statements from 2010 All articles containing potentially dated statements Articles containing potentially dated statements from 2004 Articles with limited geographic scope from September 2021 Articles containing potentially dated statements from 2006 Commons category link is locally defined Commons category link from Wikidata Webarchive template wayback links This page was last edited on 18 December 2025, at 04:56 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software engineering 84 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_development_process",
    "title": "Software development process - Wikipedia",
    "content": "Software development process - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Methodology Toggle Methodology subsection 1.1 History 1.2 Examples 1.3 Comparison 2 Process meta-models 3 See also 4 References 5 External links Toggle the table of contents Software development process 31 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Az\u0259rbaycanca \u09ac\u09be\u0982\u09b2\u09be Catal\u00e0 \u010ce\u0161tina \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 \u0939\u093f\u0928\u094d\u0926\u0940 Bahasa Indonesia Italiano Latvie\u0161u Magyar Nederlands \u65e5\u672c\u8a9e O\u02bbzbekcha / \u045e\u0437\u0431\u0435\u043a\u0447\u0430 Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u06a9\u0648\u0631\u062f\u06cc \u0421\u0440\u043f\u0441\u043a\u0438 / srpski \u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0627\u0631\u062f\u0648 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Process by which software is developed This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Software development process\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( December 2010 ) ( Learn how and when to remove this message ) Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e A software development process prescribes a process for developing software . It typically divides an overall effort into smaller steps or sub-processes that are intended to ensure high-quality results. The process may describe specific deliverables \u2013 artifacts to be created and completed. [ 1 ] Although not strictly limited to it, software development process often refers to the high-level process that governs the development of a software system from its beginning to its end of life \u2013 known as a methodology, model or framework. The system development life cycle (SDLC) describes the typical phases that a development effort goes through from the beginning to the end of life for a system \u2013 including a software system. A methodology prescribes how engineers go about their work in order to move the system through its life cycle. A methodology is a classification of processes or a blueprint for a process that is devised for the SDLC. For example, many processes can be classified as a spiral model. Software process and software quality are closely interrelated; some unexpected facets and effects have been observed in practice. [ 2 ] Methodology [ edit ] The SDLC drives the definition of a methodology in that a methodology must address the phases of the SDLC. Generally, a methodology is designed to result in a high-quality system that meets or exceeds expectations (requirements) and is delivered on time and within budget even though computer systems can be complex and integrate disparate components. [ 3 ] Various methodologies have been devised, including waterfall , spiral , agile , rapid prototyping , incremental , and synchronize and stabilize. [ 4 ] A major difference between methodologies is the degree to which the phases are sequential vs. iterative. Agile methodologies, such as XP and scrum , focus on lightweight processes that allow for rapid changes. [ 5 ] Iterative methodologies, such as Rational Unified Process and dynamic systems development method , focus on stabilizing project scope and iteratively expanding or improving products. Sequential or big-design-up-front (BDUF) models, such as waterfall, focus on complete and correct planning to guide larger projects and limit risks to successful and predictable results. [ 6 ] Anamorphic development is guided by project scope and adaptive iterations. In scrum, [ 7 ] for example, one could say a single user story goes through all the phases of the SDLC within a two-week sprint. By contrast the waterfall methodology, where every business requirement [ citation needed ] is translated into feature/functional descriptions which are then all implemented typically over a period of months or longer. [ citation needed ] A project can include both a project life cycle (PLC) and an SDLC, which describe different activities. According to Taylor (2004), \"the project life cycle encompasses all the activities of the project , while the systems development life cycle focuses on realizing the product requirements \". [ 8 ] History [ edit ] The term SDLC is often used as an abbreviated version of SDLC methodology . Further, some use SDLC and traditional SDLC to mean the waterfall methodology. According to Elliott (2004), SDLC \"originated in the 1960s, to develop large scale functional business systems in an age of large scale business conglomerates . Information systems activities revolved around heavy data processing and number crunching routines\". [ 9 ] The structured systems analysis and design method (SSADM) was produced for the UK government Office of Government Commerce in the 1980s. Ever since, according to Elliott (2004), \"the traditional life cycle approaches to systems development have been increasingly replaced with alternative approaches and frameworks, which attempted to overcome some of the inherent deficiencies of the traditional SDLC\". [ 9 ] The main idea of the SDLC has been \"to pursue the development of information systems in a very deliberate, structured and methodical way, requiring each stage of the life cycle\u2013\u2013from the inception of the idea to delivery of the final system\u2013\u2013to be carried out rigidly and sequentially\" [ 9 ] within the context of the framework being applied. Other methodologies were devised later: 1970s Structured programming since 1969 Cap Gemini SDM , originally from PANDATA, the first English translation was published in 1974. SDM stands for System Development Methodology 1980s Structured systems analysis and design method (SSADM) from 1980 onwards Information Requirement Analysis/Soft systems methodology 1990s Object-oriented programming (OOP) developed in the early 1960s and became a dominant programming approach during the mid-1990s Rapid application development (RAD), since 1991 Dynamic systems development method (DSDM), since 1994 Scrum , since 1995 Team software process , since 1998 Rational Unified Process (RUP), maintained by IBM since 1998 Extreme programming , since 1999 2000s Agile Unified Process (AUP) maintained since 2005 by Scott Ambler Disciplined agile delivery (DAD) Supersedes AUP 2010s Scaled Agile Framework (SAFe) Large-Scale Scrum (LeSS) DevOps Since DSDM in 1994, all of the methodologies on the above list except RUP have been agile methodologies - yet many organizations, especially governments, still use pre-agile processes (often waterfall or similar). Examples [ edit ] The following are notable methodologies somewhat ordered by popularity. Agile Agile software development refers to a group of frameworks based on iterative development, where requirements and solutions evolve via collaboration between self-organizing cross-functional teams. The term was coined in the year 2001 when the Agile Manifesto was formulated. Waterfall The waterfall model is a sequential development approach, in which development flows one-way (like a waterfall) through the SDLC phases. Spiral In 1988, Barry Boehm published a software system development spiral model , which combines key aspects of the waterfall model and rapid prototyping , in an effort to combine advantages of top-down and bottom-up concepts. It emphases a key area many felt had been neglected by other methodologies: deliberate iterative risk analysis, particularly suited to large-scale complex systems. Incremental Various methods combine linear and iterative methodologies , with the primary objective of reducing inherent project risk by breaking a project into smaller segments and providing more ease-of-change during the development process. Prototyping Software prototyping is about creating prototypes, i.e. incomplete versions of the software program being developed. Rapid Rapid application development (RAD) is a methodology which favors iterative development and the rapid construction of prototypes instead of large amounts of up-front planning. The \"planning\" of software developed using RAD is interleaved with writing the software itself. The lack of extensive pre-planning generally allows software to be written much faster and makes it easier to change requirements. Shape Up Shape Up is a software development approach introduced by Basecamp in 2018. It is a set of principles and techniques that Basecamp developed internally to overcome the problem of projects dragging on with no clear end. Its primary target audience is remote teams. Shape Up has no estimation and velocity tracking, backlogs, or sprints, unlike waterfall , agile , or scrum . Instead, those concepts are replaced with appetite, betting, and cycles. As of 2022, besides Basecamp, notable organizations that have adopted Shape Up include UserVoice and Block. [ 10 ] [ 11 ] Chaos Chaos model has one main rule: always resolve the most important issue first. Incremental funding Incremental funding methodology - an iterative approach. Lightweight Lightweight methodology - a general term for methods that only have a few rules and practices. Structured systems analysis and design Structured systems analysis and design method - a specific version of waterfall. Slow programming As part of the larger slow movement , emphasizes careful and gradual work without (or minimal) time pressures. Slow programming aims to avoid bugs and overly quick release schedules. V-Model V-Model (software development) - an extension of the waterfall model. Unified Process Unified Process (UP) is an iterative software development methodology framework, based on Unified Modeling Language (UML). UP organizes the development of software into four phases, each consisting of one or more executable iterations of the software at that stage of development: inception, elaboration, construction, and guidelines. Comparison [ edit ] This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. ( January 2024 ) ( Learn how and when to remove this message ) The waterfall model describes the SDLC phases such that each builds on the result of the previous one. [ 12 ] [ 13 ] [ 14 ] [ 15 ] Not every project requires that the phases be sequential. For relatively simple projects, phases may be combined or overlapping. [ 12 ] Alternative methodologies to waterfall are described and compared below. [ 16 ] Comparison of methodologies Waterfall RAD Open source OOP JAD proto-typing End User Control Formal MIS Weak Standards Joint User User Time frame Long Short Medium Any Medium Short Short \u2013 Users Many Few Few Varies Few One or two One MIS staff Many Few Hundreds Split Few One or two None Transaction/ DSS Transaction Both Both Both DSS DSS DSS Interface Minimal Minimal Weak Windows Crucial Crucial Crucial Documentation and training Vital Limited Internal In Objects Limited Weak None Integrity and security Vital Vital Unknown In Objects Limited Weak Weak Reusability Limited Some Maybe Vital Limited Weak None Process meta-models [ edit ] Further information: Process patterns Some process models are abstract descriptions for evaluating, comparing, and improving the specific process adopted by an organization. ISO/IEC 12207 ISO/IEC 12207 is the international standard describing the method to select, implement, and monitor the life cycle for software. Capability Maturity Model Integration The Capability Maturity Model Integration (CMMI) is one of the leading models and is based on best practices. Independent assessments grade organizations on how well they follow their defined processes, not on the quality of those processes or the software produced. CMMI has replaced CMM . ISO 9000 ISO 9000 describes standards for a formally organized process to manufacture a product and the methods of managing and monitoring progress. Although the standard was originally created for the manufacturing sector, ISO 9000 standards have been applied to software development as well. Like CMMI, certification with ISO 9000 does not guarantee the quality of the end result, only that formalized business processes have been followed. ISO/IEC 15504 ISO/IEC 15504 Information technology\u2014Process assessment , a.k.a. Software Process Improvement Capability Determination (SPICE), is a framework for the assessment of software processes. This standard is aimed at setting out a clear model for process comparison. SPICE is used much like CMMI. It models processes to manage, control, guide, and monitor software development. This model is then used to measure what a development organization or project team actually does during software development. This information is analyzed to identify weaknesses and drive improvement. It also identifies strengths that can be continued or integrated into common practice for that organization or team. ISO/IEC 24744 ISO/IEC 24744 Software Engineering\u2014Metamodel for Development Methodologies , is a power type-based metamodel for software development methodologies. Soft systems methodology Soft systems methodology is a general method for improving management processes. Method engineering Method engineering is a general method for improving information system processes. See also [ edit ] Computer-aided software engineering List of software development philosophies Outline of software engineering Program lifecycle phase Software development effort estimation Software documentation Software project management Software release life cycle References [ edit ] ^ \"Selecting a development approach\" (PDF) . Centers for Medicare & Medicaid Services (CMS) Office of Information Service . United States Department of Health and Human Services (HHS). March 27, 2008 [Original Issuance: February 17, 2005]. Archived from the original (PDF) on June 20, 2012 . Retrieved October 27, 2008 . ^ Suryanarayana, Girish (2015). \"Software Process versus Design Quality: Tug of War?\" . IEEE Software . 32 (4): 7\u2013 11. doi : 10.1109/MS.2015.87 . ^ \"Systems Development Life Cycle from\" . FOLDOC . Retrieved June 14, 2013 . ^ \"Software Development Life Cycle (SDLC)\" (PDF) . softwarelifecyclepros.com . May 2012 . Retrieved June 26, 2025 . ^ \"SDLC Overview: Models & Methodologies\" . Retrieved December 12, 2021 . ^ Arden, Trevor (1991). Information technology applications . London: Pitman. ISBN 978-0-273-03470-4 . ^ \"What is Scrum?\" . December 24, 2019. ^ Taylor, James (2004). Managing Information Technology Projects . p.\u00a039. ^ a b c Geoffrey Elliott (2004). Global Business Information Technology: an integrated systems approach . Pearson Education. p.\u00a087. ^ \"Foreword by Jason Fried | Shape Up\" . basecamp.com . Retrieved September 11, 2022 . ^ \"Is Shape Up just a nice theory?\" . Curious Lab . Retrieved September 12, 2022 . ^ a b US Department of Justice (2003). INFORMATION RESOURCES MANAGEMENT Chapter 1. Introduction. ^ Everatt, G.D.; McLeod, R Jr (2007). \"Chapter 2: The Software Development Life Cycle\" . Software Testing: Testing Across the Entire Software Development Life Cycle . John Wiley & Sons. pp. 29\u2013 58. ISBN 9780470146347 . ^ Unhelkar, B. (2016). The Art of Agile Practice: A Composite Approach for Projects and Organizations . CRC Press. pp. 56\u2013 59. ISBN 9781439851197 . ^ Land, S.K. ; Smith, D.B.; Walz, J.W. (2012). Practical Support for Lean Six Sigma Software Process Definition: Using IEEE Software Engineering Standards . John Wiley & Sons. pp. 341\u2013 3. ISBN 9780470289952 . ^ Post, G., & Anderson, D., (2006). Management information systems: Solving business problems with information technology . (4th ed.).  New York:  McGraw-Hill Irwin. External links [ edit ] Wikimedia Commons has media related to Software development methodology . Selecting a development approach Archived January 2, 2019, at the Wayback Machine at cms.hhs.gov. Gerhard Fischer, \"The Software Technology of the 21st Century: From Software Reuse to Collaborative Software Design\" Archived September 15, 2009, at the Wayback Machine , 2001 v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_development_process&oldid=1325364542 \" Categories : Software development process Methodology Software engineering Hidden categories: Articles with short description Short description matches Wikidata Use mdy dates from December 2023 Articles needing additional references from December 2010 All articles needing additional references Use American English from April 2022 All Wikipedia articles written in American English All articles with unsourced statements Articles with unsourced statements from August 2021 Articles needing additional references from January 2024 Commons category link is on Wikidata Webarchive template wayback links This page was last edited on 2 December 2025, at 18:16 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software development process 31 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Data_modeling",
    "title": "Data modeling - Wikipedia",
    "content": "Data modeling - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Overview 2 Topics Toggle Topics subsection 2.1 Data models 2.2 Conceptual, logical and physical schemas 2.3 Data modeling process 2.4 Modeling methodologies 2.5 Entity\u2013relationship diagrams 2.6 Generic data modeling 2.7 Semantic data modeling 3 See also 4 References 5 Further reading 6 External links Toggle the table of contents Data modeling 23 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 \u010ce\u0161tina Cymraeg Deutsch \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 \u0939\u093f\u0928\u094d\u0926\u0940 Bahasa Indonesia Italiano \u65e5\u672c\u8a9e Norsk bokm\u00e5l Portugu\u00eas Shqip Suomi \u0ba4\u0bae\u0bbf\u0bb4\u0bcd T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0627\u0631\u062f\u0648 Ti\u1ebfng Vi\u1ec7t \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Creating a model of the data in a system This article duplicates the scope of other articles , specifically Data model . Please discuss this issue and help introduce a summary style to the article. ( March 2023 ) The data modeling process. The figure illustrates the way data models are developed and used today . A conceptual data model is developed based on the data requirements for the application that is being developed, perhaps in the context of an activity model . The data model will normally consist of entity types, attributes, relationships, integrity rules, and the definitions of those objects. This is then used as the start point for interface or database design. [ 1 ] Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Data modeling in software engineering is the process of creating a data model for an information system by applying certain formal techniques. It may be applied as part of broader Model-driven engineering (MDE) concept. Overview [ edit ] Data modeling is a process used to define and analyze data requirements needed to support the business processes within the scope of corresponding information systems in organizations. Therefore, the process of data modeling involves professional data modelers working closely with business stakeholders, as well as potential users of the information system. There are three different types of data models produced while progressing from requirements to the actual database to be used for the information system. [ 2 ] The data requirements are initially recorded as a conceptual data model which is essentially a set of technology independent specifications about the data and is used to discuss initial requirements with the business stakeholders. The conceptual model is then translated into a logical data model , which documents structures of the data that can be implemented in databases. Implementation of one conceptual data model may require multiple logical data models. The last step in data modeling is transforming the logical data model to a physical data model that organizes the data into tables, and accounts for access, performance and storage details. Data modeling defines not just data elements, but also their structures and the relationships between them. [ 3 ] Data modeling techniques and methodologies are used to model data in a standard, consistent, predictable manner in order to manage it as a resource. The use of data modeling standards is strongly recommended for all projects requiring a standard means of defining and analyzing data within an organization, e.g., using data modeling: to assist business analysts, programmers, testers, manual writers, IT package selectors, engineers, managers, related organizations and clients to understand and use an agreed-upon semi-formal model that encompasses the concepts of the organization and how they relate to one another to manage data as a resource to integrate information systems to design databases/ data warehouses (aka data repositories) Data modelling may be performed during various types of projects and in multiple phases of projects. Data models are progressive; there is no such thing as the final data model for a business or application. Instead, a data model should be considered a living document that will change in response to a changing business. The data models should ideally be stored in a repository so that they can be retrieved, expanded, and edited over time. Whitten et al. (2004) determined two types of data modelling: [ 4 ] Strategic data modelling: This is part of the creation of an information systems strategy, which defines an overall vision and architecture for information systems. Information technology engineering is a methodology that embraces this approach. Data modelling during systems analysis: In systems analysis logical data models are created as part of the development of new databases. Data modelling is also used as a technique for detailing business requirements for specific databases . It is sometimes called database modelling because a data model is eventually implemented in a database. [ 4 ] Topics [ edit ] Data models [ edit ] Main article: Data model How data models deliver benefit. [ 1 ] Data models provide a framework for data to be used within information systems by providing specific definitions and formats. If a data model is used consistently across systems then compatibility of data can be achieved. If the same data structures are used to store and access data then different applications can share data seamlessly. The results of this are indicated in the diagram. However, systems and interfaces are often expensive to build, operate, and maintain. They may also constrain the business rather than support it. This may occur when the quality of the data models implemented in systems and interfaces is poor. [ 1 ] Some common problems found in data models are: Business rules, specific to how things are done in a particular place, are often fixed in the structure of a data model. This means that small changes in the way business is conducted lead to large changes in computer systems and interfaces. So, business rules need to be implemented in a flexible way that does not result in complicated dependencies, rather the data model should be flexible enough so that changes in the business can be implemented within the data model in a relatively quick and efficient way. Entity types are often not identified, or are identified incorrectly.  This can lead to replication of data, data structure and functionality, together with the attendant costs of that duplication in development and maintenance. Therefore, data definitions should be made as explicit and easy to understand as possible to minimize misinterpretation and duplication. Data models for different systems are arbitrarily different. The result of this is that complex interfaces are required between systems that share data. These interfaces can account for between 25 and 70% of the cost of current systems. Required interfaces should be considered inherently while designing a data model, as a data model on its own would not be usable without interfaces within different systems. Data cannot be shared electronically with customers and suppliers, because the structure and meaning of data have not been standardised. To obtain optimal value from an implemented data model, it is very important to define standards that will ensure that data models will both meet business needs and be consistent. [ 1 ] Conceptual, logical and physical schemas [ edit ] The ANSI/SPARC three-level architecture. This shows that a data model can be an external model (or view), a conceptual model, or a physical model. This is not the only way to look at data models, but it is a useful way, particularly when comparing models. [ 1 ] In 1975 ANSI described three kinds of data-model instance : [ 5 ] Conceptual schema : describes the semantics of a domain (the scope of the model). For example, it may be a model of the interest area of an organization or of an industry. This consists of entity classes, representing kinds of things of significance in the domain, and relationship assertions about associations between pairs of entity classes. A conceptual schema specifies the kinds of facts or propositions that can be expressed using the model. In that sense, it defines the allowed expressions in an artificial \"language\" with a scope that is limited by the scope of the model. Simply described, a conceptual schema is the first step in organizing the data requirements. Logical schema : describes the structure of some domain of information.  This consists of descriptions of (for example) tables, columns, object-oriented classes, and XML tags. The logical schema and conceptual schema are sometimes implemented as one and the same. [ 2 ] Physical schema : describes the physical means used to store data.  This is concerned with partitions, CPUs, tablespaces , and the like. According to ANSI, this approach allows the three perspectives to be relatively independent of each other. Storage technology can change without affecting either the logical or the conceptual schema. The table/column structure can change without (necessarily) affecting the conceptual schema.  In each case, of course, the structures must remain consistent across all schemas of the same data model. Data modeling process [ edit ] Further information: Database design Data modeling in the context of business process integration. [ 6 ] In the context of business process integration (see figure), data modeling complements business process modeling , and ultimately results in database generation. [ 6 ] The process of designing a database involves producing the previously described three types of schemas \u2013 conceptual, logical, and physical. The database design documented in these schemas is converted through a Data Definition Language , which can then be used to generate a database.  A fully attributed data model contains detailed attributes (descriptions) for every entity within it. The term \"database design\" can describe many different parts of the design of an overall database system . Principally, and most correctly, it can be thought of as the logical design of the base data structures used to store the data. In the relational model these are the tables and views . In an object database the entities and relationships map directly to object classes and named relationships. However, the term \"database design\" could also be used to apply to the overall process of designing, not just the base data structures, but also the forms and queries used as part of the overall database application within the Database Management System or DBMS. In the process, system interfaces account for 25% to 70% of the development and support costs of current systems. The primary reason for this cost is that these systems do not share a common data model . If data models are developed on a system by system basis, then not only is the same analysis repeated in overlapping areas, but further analysis must be performed to create the interfaces between them. Most systems within an organization contain the same basic data, redeveloped for a specific purpose. Therefore, an efficiently designed basic data model can minimize rework with minimal modifications for the purposes of different systems within the organization [ 1 ] Modeling methodologies [ edit ] See also: Model-driven engineering Data models represent information areas of interest. While there are many ways to create data models, according to Len Silverston (1997) [ 7 ] only two modeling methodologies stand out, top-down and bottom-up: Bottom-up models or View Integration models are often the result of a reengineering effort. They usually start with existing data structures forms, fields on application screens, or reports. These models are usually physical, application-specific, and incomplete from an enterprise perspective . They may not promote data sharing, especially if they are built without reference to other parts of the organization. [ 7 ] Top-down logical data models , on the other hand, are created in an abstract way by getting information from people who know the subject area. A system may not implement all the entities in a logical model, but the model serves as a reference point or template. [ 7 ] Sometimes models are created in a mixture of the two methods: by considering the data needs and structure of an application and by consistently referencing a subject-area model. In many environments, the distinction between a logical data model and a physical data model is blurred. In addition, some CASE tools don't make a distinction between logical and physical data models . [ 7 ] Entity\u2013relationship diagrams [ edit ] Main article: Entity\u2013relationship model Example of an IDEF1X entity\u2013relationship diagrams used to model IDEF1X itself. The name of the view is mm. The domain hierarchy and constraints are also given. The constraints are expressed as sentences in the formal theory of the meta model. [ 8 ] There are several notations for data modeling. The actual model is frequently called \"entity\u2013relationship model\", because it depicts data in terms of the entities and relationships described in the data . [ 4 ] An entity\u2013relationship model (ERM) is an abstract conceptual representation of structured data. Entity\u2013relationship modeling is a relational schema database modeling method, used in software engineering to produce a type of conceptual data model (or semantic data model ) of a system, often a relational database , and its requirements in a top-down fashion. These models are being used in the first stage of information system design during the requirements analysis to describe information needs or the type of information that is to be stored in a database . The data modeling technique can be used to describe any ontology (i.e. an overview and classifications of used terms and their relationships) for a certain universe of discourse i.e. the area of interest. Several techniques have been developed for the design of data models. While these methodologies guide data modelers in their work, two different people using the same methodology will often come up with very different results. Most notable are: Bachman diagrams Barker's notation Chen's notation Data Vault Modeling Extended Backus\u2013Naur form IDEF1X Object-relational mapping Object-Role Modeling and Fully Communication Oriented Information Modeling Relational Model Relational Model/Tasmania Generic data modeling [ edit ] Main article: Generic data model Example of a Generic data model. [ 9 ] Generic data models are generalizations of conventional data models . They define standardized general relation types, together with the kinds of things that may be related by such a relation type. \nThe definition of the generic data model is similar to the definition of a natural language. For example, a generic data model may define relation types such as a 'classification relation', being a binary relation between an individual thing and a kind of thing (a class) and a 'part-whole relation', being a binary relation between two things, one with the role of part, the other with the role of whole, regardless the kind of things that are related. Given an extensible list of classes, this allows the classification of any individual thing and to specification of part-whole relations for any individual object. By standardization of an extensible list of relation types, a generic data model enables the expression of an unlimited number of kinds of facts and will approach the capabilities of natural languages. Conventional data models, on the other hand, have a fixed and limited domain scope, because the instantiation (usage) of such a model only allows expressions of kinds of facts that are predefined in the model. Semantic data modeling [ edit ] Main article: Semantic data model The logical data structure of a DBMS, whether hierarchical, network, or relational, cannot totally satisfy the requirements for a conceptual definition of data because it is limited in scope and biased toward the implementation strategy employed by the DBMS. That is unless the semantic data model is implemented in the database on purpose, a choice which may slightly impact performance but generally vastly improves productivity. Semantic data models. [ 8 ] Therefore, the need to define data from a conceptual view has led to the development of semantic data modeling techniques. That is, techniques to define the meaning of data within the context of its interrelationships with other data. As illustrated in the figure the real world, in terms of resources, ideas, events, etc., is symbolically defined by its description within physical data stores. A semantic data model is an abstraction which defines how the stored symbols relate to the real world. Thus, the model must be a true representation of the real world. [ 8 ] The purpose of semantic data modeling is to create a structural model of a piece of the real world, called \"universe of discourse\". For this, three fundamental structural relations are considered: Classification/instantiation: Objects with some structural similarity are described as instances of classes Aggregation/decomposition: Composed objects are obtained by joining their parts Generalization/specialization: Distinct classes with some common properties are reconsidered in a more generic class with the common attributes A semantic data model can be used to serve many purposes, such as: [ 8 ] Planning of data resources Building of shareable databases Evaluation of vendor software Integration of existing databases The overall goal of semantic data models is to capture more meaning of data by integrating relational concepts with more powerful abstraction concepts known from the artificial intelligence field. The idea is to provide high-level modeling primitives as integral parts of a data model in order to facilitate the representation of real-world situations. [ 10 ] See also [ edit ] Architectural pattern Comparison of data modeling tools Data (computer science) Data dictionary Document modeling Enterprise data modelling Entity Data Model Information management Information model Building information modeling Metadata modeling Three-schema approach Zachman Framework References [ edit ] ^ a b c d e f Matthew West and Julian Fowler (1999). Developing High Quality Data Models Archived September 9, 2020, at the Wayback Machine . The European Process Industries STEP Technical Liaison Executive (EPISTLE). ^ a b Simison, Graeme. C. & Witt, Graham. C. (2005). Data Modeling Essentials . 3rd Edition. Morgan Kaufmann Publishers . ISBN 0-12-644551-6 ^ Data Integration Glossary Archived March 20, 2009, at the Wayback Machine , U.S. Department of Transportation, August 2001. ^ a b c Whitten, Jeffrey L. ; Lonnie D. Bentley , Kevin C. Dittman . (2005). Systems Analysis and Design Methods . 6th edition. ISBN 0-256-19906-X . ^ American National Standards Institute. 1975. ANSI/X3/SPARC Study Group on Data Base Management Systems; Interim Report . FDT (Bulletin of ACM SIGMOD) 7:2. ^ a b Paul R. Smith & Richard Sarfaty (1993). Creating a strategic plan for configuration management using Computer Aided Software Engineering (CASE) tools. Paper For 1993 National DOE/Contractors and Facilities CAD/CAE User's Group. ^ a b c d Len Silverston, W.H.Inmon, Kent Graziano (2007). The Data Model Resource Book . Wiley, 1997. ISBN 0-471-15364-8 . Reviewed by Van Scott on tdan.com . Accessed November 1, 2008. ^ a b c d FIPS Publication 184 Archived December 3, 2013, at the Wayback Machine released of IDEF1X by the Computer Systems Laboratory of the National Institute of Standards and Technology (NIST). December 21, 1993. ^ Amnon Shabo (2006). Clinical genomics data standards for pharmacogenetics and pharmacogenomics Archived July 22, 2009, at the Wayback Machine . ^ \"Semantic data modeling\" In: Metaclasses and Their Application . Book Series Lecture Notes in Computer Science. Publisher Springer Berlin / Heidelberg. Volume Volume 943/1995. This article incorporates public domain material from the National Institute of Standards and Technology Further reading [ edit ] ter Bekke, Johannes Hendrikus (June 4, 1991). Semantic Data Modeling in Relational Environments (PDF) (PhD thesis). Technische Universiteit Delft. Archived (PDF) from the original on April 2, 2025 . Retrieved April 2, 2025 . John Vincent Carlis, Joseph D. Maguire (2001). Mastering Data Modeling: A User-driven Approach . Alan Chmura, J. Mark Heumann (2005). Logical Data Modeling: What it is and how to Do it . Martin E. Modell (1992). Data Analysis, Data Modeling, and Classification . M. Papazoglou, Stefano Spaccapietra, Zahir Tari (2000). Advances in Object-oriented Data Modeling . G. Lawrence Sanders (1995). Data Modeling Graeme C. Simsion, Graham C. Witt (2005). Data Modeling Essentials' Matthew West (2011) Developing High Quality Data Models External links [ edit ] Wikimedia Commons has media related to Data modeling . Agile/Evolutionary Data Modeling Data modeling articles Archived March 7, 2010, at the Wayback Machine Database Modelling in UML Data Modeling 101 Semantic data modeling System Development, Methodologies and Modeling Archived March 7, 2012, at the Wayback Machine Notes on by Tony Drewry Request For Proposal - Information Management Metamodel (IMM) of the Object Management Group Data Modeling is NOT just for DBMS's Part 1 Chris Bradley Data Modeling is NOT just for DBMS's Part 2 Chris Bradley v t e Data model Main Architecture Modeling Structure Schemas Conceptual Logical Physical Types Database Data structure diagram Entity\u2013relationship model ( enhanced ) Geographic Generic Semantic Common Related models Data-flow diagram Information model Object model Object\u2013role modeling Unified Modeling Language See also Database design Business process modeling Core architecture data model Enterprise modelling Function model Process modeling XML schema Data Format Description Language v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Data_modeling&oldid=1317464577 \" Categories : Data modeling Conceptual modelling Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata Duplicate articles Use mdy dates from March 2016 Wikipedia articles incorporating text from the National Institute of Standards and Technology Commons category link is on Wikidata This page was last edited on 18 October 2025, at 06:48 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Data modeling 23 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Main_Page",
    "title": "Wikipedia, the free encyclopedia",
    "content": "Wikipedia, the free encyclopedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Main Page Main Page Talk English Read View source View history Tools Tools move to sidebar hide Actions Read View source View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikimedia Foundation MediaWiki Meta-Wiki Wikimedia Outreach Multilingual Wikisource Wikispecies Wikibooks Wikidata Wikifunctions Wikimania Wikinews Wikiquote Wikisource Wikiversity Wikivoyage Wiktionary Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Welcome to Wikipedia , the free encyclopedia that anyone can edit . 297,808 active editors 7,108,271 articles in English From today's featured article Ali MacGraw The Getaway is a 1972 American action thriller film based on the 1958 novel by Jim Thompson . The film was directed by Sam Peckinpah , written by Walter Hill , and stars Steve McQueen , Ali MacGraw (pictured) , Ben Johnson , Al Lettieri , and Sally Struthers . The plot follows imprisoned mastermind robber Carter \"Doc\" McCoy, whose wife Carol conspires for his release on the condition they rob a bank in Texas. A double-cross follows the crime, and the McCoys are forced to flee for Mexico with the police and criminals in hot pursuit. The Getaway premiered on December\u00a019, 1972. Despite the negative reviews it received upon release, numerous retrospective critics give the film good reviews. A box-office hit earning more than $36\u00a0million, it was the eighth highest-grossing film of 1972 , and one of the most financially successful productions of Peckinpah's and McQueen's careers. A film remake starring Alec Baldwin and Kim Basinger was released in 1994. ( Full\u00a0article... ) Recently featured: Caesar cipher Poisoning of Abbot Greenwell Littlehampton libels Archive By email More featured articles About Did you know\u00a0... Lobster emoji ... that a U.S. senator advocated for the lobster emoji (pictured) ? ... that Irina Voronina was once painted blue and orange for a nude photoshoot? ... that, under O'Donoghue v. United States , Washington, D.C.'s courts are the only tribunals in the United States that might be both constitutional and legislative courts at the same time? ... that Alek Skarlatos , who helped foil a terrorist attack in 2015, became a member of the Oregon House of Representatives nearly a decade later? ... that a cartel was formed to purchase papyri for the Berlin Papyrus Collection ? ... that British physiotherapist Jane Madders developed relaxation training for pregnant women and migraine patients? ... that the architecture of a city in Genshin Impact was influenced by an ancient town in the province of Hunan ? ... that dockworkers constructed makeshift barricades out of large rolls of paper during the July\u00a01936 military uprising in Barcelona ? ... that several Internet memes, including \"is this Battletoads ? \" and the NPC Wojak , originated from the 4chan imageboard /v/ ? Archive Start a new article Nominate an article In the news Fatafehi Fakaf\u0101nua Fatafehi Fakaf\u0101nua (pictured) is elected prime minister by the legislative assembly of Tonga . Filmmaker and actor Rob Reiner and his wife, Michele , are found stabbed to death in their Los Angeles home. Jos\u00e9 Antonio Kast is elected president of Chile . Sixteen people, including a gunman, are killed in a mass shooting attack on a Hanukkah celebration at Bondi Beach in Sydney. Ongoing : Gaza war timeline genocide Russo-Ukrainian war timeline Sudanese civil war timeline Recent deaths : Jose Bantolo Paul Wiggin Arthur Konrad Bobby Rousseau Abraham Quintanilla Hans Roericht More current events Nominate an article On this day December 19 Henry II 1154 \u2013 Henry\u00a0II (depicted) was crowned king of England in Westminster Abbey , London. 1964 \u2013 The ruling junta of South Vietnam , led by Nguy\u1ec5n Kh\u00e1nh , initiated a coup , dissolving the High National Council , a civilian advisory body. 1984 \u2013 China and the United Kingdom signed the Sino-British Joint Declaration , agreeing to the transfer of sovereignty of Hong Kong to China on 1 July 1997 . 1985 \u2013 Aeroflot Flight\u00a0101/435 was hijacked by its co-pilot; it landed in a cow pasture in China, where he was apprehended. 1997 \u2013 Titanic , the third-highest-grossing film of all time with a worldwide total of more than US$1.8\u00a0billion, was released in the United States. Pope Urban\u00a0V ( d. 1370) Mary Livermore ( b. 1820) Mileva Mari\u0107 ( b. 1875) Phil Ochs ( b. 1940) More anniversaries: December 18 December 19 December 20 Archive By email List of days of the year About From today's featured list Natalie Wood American actress Natalie Wood started her career as a child by appearing in films directed by Irving Pichel . Wood's first credited role was as an Austrian war refugee in the Pichel-directed Tomorrow Is Forever (1946) with Claudette Colbert and Orson Welles . The following year, she played a child who does not believe in Santa Claus in the Christmas comedy-drama Miracle on 34th Street (1947). In 1955, she starred as a recalcitrant teenager in Rebel Without a Cause with James Dean , for which she was nominated for the Academy Award for Best Supporting Actress , and received the Golden Globe Award for Most Promising Newcomer \u2013 Female . In 1961, Wood starred as a teenager struggling with sexual repression in the period drama Splendor in the Grass with Warren Beatty , and as Maria in the highly successful musical film West Side Story . She followed West Side Story with another musical film, Gypsy (1962), in which she played the title role of the burlesque entertainer Gypsy Rose Lee . ( Full\u00a0list... ) Recently featured: Gold Coast suburbs Rugby League World Cup hat-tricks Great Northern route stations Archive More featured lists Today's featured picture Pontia edusa , commonly known as the eastern Bath white, is a species of butterfly in the family Pieridae . It is found from the southwest of Europe (southern France, Italy, Corsica, Sardinia) up to central Europe, and in the Middle East in Iran and Iraq. It is a migrant that can also be encountered in Belgium, the Netherlands, northern Germany and Poland, in the Baltic states, and in southern Sweden and Norway. The species inhabits open grassy or flowery areas, in stony or rocky places and in roadsides, at altitudes up to 1,500 metres (4,900 feet) and occasionally higher. Pontia edusa is a small to medium-sized migrant butterfly, with a wingspan reaching about 45 millimetres (1.8 inches). The upperside of its wings is white, with black stains on the top of the forewing and hindwing, while the hindwing underside has greenish-grey spots. Pontia edusa is nearly identical to P.\u00a0daplidice ; it is generally only possible to distinguish the two through genital inspection or DNA analysis. This P.\u00a0edusa butterfly, displaying its greenish-grey underside, was photographed in U\u010dka Nature Park in Istria , Croatia. The photograph was focus-stacked from four separate images. Photograph credit: Charles J. Sharp Recently featured: Blackberry Ludwig van Beethoven African chaffinch Archive More featured pictures Other areas of Wikipedia Community portal \u2013 The central hub for editors, with resources, links, tasks, and announcements. Village pump \u2013 Forum for discussions about Wikipedia itself, including policies and technical issues. Site news \u2013 Sources of news about Wikipedia and the broader Wikimedia movement. Teahouse \u2013 Ask basic questions about using or editing Wikipedia. Help desk \u2013 Ask questions about using or editing Wikipedia. Reference desk \u2013 Ask research questions about encyclopedic topics. Content portals \u2013 A unique way to navigate the encyclopedia. Wikipedia's sister projects Wikipedia is written by volunteer editors and hosted by the Wikimedia Foundation , a non-profit organization that also hosts a range of other volunteer projects : Commons Free media repository MediaWiki Wiki software development Meta-Wiki Wikimedia project coordination Wikibooks Free textbooks and manuals Wikidata Free knowledge base Wikinews Free-content news Wikiquote Collection of quotations Wikisource Free-content library Wikispecies Directory of species Wikiversity Free learning tools Wikivoyage Free travel guide Wiktionary Dictionary and thesaurus Wikipedia languages This Wikipedia is written in English . Many other Wikipedias are available ; some of the largest are listed below. 1,000,000+ articles \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc \u200e Fran\u00e7ais Italiano Nederlands \u65e5\u672c\u8a9e Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Svenska \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u4e2d\u6587 250,000+ articles Bahasa Indonesia Bahasa Melayu B\u00e2n-l\u00e2m-g\u00fa \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u010ce\u0161tina Dansk Eesti \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac Esperanto Euskara \u05e2\u05d1\u05e8\u05d9\u05ea \u0540\u0561\u0575\u0565\u0580\u0565\u0576 \ud55c\uad6d\uc5b4 Magyar Norsk bokm\u00e5l Rom\u00e2n\u0103 Simple English Sloven\u010dina Srpski Srpskohrvatski Suomi T\u00fcrk\u00e7e O\u02bbzbekcha 50,000+ articles Asturianu Az\u0259rbaycanca \u09ac\u09be\u0982\u09b2\u09be Bosanski \u06a9\u0648\u0631\u062f\u06cc Frysk Gaeilge Galego Hrvatski \u10e5\u10d0\u10e0\u10d7\u10e3\u10da\u10d8 Kurd\u00ee Latvie\u0161u Lietuvi\u0173 \u0d2e\u0d32\u0d2f\u0d3e\u0d33\u0d02 \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 \u1019\u103c\u1014\u103a\u1019\u102c\u1018\u102c\u101e\u102c Norsk nynorsk \u0a2a\u0a70\u0a1c\u0a3e\u0a2c\u0a40 Shqip Sloven\u0161\u010dina \u0e44\u0e17\u0e22 \u0c24\u0c46\u0c32\u0c41\u0c17\u0c41 \u0627\u0631\u062f\u0648 Retrieved from \" https://en.wikipedia.org/w/index.php?title=Main_Page&oldid=1325821473 \" 343 languages Ac\u00e8h \u0410\u0434\u044b\u0433\u044d\u0431\u0437\u044d \u0410\u0434\u044b\u0433\u0430\u0431\u0437\u044d Afrikaans Alemannisch \u0410\u043b\u0442\u0430\u0439 \u0442\u0438\u043b \u12a0\u121b\u122d\u129b Anar\u00e2\u0161kiel\u00e2 \u0905\u0902\u0917\u093f\u0915\u093e \u00c6nglisc \u0410\u0525\u0441\u0448\u04d9\u0430 \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Aragon\u00e9s \u0710\u072a\u0721\u071d\u0710 \u0531\u0580\u0565\u0582\u0574\u057f\u0561\u0570\u0561\u0575\u0565\u0580\u0567\u0576 Arm\u00e3neashti Arpetan \u0985\u09b8\u09ae\u09c0\u09af\u09bc\u09be Asturianu Atikamekw \u0905\u0935\u0927\u0940 Ava\u00f1e'\u1ebd \u0410\u0432\u0430\u0440 Aymar aru Az\u0259rbaycanca \u062a\u06c6\u0631\u06a9\u062c\u0647 Basa Bali Bamanankan \u09ac\u09be\u0982\u09b2\u09be Banjar \u95a9\u5357\u8a9e / B\u00e2n-l\u00e2m-g\u00ed Basa Banyumasan \u0411\u0430\u0448\u04a1\u043e\u0440\u0442\u0441\u0430 \u0411\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f \u0411\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f (\u0442\u0430\u0440\u0430\u0448\u043a\u0435\u0432\u0456\u0446\u0430) \u092d\u094b\u091c\u092a\u0941\u0930\u0940 Bikol Central Bislama \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Boarisch \u0f56\u0f7c\u0f51\u0f0b\u0f61\u0f72\u0f42 Bosanski Brezhoneg \u0411\u0443\u0440\u044f\u0430\u0434 Catal\u00e0 \u0427\u04d1\u0432\u0430\u0448\u043b\u0430 Cebuano \u010ce\u0161tina Chamoru Chavacano de Zamboanga Chi-Chewa ChiShona ChiTumbuka Corsu Cymraeg Dagbanli Dansk \u0627\u0644\u062f\u0627\u0631\u062c\u0629 Davvis\u00e1megiella Deitsch Deutsch \u078b\u07a8\u0788\u07ac\u0780\u07a8\u0784\u07a6\u0790\u07b0 Din\u00e9 bizaad Dolnoserbski \u0921\u094b\u091f\u0947\u0932\u0940 \u0f47\u0f7c\u0f44\u0f0b\u0f41 Eesti \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac Emili\u00e0n e rumagn\u00f2l \u042d\u0440\u0437\u044f\u043d\u044c Espa\u00f1ol Esperanto Estreme\u00f1u Euskara E\u028begbe Farefare \u0641\u0627\u0631\u0633\u06cc Fiji Hindi F\u00f8royskt Fran\u00e7ais Frysk Fulfulde Furlan Gaeilge Gaelg Gagauz G\u00e0idhlig Galego \u0413\u04c0\u0430\u043b\u0433\u04c0\u0430\u0439 \u8d1b\u8a9e G\u0129k\u0169y\u0169 \u06af\u06cc\u0644\u06a9\u06cc \u0a97\u0ac1\u0a9c\u0ab0\u0abe\u0aa4\u0ac0 \ud800\udf32\ud800\udf3f\ud800\udf44\ud800\udf39\ud800\udf43\ud800\udf3a \u0917\u094b\u0902\u092f\u091a\u0940 \u0915\u094b\u0902\u0915\u0923\u0940 / G\u00f5ychi Konknni Gungbe \u5ba2\u5bb6\u8a9e / Hak-k\u00e2-ng\u00ee \u0425\u0430\u043b\u044c\u043c\u0433 \ud55c\uad6d\uc5b4 Hausa Hawai\u02bbi \u0540\u0561\u0575\u0565\u0580\u0565\u0576 \u0939\u093f\u0928\u094d\u0926\u0940 Hornjoserbsce Hrvatski Bahasa Hulontalo Ido Igbo Ilokano \u09ac\u09bf\u09b7\u09cd\u09a3\u09c1\u09aa\u09cd\u09b0\u09bf\u09af\u09bc\u09be \u09ae\u09a3\u09bf\u09aa\u09c1\u09b0\u09c0 Bahasa Indonesia Interlingua Interlingue \u1403\u14c4\u1483\u144e\u1450\u1466 / inuktitut I\u00f1upiatun \u0418\u0440\u043e\u043d IsiXhosa IsiZulu \u00cdslenska Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Jawa Kab\u0269y\u025b Kalaallisut \u0c95\u0ca8\u0ccd\u0ca8\u0ca1 Kapampangan \u041a\u044a\u0430\u0440\u0430\u0447\u0430\u0439-\u043c\u0430\u043b\u043a\u044a\u0430\u0440 \u10e5\u10d0\u10e0\u10d7\u10e3\u10da\u10d8 \u06a9\u0672\u0634\u064f\u0631 Kasz\u00ebbsczi \u049a\u0430\u0437\u0430\u049b\u0448\u0430 Kernowek Ikinyarwanda Ikirundi Kiswahili \u041a\u043e\u043c\u0438 Kongo Kotava Krey\u00f2l ayisyen Kriy\u00f2l gwiyannen Kurd\u00ee \u041a\u044b\u0440\u0433\u044b\u0437\u0447\u0430 \u041a\u044b\u0440\u044b\u043a \u043c\u0430\u0440\u044b Ladin Ladino \u041b\u0430\u043a\u043a\u0443 \u0ea5\u0eb2\u0ea7 Latga\u013cu Latina Latvie\u0161u L\u00ebtzebuergesch \u041b\u0435\u0437\u0433\u0438 Lietuvi\u0173 Li Niha Ligure Limburgs Ling\u00e1la Lingua Franca Nova Livvinkarjala La .lojban. Luganda Lombard Magyar Madhur\u00e2 \u092e\u0948\u0925\u093f\u0932\u0940 \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 Malagasy \u0d2e\u0d32\u0d2f\u0d3e\u0d33\u0d02 Malti M\u0101ori \u092e\u0930\u093e\u0920\u0940 \u10db\u10d0\u10e0\u10d2\u10d0\u10da\u10e3\u10e0\u10d8 \u0645\u0635\u0631\u0649 \u1018\u102c\u101e\u102c\u1019\u1014\u103a \u0645\u0627\u0632\u0650\u0631\u0648\u0646\u06cc Bahasa Melayu \uabc3\uabe4\uabc7\uabe9 \uabc2\uabe3\uabdf Mfantse Minangkabau \u95a9\u6771\u8a9e / M\u00ecng-d\u0115\u0324ng-ng\u1e73\u0304 Mirand\u00e9s \u041c\u043e\u043a\u0448\u0435\u043d\u044c \u041c\u043e\u043d\u0433\u043e\u043b \u1019\u103c\u1014\u103a\u1019\u102c\u1018\u102c\u101e\u102c N\u0101huatl Naij\u00e1 Na Vosa Vakaviti Nederlands Nedersaksies N\u0113hiyaw\u0113win / \u14c0\u1426\u1403\u152d\u140d\u140f\u1423 \u0928\u0947\u092a\u093e\u0932\u0940 \u0928\u0947\u092a\u093e\u0932 \u092d\u093e\u0937\u093e \u65e5\u672c\u8a9e Napulitano \u07d2\u07de\u07cf \u041d\u043e\u0445\u0447\u0438\u0439\u043d Nordfriisk Norsk bokm\u00e5l Norsk nynorsk Nouormand Novial Occitan \u041e\u043b\u044b\u043a \u043c\u0430\u0440\u0438\u0439 \u0b13\u0b21\u0b3c\u0b3f\u0b06 Oromoo O\u02bbzbekcha / \u045e\u0437\u0431\u0435\u043a\u0447\u0430 \u0a2a\u0a70\u0a1c\u0a3e\u0a2c\u0a40 \u092a\u093e\u0932\u093f P\u00e4lzisch Pangasinan Pangcah \u067e\u0646\u062c\u0627\u0628\u06cc \u1015\u1021\u102d\u102f\u101d\u103a\u108f\u1018\u102c\u108f\u101e\u102c\u108f Papiamentu \u067e\u069a\u062a\u0648 Patois \u041f\u0435\u0440\u0435\u043c \u043a\u043e\u043c\u0438 \u1797\u17b6\u179f\u17b6\u1781\u17d2\u1798\u17c2\u179a Picard Piemont\u00e8is Pinayuanan Tok Pisin Plattd\u00fc\u00fctsch Polski \u03a0\u03bf\u03bd\u03c4\u03b9\u03b1\u03ba\u03ac Portugu\u00eas Qaraqalpaqsha Q\u0131r\u0131mtatarca Reo tahiti Ripoarisch Rom\u00e2n\u0103 Romani \u010dhib Rumantsch Runa Simi \u0420\u0443\u0441\u0438\u043d\u044c\u0441\u043a\u044b\u0439 \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u0421\u0430\u0445\u0430 \u0442\u044b\u043b\u0430 Sakizaya Gagana Samoa \u0938\u0902\u0938\u094d\u0915\u0943\u0924\u092e\u094d S\u00e4ng\u00f6 \u1c65\u1c5f\u1c71\u1c5b\u1c5f\u1c72\u1c64 \u0633\u0631\u0627\u0626\u06cc\u06a9\u06cc Sardu Scots Seediq Seeltersk Sesotho Sesotho sa Leboa Setswana Shqip Sicilianu \u0dc3\u0dd2\u0d82\u0dc4\u0dbd Simple English \u0633\u0646\u068c\u064a SiSwati Sloven\u010dina Sloven\u0161\u010dina \u0421\u043b\u043e\u0432\u0463\u043d\u044c\u0441\u043a\u044a / \u2c14\u2c0e\u2c11\u2c02\u2c21\u2c10\u2c20\u2c14\u2c0d\u2c1f \u015al\u016fnski Soomaaliga \u06a9\u0648\u0631\u062f\u06cc Sranantongo \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Srpskohrvatski / \u0441\u0440\u043f\u0441\u043a\u043e\u0445\u0440\u0432\u0430\u0442\u0441\u043a\u0438 Sunda Suomi Svenska Tagalog \u0ba4\u0bae\u0bbf\u0bb4\u0bcd Tacl\u1e25it Taqbaylit Tarand\u00edne \u0422\u0430\u0442\u0430\u0440\u0447\u0430 / tatar\u00e7a \u1010\u1086\u1038 Tayal \u0c24\u0c46\u0c32\u0c41\u0c17\u0c41 Tetun \u0e44\u0e17\u0e22 Thu\u0254\u014bj\u00e4\u014b \u1275\u130d\u122d\u129b \u0422\u043e\u04b7\u0438\u043a\u04e3 Lea faka-Tonga \u13e3\u13b3\u13a9 Tsets\u00eahest\u00e2hese Tshivenda \u0ca4\u0cc1\u0cb3\u0cc1 T\u00fcrk\u00e7e T\u00fcrkmen\u00e7e Twi Tyap \u0422\u044b\u0432\u0430 \u0434\u044b\u043b \u0423\u0434\u043c\u0443\u0440\u0442 Basa Ugi \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0627\u0631\u062f\u0648 \u0626\u06c7\u064a\u063a\u06c7\u0631\u0686\u06d5 / Uyghurche Vahcuengh V\u00e8neto Veps\u00e4n kel\u2019 Ti\u1ebfng Vi\u1ec7t Volap\u00fck V\u00f5ro Walon Wayuunaiki \u6587\u8a00 West-Vlams Winaray Wolof \u5434\u8bed Xitsonga \u05d9\u05d9\u05b4\u05d3\u05d9\u05e9 Yor\u00f9b\u00e1 \u7cb5\u8a9e Zazaki Ze\u00eauws \u017demait\u0117\u0161ka \u4e2d\u6587 Obolo Batak Toba Bajau Sama Betawi Batak Mandailing Dagaare Kadazandusun F\u0254\u0300ngb\u00e8 Ghanaian Pidgin Jaku Iban Igala Kumoring Yerwa Kanuri K\u028bsaal Moore IsiNdebele seSewula Nupe \u101b\u1001\u102d\u102f\u1004\u103a \u0420\u0443\u0441\u043a\u0438 \ua80d\ua824\ua81f\ua810\ua824 \u1956\u196d\u1970 \u1956\u196c\u1972 \u1951\u1968\u1952\u1970 \u1275\u130d\u122c Tol\u0131\u015fi Toki pona \u2d5c\u2d30\u2d4e\u2d30\u2d63\u2d49\u2d56\u2d5c \u2d5c\u2d30\u2d4f\u2d30\u2d61\u2d30\u2d62\u2d5c Edit links This page was last edited on 5 December 2025, at 10:53 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Main Page 343 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Requirements_analysis",
    "title": "Requirements analysis - Wikipedia",
    "content": "Requirements analysis - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Overview 2 Requirements analysis topics Toggle Requirements analysis topics subsection 2.1 Stakeholder identification 2.2 Joint Requirements Development (JRD) Sessions 2.3 Contract-style requirement lists 2.3.1 Strengths 2.3.2 Weaknesses 2.3.3 Alternative to requirement lists 2.4 Measurable goals 2.5 Prototypes 2.6 Use cases 2.7 Requirements specification 3 Types of requirements Toggle Types of requirements subsection 3.1 Business requirements 3.2 Customer requirements 3.3 Architectural requirements 3.4 Behavioral requirements 3.5 Functional requirements 3.6 Non-functional requirements 3.7 Performance requirements 3.8 Design requirements 3.9 Derived requirements 3.10 Allocated requirements 4 Requirements analysis issues Toggle Requirements analysis issues subsection 4.1 Stakeholder issues 4.2 Engineer/developer issues 4.3 Attempted solutions 5 See also 6 References 7 Bibliography 8 External links Toggle the table of contents Requirements analysis 29 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Az\u0259rbaycanca Catal\u00e0 \u010ce\u0161tina Dansk Deutsch \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais Galego \ud55c\uad6d\uc5b4 Bahasa Indonesia Italiano Magyar Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Svenska \u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Requirements analysis\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( December 2011 ) ( Learn how and when to remove this message ) This article is in list format but may read better as prose . You can help by converting this article , if appropriate. Editing help is available. ( July 2022 ) ( Learn how and when to remove this message ) Engineering process For broader coverage of this topic, see Requirements engineering . A systems engineering perspective on requirements analysis [ 1 ] Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e In systems engineering and software engineering , requirements analysis focuses on the tasks that determine the needs or conditions to meet the new or altered product or project, taking account of the possibly conflicting requirements of the various stakeholders , analyzing , documenting , validating , and managing software or system requirements . [ 2 ] Requirements analysis is critical to the success or failure of systems or software projects . [ 3 ] The requirements should be documented, actionable, measurable, testable, [ 4 ] traceable, [ 4 ] related to identified business needs or opportunities, and defined to a level of detail sufficient for system design . Overview [ edit ] Conceptually, requirements analysis includes three types of activities: [ citation needed ] Eliciting requirements : (e.g. the project charter or definition), business process documentation, and stakeholder interviews. This is sometimes also called requirements gathering or requirements discovery. Recording requirements: Requirements may be documented in various forms, usually including a summary list, and may include natural-language documents, use cases , user stories , process specifications , and a variety of models including data models. Analyzing requirements: determining whether the stated requirements are clear, complete, unduplicated, concise, valid, consistent and unambiguous, and resolving any apparent conflicts. Analyzing can also include sizing requirements. Requirements analysis can be a long and tiring process during which many delicate psychological skills are involved. New systems change the environment and relationships between people, so it is important to identify all the stakeholders, take into account all their needs, and ensure they understand the implications of the new systems. Analysts can employ several techniques to elicit the requirements from the customer. These may include the development of scenarios (represented as user stories in agile methods ), the identification of use cases , the use of workplace observation or ethnography , holding interviews , or focus groups (more aptly named in this context as requirements workshops, or requirements review sessions) and creating requirements lists. Prototyping may be used to develop an example system that can be demonstrated to stakeholders. Where necessary, the analyst will employ a combination of these methods to establish the exact requirements of the stakeholders, so that a system that meets the business needs is produced. [ 5 ] [ 6 ] Requirements quality can be improved through these and other methods: Visualization. Using tools that promote better understanding of the desired end-product such as visualization and simulation. Consistent use of templates. Producing a consistent set of models and templates to document the requirements. Documenting dependencies . Documenting dependencies and interrelationships among requirements, as well as any assumptions and congregations. Requirements analysis topics [ edit ] This section does not cite any sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . ( October 2009 ) ( Learn how and when to remove this message ) Stakeholder identification [ edit ] See Stakeholder analysis for a discussion of people or organizations (legal entities such as companies, and standards bodies) that have a valid interest in the system. They may be affected by it either directly or indirectly. A major new emphasis in the 1990s was a focus on the identification of stakeholders . It is increasingly recognized that stakeholders are not limited to the organization employing the analyst. Other stakeholders will include: anyone who operates the system (normal and maintenance operators) anyone who benefits from the system (functional, political, financial, and social beneficiaries) anyone involved in purchasing or procuring the system. In a mass-market product organization, product management, marketing, and sometimes sales act as surrogate consumers (mass-market customers) to guide the development of the product. organizations that regulate aspects of the system (financial, safety, and other regulators) people or organizations opposed to the system (negative stakeholders; see also Misuse case ) organizations responsible for systems that interface with the system under design. those organizations that integrate horizontally with the organization for whom the analyst is designing the system. Joint Requirements Development (JRD) Sessions [ edit ] Requirements often have cross-functional implications that are unknown to individual stakeholders and often missed or incompletely defined during stakeholder interviews. These cross-functional implications can be elicited by conducting JRD sessions in a controlled environment, facilitated by a trained facilitator (Business Analyst), wherein stakeholders participate in discussions to elicit requirements, analyze their details, and uncover cross-functional implications. A dedicated scribe should be present to document the discussion, freeing up the Business Analyst to lead the discussion in a direction that generates appropriate requirements that meet the session objective. JRD Sessions are analogous to Joint Application Design Sessions. In the former, the sessions elicit requirements that guide design, whereas the latter elicit the specific design features to be implemented in satisfaction of elicited requirements. Contract-style requirement lists [ edit ] One traditional way of documenting requirements has been contract-style requirement lists. In a complex system such requirements lists can run hundreds of pages long. An appropriate metaphor would be an extremely long shopping list. Such lists are very much out of favor in modern analysis; as they have proved spectacularly unsuccessful at achieving their aims [ citation needed ] ; but they are still seen to this day. Strengths [ edit ] Provides a checklist of requirements. Provide a contract between the project sponsor(s) and developers. For a large system can provide a high level description from which lower-level requirements can be derived. Weaknesses [ edit ] Such lists can run to hundreds of pages. They are not intended to serve as a reader-friendly description of the desired application. Such requirements lists abstract all the requirements and so there is little context. The Business Analyst may include context for requirements in accompanying design documentation. This abstraction is not intended to describe how the requirements fit or work together. The list may not reflect relationships and dependencies between requirements. While a list does make it easy to prioritize each item, removing one item out of context can render an entire use case or business requirement useless. The list does not supplant the need to review requirements carefully with stakeholders to gain a better-shared understanding of the implications for the design of the desired system/application. Simply creating a list does not guarantee its completeness. The Business Analyst must make a good faith effort to discover and collect a substantially comprehensive list and rely on stakeholders to point out missing requirements. These lists can create a false sense of mutual understanding between the stakeholders and developers; Business Analysts are critical to the translation process. It is almost impossible to uncover all the functional requirements before the process of development and testing begins. If these lists are treated as an immutable contract, then requirements that emerge in the Development process may generate a controversial change request. Alternative to requirement lists [ edit ] As an alternative to requirement lists, Agile Software Development uses User stories to suggest requirements in everyday language. Measurable goals [ edit ] Main article: Goal modeling Best practices take the composed list of requirements merely as clues and repeatedly ask \"why?\" until the actual business purposes are discovered. Stakeholders and developers can then devise tests to measure what level of each goal has been achieved thus far. Such goals change more slowly than the long list of specific but unmeasured requirements. Once a small set of critical, measured goals has been established, rapid prototyping and short iterative development phases may proceed to deliver actual stakeholder value long before the project is half over. Prototypes [ edit ] Main article: Software prototyping A prototype is a computer program that exhibits a part of the properties of another computer program, allowing users to visualize an application that has not yet been constructed. A popular form of prototype is a mockup , which helps future users and other stakeholders get an idea of what the system will look like. Prototypes make it easier to make design decisions because aspects of the application can be seen and shared before the application is built. Major improvements in communication between users and developers were often seen with the introduction of prototypes. Early views of applications led to fewer changes later and hence reduced overall costs considerably. [ citation needed ] Prototypes can be flat diagrams (often referred to as wireframes ) or working applications using synthesized functionality. Wireframes are made in a variety of graphic design documents, and often remove all color from the design (i.e. use a greyscale color palette) in instances where the final software is expected to have a graphic design applied to it. This helps to prevent confusion as to whether the prototype represents the final visual look and feel of the application. [ citation needed ] Use cases [ edit ] Main article: Use case A use case is a structure for documenting the functional requirements for a system, usually involving software, whether that is new or being changed. Each use case provides a set of scenarios that convey how the system should interact with a human user or another system, to achieve a specific business goal. Use cases typically avoid technical jargon, preferring instead the language of the end-user or domain expert . Use cases are often co-authored by requirements engineers and stakeholders. Use cases are deceptively simple tools for describing the behavior of software or systems. A use case contains a textual description of how users are intended to work with the software or system. Use cases should not describe the internal workings of the system, nor should they explain how that system will be implemented. Instead, they show the steps needed to perform a task without sequential assumptions. Requirements specification [ edit ] Main article: Requirements specification This section needs expansion . You can help by adding to it . ( February 2018 ) Requirements specification is the synthesis of discovery findings regarding current state business needs and the assessment of these needs to determine, and specify, what is required to meet the needs within the solution scope in focus. Discovery, analysis, and specification move the understanding from a current as-is state to a future to-be state. Requirements specification can cover the full breadth and depth of the future state to be realized, or it could target specific gaps to fill, such as priority software system bugs to fix and enhancements to make. Given that any large business process almost always employs software and data systems and technology, requirements specification is often associated with software system builds, purchases, cloud computing strategies, embedded software in products or devices, or other technologies. The broader definition of requirements specification includes or focuses on any solution strategy or component, such as training, documentation guides, personnel, marketing strategies, equipment, supplies, etc. Types of requirements [ edit ] Requirements are categorized in several ways. The following are common categorizations of requirements that relate to technical management: [ 1 ] Business requirements [ edit ] Main article: Business requirements Statements of business level goals, without reference to detailed functionality. These are usually high-level (software and/or hardware) capabilities that are needed to achieve a business outcome. Customer requirements [ edit ] Statements of fact and assumptions that define the expectations of the system in terms of mission objectives, environment, constraints, and measures of effectiveness and suitability (MOE/MOS). The customers are those that perform the eight primary functions of systems engineering, with special emphasis on the operator as the key customer. Operational requirements will define the basic need and, at a minimum, answer the questions posed in the following listing: [ 1 ] Operational distribution or deployment : Where will the system be used? Mission profile or scenario : How will the system accomplish its mission objective? Performance and related parameters : What are the critical system parameters to accomplish the mission? Utilization environments : How are the various system components to be used? Effectiveness requirements : How effective or efficient must the system be in performing its mission? Operational life cycle : How long will the system be in use by the user? Environment : What environments will the system be expected to operate in an effective manner? Architectural requirements [ edit ] Architectural requirements explain what has to be done by identifying the necessary systems architecture of a system . Behavioral requirements [ edit ] Behavioral requirements explain what has to be done by identifying the necessary behavior of a system. Functional requirements [ edit ] Main article: Functional requirements Functional requirements explain what has to be done by identifying the necessary task, action or activity that must be accomplished. Functional requirements analysis will be used as the toplevel functions for functional analysis. [ 1 ] Non-functional requirements [ edit ] Main article: Non-functional requirements Non-functional requirements are requirements that specify criteria that can be used to judge the operation of a system, rather than specific behaviors. Performance requirements [ edit ] The extent to which a mission or function must be executed; is generally measured in terms of quantity, quality, coverage, timeliness, or readiness. During requirements analysis, performance (how well does it have to be done) requirements will be interactively developed across all identified functions based on system life cycle factors; and characterized in terms of the degree of certainty in their estimate, the degree of criticality to the system success, and their relationship to other requirements. [ 1 ] Design requirements [ edit ] The \"build to\", \"code to\", and \"buy to\" requirements for products and \"how to execute\" requirements for processes are expressed in technical data packages and technical manuals. [ 1 ] Derived requirements [ edit ] Requirements that are implied or transformed from higher-level requirements. For example, a requirement for long-range or high speed may result in a design requirement for low weight. [ 1 ] Allocated requirements [ edit ] A requirement is established by dividing or otherwise allocating a high-level requirement into multiple lower-level requirements. Example: A 100-pound item that consists of two subsystems might result in weight requirements of 70 pounds and 30 pounds for the two lower-level items. [ 1 ] Well-known requirements categorization models include FURPS and FURPS+, developed at Hewlett-Packard . Requirements analysis issues [ edit ] Stakeholder issues [ edit ] Steve McConnell, in his book Rapid Development , details a number of ways users can inhibit requirements gathering: Users do not understand what they want or users do not have a clear idea of their requirements Users will not commit to a set of written requirements Users insist on new requirements after the cost and schedule have been fixed Communication with users is slow Users often do not participate in reviews or are incapable of doing so Users are technically unsophisticated Users do not understand the development process Users do not know about present technology This may lead to the situation where user requirements keep changing even when system or product development has been started. Engineer/developer issues [ edit ] Possible problems caused by engineers and developers during requirements analysis are: A natural inclination towards writing code can lead to implementation beginning before the requirements analysis is complete, potentially resulting in code changes to meet actual requirements once they are known. Technical personnel and end-users may have different vocabularies. Consequently, they may wrongly believe they are in perfect agreement until the finished product is supplied. Engineers and developers may try to make the requirements fit an existing system or model, rather than develop a system specific to the needs of the client. Attempted solutions [ edit ] One attempted solution to communications problems has been to employ specialists in business or system analysis. Techniques introduced in the 1990s like prototyping , Unified Modeling Language (UML), use cases , and agile software development are also intended as solutions to problems encountered with previous methods. Also, a new class of application simulation or application definition tools has entered the market. These tools are designed to bridge the communication gap between business users and the IT organization \u2014 and also to allow applications to be 'test marketed' before any code is produced. The best of these tools offer: electronic whiteboards to sketch application flows and test alternatives ability to capture business logic and data needs ability to generate high-fidelity prototypes that closely imitate the final application interactivity capability to add contextual requirements and other comments ability for remote and distributed users to run and interact with the simulation See also [ edit ] Business analysis Business process reengineering Creative brief Data modeling Design brief Functional requirements Information technology Model-driven engineering Model Transformation Language Needs assessment Non-functional requirements Process architecture Process modeling Product fit analysis Requirements elicitation Requirements Engineering Specialist Group Requirements management Requirements Traceability Search Based Software Engineering Software prototyping Software requirements Software Requirements Specification Systems analysis System requirements System requirements specification User-centered design References [ edit ] ^ a b c d e f g h Systems Engineering Fundamentals Archived 2011-07-22 at the Wayback Machine Defense Acquisition University Press, 2001 ^ Kotonya, Gerald; Sommerville, Ian (1998). Requirements Engineering: Processes and Techniques . Chichester, UK: John Wiley and Sons. ISBN 9780471972082 . ^ Alain Abran; James W. Moore; Pierre Bourque; Robert Dupuis, eds. (March 2005). \"Chapter 2: Software Requirements\" . Guide to the software engineering body of knowledge (2004\u00a0ed.). Los Alamitos, CA: IEEE Computer Society Press. ISBN 0-7695-2330-7 . Archived from the original on 2009-03-23 . Retrieved 2007-02-08 . It is widely acknowledged within the software industry that software engineering projects are critically vulnerable when these activities are performed poorly. ^ a b Project Management Institute 2015 , p.\u00a0158, \u00a76.3.2. ^ Amin, Tauqeer ul; Shahzad, Basit (2024-09-01). \"Improving requirements elicitation in large-scale software projects with reduced customer engagement: a proposed cost-effective model\" . Requirements Engineering . 29 (3): 403\u2013 418. doi : 10.1007/s00766-024-00425-2 . ISSN 1432-010X . ^ Pacheco, Carla; Garc\u00eda, Ivan; Reyes, Miryam (August 2018). \"Requirements elicitation techniques: a systematic literature review based on the maturity of the techniques\" . IET Software . 12 (4): 365\u2013 378. doi : 10.1049/iet-sen.2017.0144 . ISSN 1751-8806 . [ 1 ] Bibliography [ edit ] Brian Berenbach; Daniel Paulish; Juergen Katzmeier; Arnold Rudorfer (2009). Software & Systems Requirements Engineering: In Practice . New York: McGraw-Hill Professional. ISBN 978-0-07-160547-2 . Hay, David C. (2003). Requirements Analysis: From Business Views to Architecture (1st\u00a0ed.). Upper Saddle River, NJ: Prentice Hall. ISBN 0-13-028228-6 . Laplante, Phil (2009). Requirements Engineering for Software and Systems (1st\u00a0ed.). Redmond, WA: CRC Press. ISBN 978-1-4200-6467-4 . Archived from the original on 2014-10-22 . Retrieved 2011-10-14 . Project Management Institute (2015-01-01). Business Analysis for Practitioners . Project Management Inst. ISBN 978-1-62825-069-5 . McConnell, Steve (1996). Rapid Development: Taming Wild Software Schedules (1st\u00a0ed.). Redmond, WA: Microsoft Press. ISBN 1-55615-900-5 . Nuseibeh, B.; Easterbrook, S. (2000). Requirements engineering: a roadmap (PDF) . ICSE '00. Proceedings of the conference on the future of Software engineering . pp. 35\u2013 46. CiteSeerX 10.1.1.131.3116 . doi : 10.1145/336512.336523 . ISBN 1-58113-253-0 . Archived from the original (PDF) on 2015-11-06 . Retrieved 2015-08-28 . Andrew Stellman & Jennifer Greene (2005). Applied Software Project Management . Cambridge, MA: O'Reilly Media. ISBN 0-596-00948-8 . Karl Wiegers & Joy Beatty (2013). Software Requirements (3rd\u00a0ed.). Redmond, WA: Microsoft Press. ISBN 978-0-7356-7966-5 . External links [ edit ] Wikimedia Commons has media related to Requirements analysis . Peer-reviewed Encyclopedia Entry on Requirements Engineering and Analysis Defense Acquisition University Stakeholder Requirements Definition Process --- Stakeholder Requirements Definition Process at the Wayback Machine (archived December 23, 2015) MIL-HDBK 520 Systems Requirements Document Guidance v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control flow Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Computational problem Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human-centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human\u2013computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Specialized Platform\nDevelopment Thermodynamic computing Category Outline Glossaries v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons v t e Systems engineering Subfields Aerospace engineering Biological systems engineering Cognitive systems engineering Configuration management Earth systems engineering and management Electrical engineering Enterprise systems engineering Health systems engineering Performance engineering Reliability engineering Safety engineering Sociocultural Systems Engineering Processes Requirements engineering Functional Analysis and Allocation System integration Verification and validation Design review System of systems engineering Concepts Business process Fault tolerance System System lifecycle V-Model Systems development life cycle Tools Decision-making Function modelling IDEF Optimization Quality function deployment Spare part System dynamics Systems Modeling Language Systems analysis Systems modeling Work breakdown structure People James S. Albus Ruzena Bajcsy Benjamin S. Blanchard Wernher von Braun Kathleen Carley Harold Chestnut Wolt Fabrycky Barbara Grosz Arthur David Hall III Derek Hitchins Robert E. Machol Radhika Nagpal Simon Ramo Joseph Francis Shea Katia Sycara Manuela M. Veloso John N. Warfield Related fields Control engineering Computer engineering Industrial engineering Operations research Project management Quality management Risk management Software engineering Category ^ Anderson, Charlotte (2022-06-08). \"Why You Need Stakeholder Identification and Analysis | Acorn\" . Acorn PLMS . Retrieved 2024-01-19 . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Requirements_analysis&oldid=1316117868 \" Categories : Systems engineering Software requirements Business analysis Hidden categories: Webarchive template wayback links Articles needing additional references from December 2011 All articles needing additional references Articles needing cleanup from July 2022 All pages needing cleanup Articles with sections that need to be turned into prose from July 2022 Articles with multiple maintenance issues Use American English from March 2019 All Wikipedia articles written in American English Articles with short description Short description is different from Wikidata All articles with unsourced statements Articles with unsourced statements from February 2012 Articles needing additional references from October 2009 Articles with unsourced statements from July 2019 Articles with unsourced statements from December 2011 Articles to be expanded from February 2018 All articles to be expanded Commons category link is on Wikidata This page was last edited on 10 October 2025, at 15:35 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Requirements analysis 29 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_development",
    "title": "Software development - Wikipedia",
    "content": "Software development - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Methodologies 2 Life cycle Toggle Life cycle subsection 2.1 Feasibility 2.2 Analysis 2.3 Design 2.4 Programming 2.5 Testing 2.6 Production 3 Workers 4 Models and tools Toggle Models and tools subsection 4.1 Computer-aided software engineering 4.2 Documentation 4.3 Effort estimation 4.4 Integrated development environment 4.5 Version control 4.6 View model 4.7 Fitness functions 5 Intellectual property 6 References 7 Further reading 8 External links Toggle the table of contents Software development 52 languages Afrikaans \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Az\u0259rbaycanca \u09ac\u09be\u0982\u09b2\u09be \u0411\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u010ce\u0161tina ChiTumbuka Dansk Deutsch Eesti Espa\u00f1ol Euskara \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 \u0939\u093f\u0928\u094d\u0926\u0940 Ido Bahasa Indonesia Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Jawa Latvie\u0161u Lietuvi\u0173 Magyar \u0d2e\u0d32\u0d2f\u0d3e\u0d33\u0d02 Bahasa Melayu \u041c\u043e\u043d\u0433\u043e\u043b \u1019\u103c\u1014\u103a\u1019\u102c\u1018\u102c\u101e\u102c \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas Qaraqalpaqsha Rom\u00e2n\u0103 Runa Simi \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip Simple English \u06a9\u0648\u0631\u062f\u06cc \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Suomi Svenska \u0ba4\u0bae\u0bbf\u0bb4\u0bcd T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0627\u0631\u062f\u0648 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 \u2d5c\u2d30\u2d4e\u2d30\u2d63\u2d49\u2d56\u2d5c \u2d5c\u2d30\u2d4f\u2d30\u2d61\u2d30\u2d62\u2d5c Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Creation and maintenance of software Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Software development is the process of designing, creating, testing, and maintaining software applications to meet specific user needs or business objectives . The process is more encompassing than programming , writing code , in that it includes conceiving the goal, evaluating feasibility, analyzing requirements , design , testing and release . The process is part of software engineering which also includes organizational management , project management , configuration management and other aspects. [ 1 ] Software development involves many skills and job specializations including programming , testing , documentation , graphic design , user support , marketing , and fundraising . Software development involves many tools including: compiler , integrated development environment (IDE), version control , computer-aided software engineering , and word processor. The details of the process used for a development effort vary. The process may be confined to a formal, documented standard , or it can be customized and emergent for the development effort. The process may be sequential, in which each major phase (i.e., design, implement, and test) is completed before the next begins, but an iterative approach \u2013 where small aspects are separately designed, implemented, and tested \u2013 can reduce risk and cost and increase quality. Methodologies [ edit ] Main article: Software development methodology Flowchart of the evolutionary prototyping model , an iterative development model [ 2 ] Each of the available methodologies is best suited to specific kinds of projects, based on various technical, organizational, project, and team considerations. [ 3 ] The simplest methodology is the \"code and fix\", typically used by a single programmer working on a small project. After briefly considering the purpose of the program, the programmer codes it and runs it to see if it works. When they are done, the product is released. This methodology is useful for prototypes but cannot be used for more elaborate programs. [ 4 ] In the top-down waterfall model , feasibility, analysis, design , development, quality assurance , and implementation occur sequentially in that order. This model requires one step to be complete before the next begins, causing delays, and makes it impossible to revise previous steps if necessary. [ 5 ] [ 6 ] [ 7 ] With iterative processes these steps are interleaved with each other for improved flexibility, efficiency, and more realistic scheduling. Instead of completing the project all at once, one might go through most of the steps with one component at a time. Iterative development also lets developers prioritize the most important features, enabling lower priority ones to be dropped later on if necessary. [ 6 ] [ 8 ] Agile is one popular method, originally intended for small or medium sized projects, that focuses on giving developers more control over the features that they work on to reduce the risk of time or cost overruns. [ 9 ] Derivatives of agile include extreme programming and Scrum . [ 9 ] Open-source software development typically uses agile methodology with concurrent design, coding, and testing, due to reliance on a distributed network of volunteer contributors. [ 10 ] Beyond agile, some companies integrate information technology (IT) operations with software development, which is called DevOps or DevSecOps including computer security . [ 11 ] DevOps includes continuous development, testing , integration of new code in the version control system, deployment of the new code, and sometimes delivery of the code to clients. [ 12 ] The purpose of this integration is to deliver IT services more quickly and efficiently. [ 11 ] Another focus in many programming methodologies is the idea of trying to catch issues such as security vulnerabilities and bugs as early as possible ( shift-left testing ) to reduce the cost of tracking and fixing them. [ 13 ] In 2009, it was estimated that 32% of software projects were delivered on time and on budget, and with full functionality. An additional 44% were delivered, but were missing at least one of their features. The remaining 24% were cancelled before release. [ 14 ] Life cycle [ edit ] Software development life cycle describes the typical phases of the process of developing software. [ 15 ] Feasibility [ edit ] The sources of ideas for software products are plentiful. These ideas can come from market research , including the demographics of potential new customers, existing customers, sales prospects who rejected the product, other internal software development staff, or a creative third party. Ideas for software products are usually first evaluated by marketing personnel for economic feasibility, fit with existing channels of distribution, possible effects on existing product lines, required features , and fit with the company's marketing objectives. In the marketing evaluation phase, the cost and time assumptions are evaluated. [ 16 ] The feasibility analysis estimates the project's return on investment , its development cost and timeframe. Based on this analysis, the company can make a business decision to invest in further development. [ 17 ] After deciding to develop the software, the company is focused on delivering the product at or below the estimated cost and time, and with a high standard of quality (i.e., lack of bugs) and the desired functionality. Nevertheless, most software projects run late, and sometimes compromises are made in features or quality to meet a deadline. [ 18 ] Analysis [ edit ] Software analysis begins with a requirements analysis to capture the business needs of the software. [ 19 ] Challenges for the identification of needs are that current or potential users may have different and incompatible needs, may not understand their own needs, and change their needs during the process of software development. [ 20 ] Ultimately, the result of analysis is a detailed specification for the product that developers can work from. Software analysts often decompose the project into smaller objects, components that can be reused for increased cost-effectiveness, efficiency, and reliability. [ 19 ] Decomposing the project may enable a multi-threaded implementation that runs significantly faster on multiprocessor computers. [ 21 ] During the analysis and design phases of software development, structured analysis is often used to break down the customer's requirements into pieces that can be implemented by software programmers. [ 22 ] The underlying logic of the program may be represented in data-flow diagrams , data dictionaries , pseudocode , state transition diagrams , and/or entity relationship diagrams . [ 23 ] If the project incorporates a piece of legacy software that has not been modeled, this software may be modeled to help ensure it is correctly incorporated with the newer software. [ 24 ] Design [ edit ] Main article: software design Design involves choices about the implementation of the software, such as which programming languages and database software to use, or how the hardware and network communications will be organized. Design may be iterative with users consulted about their needs in a process of trial and error . Design often involves people who are expert in aspects such as database design , screen architecture, and the performance of servers and other hardware. [ 19 ] Designers often attempt to find patterns in the software's functionality to spin off distinct modules that can be reused with object-oriented programming . An example of this is the model\u2013view\u2013controller , an interface between a graphical user interface and the backend . [ 25 ] Programming [ edit ] Main article: computer programming The central feature of software development is creating and understanding the software that implements the desired functionality. [ 26 ] There are various strategies for writing the code. Cohesive software has various components that are independent from each other. [ 19 ] Coupling is the interrelation of different software components, which is viewed as undesirable because it increases the difficulty of maintenance . [ 27 ] Often, software programmers do not follow industry best practices, resulting in code that is inefficient, difficult to understand, or lacking documentation on its functionality. [ 28 ] These standards are especially likely to break down in the presence of deadlines. [ 29 ] As a result, testing, debugging , and revising the code become much more difficult. Code refactoring , for example, adding more comments to the code, is a solution to improve the understandability of the code. [ 30 ] Testing [ edit ] Main article: software testing Testing is the process of ensuring that the code executes correctly and without errors. Debugging is performed by each software developer on their own code to confirm that the code does what it is intended to. In particular, it is crucial that the software executes on all inputs, even if the result is incorrect. [ 31 ] Code reviews by other developers are often used to scrutinize new code added to the project, and according to some estimates dramatically reduce the number of bugs persisting after testing is complete. [ 32 ] Once the code has been submitted, quality assurance \u2013 a separate department of non-programmers for most large companies \u2013 test the accuracy of the entire software product. Acceptance tests derived from the original software requirements are a popular tool for this. [ 31 ] Quality testing also often includes stress and load checking (whether the software is robust to heavy levels of input or usage), integration testing (to ensure that the software is adequately integrated with other software), and compatibility testing (measuring the software's performance across different operating systems or browsers). [ 31 ] When tests are written before the code, this is called test-driven development . [ 33 ] Production [ edit ] See also: Software release life cycle Production is the phase in which software is deployed to the end user. [ 34 ] During production, the developer may create technical support resources for users [ 35 ] [ 34 ] or a process for fixing bugs and errors that were not caught earlier. There might also be a return to earlier development phases if user needs changed or were misunderstood. [ 34 ] Workers [ edit ] Software development is performed by software developers , usually working on a team. Efficient communications between team members is essential to success. This is more easily achieved if the team is small, used to working together, and located near each other. [ 36 ] Communications also help identify problems at an earlier stage of development and avoid duplicated effort. Many development projects avoid the risk of losing essential knowledge held by only one employee by ensuring that multiple workers are familiar with each component. [ 37 ] Software development involves professionals from various fields, not just software programmers but also product managers who set the strategy and roadmap for the product, [ 38 ] individuals specialized in testing, documentation writing, graphic design , user support, marketing , and fundraising. Although workers for proprietary software are paid, most contributors to open-source software are volunteers. [ 39 ] Alternately, they may be paid by companies whose business model does not involve selling the software, but something else \u2013 such as services and modifications to open source software. [ 40 ] Models and tools [ edit ] Computer-aided software engineering [ edit ] Computer-aided software engineering (CASE) is tools for the partial automation of software development. [ 41 ] CASE enables designers to sketch out the logic of a program, whether one to be written, or an already existing one to help integrate it with new code or reverse engineer it (for example, to change the programming language ). [ 42 ] Documentation [ edit ] Main article: Software documentation Documentation comes in two forms that are usually kept separate \u2013 one intended for software developers, and another made available to the end user to help them use the software. [ 43 ] [ 44 ] Most developer documentation is in the form of code comments for each file, class , and method that cover the application programming interface (API)\u2014how the piece of software can be accessed by another\u2014and often implementation details. [ 45 ] This documentation is helpful for new developers to understand the project when they begin working on it. [ 46 ] In agile development, the documentation is often written at the same time as the code. [ 47 ] User documentation is more frequently written by technical writers . [ 48 ] Effort estimation [ edit ] Main article: Software development effort estimation Accurate estimation is crucial at the feasibility stage and in delivering the product on time and within budget. The process of generating estimations is often delegated by the project manager . [ 49 ] Because the effort estimation is directly related to the size of the complete application, it is strongly influenced by the addition of features in the requirements\u2014the more requirements, the higher the development cost. Aspects not related to functionality, such as the experience of the software developers and code reusability, are also essential to consider in estimation. [ 50 ] As of 2019 [update] , most of the tools for estimating the amount of time and resources for software development were designed for conventional applications and are not applicable to web applications or mobile applications . [ 51 ] Integrated development environment [ edit ] Anjuta , a C and C++ IDE for the GNOME environment An integrated development environment (IDE) supports software development with enhanced features compared to a simple text editor . [ 52 ] IDEs often include automated compiling , syntax highlighting of errors, [ 53 ] debugging assistance, [ 54 ] integration with version control , and semi-automation of tests. [ 52 ] Version control [ edit ] Main article: Version control Version control is a popular way of managing changes made to the software. Whenever a new version is checked in, the software saves a backup of all modified files. If multiple programmers are working on the software simultaneously, it manages the merging of their code changes. The software highlights cases where there is a conflict between two sets of changes and allows programmers to fix the conflict. [ 55 ] View model [ edit ] The TEAF Matrix of Views and Perspectives A view model is a framework that provides the viewpoints on the system and its environment , to be used in the software development process . It is a graphical representation of the underlying semantics of a view. The purpose of viewpoints and views is to enable human engineers to comprehend very complex systems and to organize the elements of the problem around domains of expertise . In the engineering of physically intensive systems, viewpoints often correspond to capabilities and responsibilities within the engineering organization. [ 56 ] Fitness functions [ edit ] Fitness functions are automated and objective tests to ensure that the new developments do not deviate from the established constraints, checks and compliance controls. [ 57 ] Intellectual property [ edit ] Intellectual property can be an issue when developers integrate open-source code or libraries into a proprietary product, because most open-source licenses used for software require that modifications be released under the same license. As an alternative, developers may choose a proprietary alternative or write their own software module. [ 58 ] References [ edit ] ^ Dooley 2017 , p.\u00a01. ^ Dooley 2017 , p.\u00a012. ^ System Development Methodologies for Web-Enabled E-Business: A Customization Framework\nLinda V. Knight (DePaul University, USA), Theresa A. Steinbach (DePaul University, USA), and Vince Kellen (Blue Wolf, USA) ^ Dooley 2017 , pp.\u00a08\u20139. ^ Dooley 2017 , p.\u00a09. ^ a b Langer 2016 , pp.\u00a02\u20133, 5\u20136. ^ Tucker, Morelli & de Silva 2011 , p.\u00a08. ^ Dooley 2017 , p.\u00a011. ^ a b Dooley 2017 , p.\u00a013. ^ Tucker, Morelli & de Silva 2011 , pp.\u00a041\u201342. ^ a b Vishnu 2019 , pp.\u00a01\u20132. ^ Laukkanen, Eero; Itkonen, Juha; Lassenius, Casper (2017). \"Problems, causes and solutions when adopting continuous delivery\u2014A systematic literature review\" . Information and Software Technology . 82 : 55\u2013 79. doi : 10.1016/j.infsof.2016.10.001 . ^ Winters, Manshreck & Wright 2020 , p.\u00a017. ^ Tucker, Morelli & de Silva 2011 , p.\u00a06. ^ Saif 2019 , pp.\u00a046\u201347. ^ Morris 2001 , p.\u00a01.10. ^ Langer 2016 , p.\u00a07. ^ Dooley 2017 , pp.\u00a03, 8. ^ a b c d Langer 2016 , p.\u00a08. ^ Langer 2016 , pp.\u00a02\u20133. ^ Dooley 2017 , pp.\u00a0193\u2013194. ^ Langer 2016 , pp.\u00a0103\u2013104. ^ Langer 2016 , pp.\u00a0117, 127, 131, 137, 141. ^ Langer 2016 , p.\u00a0106. ^ Dooley 2017 , p.\u00a0142. ^ Tucker, Morelli & de Silva 2011 , p.\u00a031. ^ Langer 2016 , pp.\u00a08\u20139. ^ Tucker, Morelli & de Silva 2011 , pp.\u00a031\u201332. ^ Tucker, Morelli & de Silva 2011 , pp.\u00a034\u201335. ^ Tucker, Morelli & de Silva 2011 , pp.\u00a031\u201332, 35. ^ a b c Langer 2016 , p.\u00a09. ^ Dooley 2017 , p.\u00a0272. ^ Tucker, Morelli & de Silva 2011 , p.\u00a09. ^ a b c Langer 2016 , p.\u00a010. ^ Tucker, Morelli & de Silva 2011 , p.\u00a037. ^ Dooley 2017 , p.\u00a02. ^ Winters, Manshreck & Wright 2020 , pp.\u00a030\u201331. ^ \"What Does a Product Manager Do? And How to Become One\" . Coursera . 21 January 2025 . Retrieved 5 May 2025 . ^ Tucker, Morelli & de Silva 2011 , p.\u00a07. ^ Tucker, Morelli & de Silva 2011 , pp.\u00a014\u201315. ^ Langer 2016 , p.\u00a022. ^ Langer 2016 , pp.\u00a0108\u2013110, 206. ^ Tucker, Morelli & de Silva 2011 , p.\u00a0243. ^ Winters, Manshreck & Wright 2020 , p.\u00a0192. ^ Winters, Manshreck & Wright 2020 , pp.\u00a0193\u2013195. ^ Tucker, Morelli & de Silva 2011 , p.\u00a0143. ^ Tucker, Morelli & de Silva 2011 , p.\u00a0144. ^ Winters, Manshreck & Wright 2020 , p.\u00a0204. ^ Saif 2019 , pp.\u00a050\u201351. ^ Saif 2019 , pp.\u00a052\u201353. ^ Saif 2019 , p.\u00a045. ^ a b Tucker, Morelli & de Silva 2011 , p.\u00a068. ^ Dooley 2017 , p.\u00a0236. ^ Dooley 2017 , p.\u00a0239. ^ Dooley 2017 , pp.\u00a0246\u2013247. ^ Edward J. Barkmeyer ea (2003). Concepts for Automating Systems Integration Archived 25 January 2017 at the Wayback Machine NIST 2003. ^ Fundamentals of Software Architecture: An Engineering Approach . O'Reilly Media. 2020. ISBN 978-1492043454 . ^ Langer 2016 , pp.\u00a044\u201345. Further reading [ edit ] Conde, Dan (2002). Software Product Management: Managing Software Development from Idea to Product to Marketing to Sales . Aspatore Books. ISBN 1587622025 . Davis, A. M. (2005). Just enough requirements management: Where software development meets marketing . Dorset House Publishing Company, Incorporated. ISBN 0932633641 . Dooley, John F. (2017). Software Development, Design and Coding: With Patterns, Debugging, Unit Testing, and Refactoring . Apress. ISBN 978-1-4842-3153-1 . Kit, Edward (1992). Software Testing in The Real World . Addison-Wesley Professional. ISBN 0201877562 . Hasted, Edward (2005). Software That Sells: A Practical Guide to Developing and Marketing Your Software Project . Wiley Publishing. ISBN 0764597833 . Hohmann, Luke (2003). Beyond Software Architecture: Creating and Sustaining Winning Solutions . Addison-Wesley Professional. ISBN 0201775948 . Horch, John W. (March 1995). \"Two Orientations On How To Work With Objects\". IEEE Software . 12 (2): 117\u2013 118. ProQuest 215832531 . Langer, Arthur M. (2016). Guide to Software Development: Designing and Managing the Life Cycle . Springer. ISBN 978-1-4471-6799-0 . McCarthy, Jim (1995). Dynamics of Software Development . Microsoft Press. ISBN 1556158238 . Morris, Joseph M. (2001). Software industry accounting (2nd\u00a0ed.). John Wiley & Sons . OCLC 53863959 . Rittinghouse, John (2003). Managing Software Deliverables: A Software Development Management Methodology . Digital Press. ISBN 155558313X . Saif, Syed Mohsin (2019). \"Software Effort Estimation for Successful Software Application Development\". In Vishnu, Pendyala (ed.). Tools and Techniques for Software Development in Large Organizations: Emerging Research and Opportunities: Emerging Research and Opportunities . IGI Global . pp. 45\u2013 97. ISBN 978-1-7998-1865-6 . Tucker, Allen; Morelli, Ralph; de Silva, Chamindra (2011). Software Development: An Open Source Approach . CRC Press. ISBN 978-1-4398-8460-7 . Vishnu, Pendyala (2019). \"Evolution of Integration, Build, Test, and Release Engineering Into DevOps and to DevSecOps\". In Vishnu, Pendyala (ed.). Tools and Techniques for Software Development in Large Organizations: Emerging Research and Opportunities: Emerging Research and Opportunities . IGI Global. pp. 1\u2013 20. ISBN 978-1-7998-1865-6 . Wiegers, Karl E. (2005). More About Software Requirements: Thorny Issues and Practical Advice . Microsoft Press. ISBN 0735622671 . Winters, Titus; Manshreck, Tom; Wright, Hyrum (2020). Software Engineering at Google: Lessons Learned from Programming Over Time . O'Reilly Media, Inc. ISBN 978-1-4920-8276-7 . Wysocki, Robert K. (2006). Effective Software Project Management . Wiley. ISBN 0764596365 . External links [ edit ] Media related to Software development at Wikimedia Commons v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control flow Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Computational problem Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human-centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human\u2013computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Specialized Platform\nDevelopment Thermodynamic computing Category Outline Glossaries Authority control databases International GND National United States Japan Spain Israel Other Yale LUX Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_development&oldid=1328346852 \" Categories : Software development Software project management Computer occupations Product development Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata Use dmy dates from March 2024 Use British English from December 2021 All Wikipedia articles written in British English Articles containing potentially dated statements from 2019 All articles containing potentially dated statements Commons category link is on Wikidata This page was last edited on 19 December 2025, at 09:08 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software development 52 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_deployment",
    "title": "Software deployment - Wikipedia",
    "content": "Software deployment - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Deployment activities 3 Deployment roles 4 See also 5 References 6 External links Toggle the table of contents Software deployment 21 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u010ce\u0161tina Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc \ud55c\uad6d\uc5b4 \u0939\u093f\u0928\u094d\u0926\u0940 Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Nederlands \u65e5\u672c\u8a9e Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Svenska T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Activities that make a software system available for use Software deployment is all of the activities that make a software system available for use. [ 1 ] [ 2 ] Deployment can involve activities on the producer ( software developer ) side or on the consumer ( user ) side or both. Deployment to consumers is a hard task because the target systems are diverse and unpredictable. [ 3 ] [ 4 ] Software as a service avoids these difficulties by deploying only to dedicated servers that are typically under the producer's control. Because every software system is unique, the precise processes or procedures within each activity can hardly be defined. Therefore, \"deployment\" should be interpreted as a general process that has to be customized according to specific requirements or characteristics. [ 5 ] History [ edit ] When computers were extremely large, expensive, and bulky ( mainframes and minicomputers ), the software was often bundled together with the hardware by manufacturers and provided for free. [ 6 ] A pivotal moment occurred in 1969 when IBM, influenced by antitrust lawsuits, began charging for software and services separately from hardware. This \"unbundling\" effectively created the modern software industry, turning software into a commercial product. [ 7 ] Early deployment processes were highly structured; the Lincoln Labs Phased Model, developed in 1956 for the SAGE air defense system, introduced sequential phases that influenced later methodologies. [ 8 ] This approach was formalized in the waterfall model , which became dominant after being described by Winston Royce in 1970. It led to infrequent, costly, and lengthy release cycles, often taking years. [ 9 ] If business software needed to be installed, it often required an expensive, time-consuming visit by a systems architect or a consultant . [ 10 ] For complex, on-premises installation of enterprise software today, this is sometimes still the case. [ 11 ] The development of mass-market software for the new age of microcomputers in the 1980s brought new forms of software distribution \u2013 first cartridges , then Compact Cassettes , then floppy disks , and later (in the 1990s and beyond) optical media , the internet and flash drives . [ 12 ] [ 13 ] This shift meant that software deployment could be left to the customer. [ 14 ] During this period, alternatives to the rigid waterfall model emerged. The Spiral Model , proposed by Barry Boehm in 1988, introduced a risk-driven, iterative approach that challenged waterfall's linear structure and paved the way for more flexible, agile methodologies. [ 15 ] As customer-led deployment became standard, it was recognized that configuration should be user-friendly. In the 1990s, tools like InstallShield became popular, providing installer wizards that eliminated the need for users to perform complex tasks like editing registry entries. [ 16 ] In pre-internet software deployments, releases were by nature expensive and infrequent affairs. [ 17 ] The spread of the internet fundamentally transformed software distribution and made end-to-end agile software development viable by enabling rapid collaboration and digital delivery. [ 18 ] The foundations for modern rapid deployment were laid in the 1990s when Kent Beck developed Continuous Integration as a core practice of Extreme Programming , advocating for developers to integrate their work daily. [ 19 ] The advent of cloud computing and software as a service (SaaS) in the 2000s further accelerated this trend, allowing software to be deployed to a large number of customers in minutes. This shift also meant deployment schedules were now typically determined by the software supplier, not the customers. [ 20 ] [ 21 ] Such flexibility led to the rise of continuous delivery as a viable option, especially for web applications . [ 22 ] Modern deployment strategies that build upon these principles include blue\u2013green deployment and canary release deployment. [ 23 ] Deployment activities [ edit ] Release The release activity follows from the completed the development process and is sometimes classified as part of the development process rather than deployment process. [ 24 ] It includes all the operations to prepare a system for assembly and transfer to the computer system(s) on which it will be run in production. Therefore, it sometimes involves determining the resources required for the system to operate with tolerable performance and planning and/or documenting subsequent activities of the deployment process. Installation and activation For simple systems, installation involves establishing some form of a command , shortcut, script or service for executing the software (manually or automatically). For complex systems it may involve configuration of the system\u00a0\u2013  possibly by asking the end-user questions about its intended use, or directly asking them how they would like it to be configured\u00a0\u2013  and/or making all the required subsystems ready to use. Activation is the activity of starting up the executable component of software for the first time (not to be confused with the common use of the term activation concerning a software license, which is a function of Digital Rights Management systems.) In larger software deployments on servers , the main copy of the software to be used by users - \"production\" - might be installed on a production server in a production environment.  Other versions of the deployed software may be installed in a test environment , development environment and disaster recovery environment. In complex continuous delivery environments and/or software as a service system, differently-configured versions of the system might even exist simultaneously in the production environment for different internal or external customers (this is known as a multi-tenant architecture ), or even be gradually rolled out in parallel to different groups of customers, with the possibility of canceling one or more of the parallel deployments. For example, Twitter is known to use the latter approach for A/B testing of new features and user interface changes. A \"hidden live\" group can also be created within a production environment, consisting of servers that are not yet connected to the production load balancer , for the purposes of blue\u2013green deployment . Deactivation Deactivation is the inverse of activation and refers to shutting down any already-executing components of a system. Deactivation is often required to perform other deployment activities, e.g., a software system may need to be deactivated before an update can be performed.  The practice of removing infrequently used or obsolete systems from service is often referred to as application retirement or application decommissioning. Uninstallation Uninstallation is the inverse of installation. It is the removal of a system that is no longer required. It may also involve some reconfiguration of other software systems to remove the uninstalled system's dependencies . Update The update process replaces an earlier version of all or part of a software system with a newer release. It commonly consists of deactivation followed by installation. On some systems, such as on Linux when using the system's package manager , the old version of a software application is typically also uninstalled as an automatic part of the process. (This is because Linux package managers do not typically support installing multiple versions of a software application at the same time unless the software package has been specifically designed to work around this limitation.) Built-in update Mechanisms for installing updates are built into some software systems (or, in the case of some operating systems such as Linux , Android and iOS , into the operating system itself). Automation of these update processes ranges from fully automatic to user-initiated and controlled. Norton Internet Security is an example of a system with a semi-automatic method for retrieving and installing updates to both the antivirus definitions and other components of the system. Other software products provide query mechanisms for determining when updates are available. Version tracking Version tracking systems help the user find and install updates to software systems. For example: The Software Catalog stores the version and other information for each software package installed on a local system. One-click of a button launches a browser window to the upgrade web page for the application, including auto-filling of the user name and password for sites that require a login. On Linux, Android and iOS this process is even easier because a standardized process for version tracking (for software packages installed in the officially supported way) is built into the operating system, so no separate login, download and execute steps are required\u00a0\u2013  so the process can be configured to be fully automated. Some third-party software also supports automated version tracking and upgrading for certain Windows software packages. Deployment roles [ edit ] The complexity and variability of software products have fostered the emergence of specialized roles for coordinating and engineering the deployment process.  For desktop systems, end-users frequently also become the \"software deployers\" when they install a software package on their machine. The deployment of enterprise software involves many more roles, and those roles typically change as the application progresses from the test (pre-production) to production environments.  Typical roles involved in software deployments for enterprise applications may include: [ 25 ] in pre-production environments: application developers: see Software development process build-and-release engineers: see Release engineering release managers: see Release management deployment coordinators: see DevOps in production environments: system administrator database administrator release coordinators: see DevOps operations project managers: see ITIL [ 26 ] See also [ edit ] Application lifecycle management Product lifecycle management Systems management System deployment Software release Definitive Media Library Readme Release management Deployment environment References [ edit ] ^ Pressman, Roger S. (2014). Software Engineering: A Practitioner's Approach (8th\u00a0ed.). McGraw-Hill. ISBN 978-0078022128 . ^ \"Deploying software\" . IBM Documentation . IBM . Retrieved 25 November 2024 . ^ A. Nejati, M. Svechikov, J. Wuttke: Deploying a C++ Software with (or without) Python Embedding and Extension. In: deRSE24 - Selected Contributions of the 4th Conference for\nResearch Software Engineering in Germany, edited by J. Bernoth et al. Electronic Communications of the EASST, vol 83 (2025). https://eceasst.org/index.php/eceasst/article/view/2596 . ^ \"What Is Software Deployment?\" . PagerDuty . Retrieved 23 September 2025 . ^ Rees-Carter, Stephen (13 July 2018). \"How to Install and Configure Ansible on Ubuntu 18.04\" . DigitalOcean . Archived from the original on 9 June 2019 . Retrieved 8 June 2019 . Configuration management systems are designed to make controlling large numbers of servers easy for administrators and operations teams. They allow you to control many different systems in an automated way from one central location. ^ \"Software Becomes a Product\" . Computer History Museum . Retrieved 23 September 2025 . ^ \"Software Becomes a Product\" . Computer History Museum . Retrieved 23 September 2025 . ^ \"Early Software Delivery Models\" . Octopus Deploy . August 23, 2022 . Retrieved 23 September 2025 . ^ \"Early Software Delivery Models\" . Octopus Deploy . August 23, 2022 . Retrieved 23 September 2025 . ^ \"Early Software Delivery Models\" . Octopus Deploy . August 23, 2022 . Retrieved 23 September 2025 . ^ Bansal, Prateek (August 22, 2023). \"The Evolution of Software Deployment: From Physical Servers to Container Orchestration\" . Medium . Retrieved 23 September 2025 . ^ Oosthuizen, Dewald (May 15, 2025). \"The Evolution of Software Development\" . Medium . Retrieved 23 September 2025 . ^ \"The Evolution of Software Development!\" . XPARTRON . September 11, 2024 . Retrieved 23 September 2025 . ^ Poornima (August 18, 2023). \"A Short History of Deployment Processes\" . Hashnode . Retrieved 23 September 2025 . ^ \"Early Software Delivery Models\" . Octopus Deploy . August 23, 2022 . Retrieved 23 September 2025 . ^ \"The Evolution of App Deployment and Packaging: 1990 to Now\" . Iron.io Blog . December 23, 2020 . Retrieved 23 September 2025 . ^ \"Early Software Delivery Models\" . Octopus Deploy . August 23, 2022 . Retrieved 23 September 2025 . ^ Wasserman, Anthony I. (2011). \"How the Internet transformed the software industry\" . J Internet Serv Appl . 2 : 11\u2013 22. doi : 10.1007/s13174-011-0019-x . Retrieved 23 September 2025 . ^ Fowler, Martin (January 18, 2024). \"Continuous Integration\" . martinfowler.com . Retrieved 23 September 2025 . ^ \"Continuous Delivery: Origins, 5 Principles, And 7 Key Capabilities\" . Octopus Deploy . July 20, 2022 . Retrieved 23 September 2025 . ^ Wasserman, Anthony I. (2011). \"How the Internet transformed the software industry\" . J Internet Serv Appl . 2 : 11\u2013 22. doi : 10.1007/s13174-011-0019-x . Retrieved 23 September 2025 . ^ Fowler, Martin (January 18, 2024). \"Continuous Integration\" . martinfowler.com . Retrieved 23 September 2025 . ^ \"A Brief History of DevOps, Part IV: Continuous Delivery vs. Continuous Deployment\" . CircleCI Blog . November 9, 2023 . Retrieved 23 September 2025 . ^ Dolstra, Eelco; Jonker, Willem; L\u00f6we, Erik (2003). \"Integrating Software Construction and Software Deployment\" (PDF) . Proceedings of the 3rd workshop on Software configuration management . ^ Bass, Len; Weber, Ingo; Zhu, Liming (2015). DevOps: A Software Architect's Perspective . Addison-Wesley. ISBN 978-0134049847 . ^ Steinberg, Gene (2018). Reinventing ITIL in the Age of DevOps: Innovative Practices Across Frameworks . Apress. External links [ edit ] Standardization efforts Solution Installation Schema Submission request to W3C OASIS Solution Deployment Descriptor TC OMG Specification for Deployment and Configuration of Component-based Distributed Applications (OMG D&C) JSR 88: Java EE Application Deployment Articles Carzaniga, Antonio; Fuggetta, Alfonso; Hall, Richard S.; Van Der Hoek, Andr\u00e9; Heimbigner, Dennis; Wolf, Alexander L. (April 1998). \"A Characterization Framework for Software Deployment Technologies \u2013 Technical Report CU-CS-857-98\" (PDF) . Boulder, CO : Department of Computer Science, University of Colorado Boulder . Resources Visual Studio Release Management v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_deployment&oldid=1322843480 \" Categories : Software distribution System administration Software release Hidden categories: Articles with short description Short description is different from Wikidata Use American English from June 2020 All Wikipedia articles written in American English This page was last edited on 18 November 2025, at 05:02 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software deployment 21 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Debugging",
    "title": "Debugging - Wikipedia",
    "content": "Debugging - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Etymology 2 Scope 3 Tools 4 Debugging process 5 Techniques Toggle Techniques subsection 5.1 Automatic bug fixing 6 Debugging for embedded systems 7 Anti-debugging 8 See also 9 References 10 Further reading 11 External links Toggle the table of contents Debugging 39 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u010ce\u0161tina Deutsch Eesti \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc \ud55c\uad6d\uc5b4 \u0540\u0561\u0575\u0565\u0580\u0565\u0576 \u0939\u093f\u0928\u094d\u0926\u0940 Hrvatski Ido Bahasa Indonesia Italiano \u05e2\u05d1\u05e8\u05d9\u05ea \u10e5\u10d0\u10e0\u10d7\u10e3\u10da\u10d8 \u049a\u0430\u0437\u0430\u049b\u0448\u0430 Kiswahili Bahasa Melayu Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l \u041e\u043b\u044b\u043a \u043c\u0430\u0440\u0438\u0439 Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Simple English Sloven\u0161\u010dina \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Suomi \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Betawi Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikiquote Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Fixing defects in an engineered system \"Debug\" redirects here. For other uses, see Debug (disambiguation) . Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e In engineering , debugging is the process of finding the root cause , workarounds , and possible fixes for bugs . For software , debugging tactics can involve interactive debugging, control flow analysis, log file analysis , monitoring at the application or system level, memory dumps , and profiling . Many programming languages and software development tools also offer programs to aid in debugging, known as debuggers. Etymology [ edit ] See also: Bug (engineering) \u00a7\u00a0History A computer log entry from the Mark\u00a0II, with a moth taped to the page The term bug , in the sense of defect, dates back at least to 1878 when Thomas Edison wrote \"little faults and difficulties\" in his inventions as \"Bugs\". A popular story from the 1940s is from Admiral Grace Hopper . [ 1 ] While she was working on a Mark II computer at Harvard University, her associates discovered a moth stuck in a relay that impeded operation and wrote in a log book \"First actual case of a bug being found\". Although probably a joke , conflating the two meanings of bug (biological and defect), the story indicates that the term was used in the computer field at that time. Similarly, the term debugging was used in aeronautics before entering the world of computers . A letter from J. Robert Oppenheimer , director of the WWII atomic bomb Manhattan Project at Los Alamos, used the term in a letter to Dr. Ernest Lawrence at UC Berkeley, dated October 27, 1944, [ 2 ] regarding the recruitment of additional technical staff.\nThe Oxford English Dictionary entry for debug uses the term debugging in reference to airplane engine testing in a 1945 article in the Journal of the Royal Aeronautical Society. \nAn article in \"Airforce\" (June 1945 p.\u00a050) refers to debugging aircraft cameras. The seminal article by Gill [ 3 ] in 1951 is the earliest in-depth discussion of programming errors, but it does not use the term bug or debugging . In the ACM 's digital library, the term debugging is first used in three papers from the 1952 ACM National Meetings. [ 4 ] [ 5 ] [ 6 ] Two of the three use the term in quotation marks. By 1963, debugging was a common enough term to be mentioned in passing without explanation on page 1 of the CTSS manual. [ 7 ] Scope [ edit ] As software and electronic systems have become generally more complex, the various common debugging techniques have expanded with more methods to detect anomalies, assess impact, and schedule software patches or full updates to a system. The words \"anomaly\" and \"discrepancy\" can be used, as being more neutral terms , to avoid the words \"error\" and \"defect\" or \"bug\" where there might be an implication that all so-called errors , defects or bugs must be fixed (at all costs). Instead, an impact assessment can be made to determine if changes to remove an anomaly (or discrepancy ) would be cost-effective for the system, or perhaps a scheduled new release might render the change(s) unnecessary. Not all issues are safety-critical or mission-critical in a system. Also, it is important to avoid the situation where a change might be more upsetting to users, long-term, than living with the known problem(s) (where the \"cure would be worse than the disease\"). Basing decisions of the acceptability of some anomalies can avoid a culture of a \"zero-defects\" mandate, where people might be tempted to deny the existence of problems so that the result would appear as zero defects . Considering the collateral issues, such as the cost-versus-benefit impact assessment, then broader debugging techniques will expand to determine the frequency of anomalies (how often the same \"bugs\" occur) to help assess their impact to the overall system. Tools [ edit ] Main article: Debugger Debugging on video game consoles is usually done with special hardware such as this Xbox debug unit intended for developers. Debugging ranges in complexity from fixing simple errors to performing lengthy and tiresome tasks of data collection, analysis, and scheduling updates. The debugging skill of the programmer can be a major factor in the ability to debug a problem, but the difficulty of software debugging varies greatly with the complexity of the system, and also depends, to some extent, on the programming language (s) used and the available tools, such as debuggers . Debuggers are software tools which enable the programmer to monitor the execution of a program, stop it, restart it, set breakpoints , and change values in memory. The term debugger can also refer to the person who is doing the debugging. Generally, high-level programming languages , such as Java , make debugging easier, because they have features such as exception handling and type checking that make real sources of erratic behaviour easier to spot. In programming languages such as C or assembly , bugs may cause silent problems such as memory corruption , and it is often difficult to see where the initial problem happened. In those cases, memory debugger tools may be needed. In certain situations, general purpose software tools that are language specific in nature can be very useful. These take the form of static code analysis tools . These tools look for a very specific set of known problems, some common and some rare, within the source code, concentrating more on the semantics (e.g. data flow) rather than the syntax, as compilers and interpreters do. Both commercial and free tools exist for various languages; some claim to be able to detect hundreds of different problems. These tools can be extremely useful when checking very large source trees, where it is impractical to do code walk-throughs. A typical example of a problem detected would be a variable dereference that occurs before the variable is assigned a value. As another example, some such tools perform strong type checking when the language does not require it. Thus, they are better at locating likely errors in code that is syntactically correct. But these tools have a reputation of false positives, where correct code is flagged as dubious. The old Unix lint program is an early example. For debugging electronic hardware (e.g., computer hardware ) as well as low-level software (e.g., BIOSes , device drivers ) and firmware , instruments such as oscilloscopes , logic analyzers , or in-circuit emulators (ICEs) are often used, alone or in combination. An ICE may perform many of the typical software debugger's tasks on low-level software and firmware . Debugging process [ edit ] The debugging process normally begins with identifying the steps to reproduce the problem. This can be a non-trivial task, particularly with parallel processes and some Heisenbugs for example. The specific user environment and usage history can also make it difficult to reproduce the problem. After the bug is reproduced, the input of the program may need to be simplified to make it easier to debug. For example, a bug in a compiler can make it crash when parsing a large source file. However, after simplification of the test case, only few lines from the original source file can be sufficient to reproduce the same crash. Simplification may be done manually using a divide-and-conquer approach, in which the programmer attempts to remove some parts of original test case then checks if the problem still occurs. When debugging in a GUI , the programmer can try skipping some user interaction from the original problem description to check if the remaining actions are sufficient for causing the bug to occur. After the test case is sufficiently simplified, a programmer can use a debugger tool to examine program states (values of variables, plus the call stack ) and track down the origin of the problem(s). Alternatively, tracing can be used. In simple cases, tracing is just a few print statements which output the values of variables at particular points during the execution of the program. [ citation needed ] Techniques [ edit ] Interactive debugging uses debugger tools which allow a program's execution to be processed one step at a time and to be paused to inspect or alter its state. Subroutines or function calls may typically be executed at full speed and paused again upon return to their caller, or themselves single stepped, or any mixture of these options. Setpoints may be installed which permit full speed execution of code that is not suspected to be faulty, and then stop at a point that is. Putting a setpoint immediately after the end of a program loop is a convenient way to evaluate repeating code. Watchpoints are commonly available, where execution can proceed until a particular variable changes, and catchpoints which cause the debugger to stop for certain kinds of program events, such as exceptions or the loading of a shared library. Print debugging or tracing is the act of watching (live or recorded) trace statements, or print statements, that indicate the flow of execution of a process and the data progression. Tracing can be done with specialized tools (like with GDB's trace) or by insertion of trace statements into the source code. The latter is sometimes called printf debugging , due to the use of the printf function in C. This kind of debugging was turned on by the command TRON in the original versions of the novice-oriented BASIC programming language. TRON stood for, \"Trace On.\" TRON caused the line numbers of each BASIC command line to print as the program ran. Activity tracing is like tracing (above), but rather than following program execution one instruction or function at a time, follows program activity based on the overall amount of time spent by the processor/CPU executing particular segments of code. This is typically presented as a fraction of the program's execution time spent processing instructions within defined memory addresses (machine code programs) or certain program modules (high level language or compiled programs). If the program being debugged is shown to be spending an inordinate fraction of its execution time within traced areas, this could indicate misallocation of processor time caused by faulty program logic, or at least inefficient allocation of processor time that could benefit from optimization efforts. Remote debugging is the process of debugging a program running on a system different from the debugger. To start remote debugging, a debugger connects to a remote system over a communications link such as a local area network. The debugger can then control the execution of the program on the remote system and retrieve information about its state. Post-mortem debugging is debugging of the program after it has already crashed . Related techniques often include various tracing techniques like examining log files, outputting a call stack on the crash, [ 8 ] and analysis of memory dump (or core dump ) of the crashed process. The dump of the process could be obtained automatically by the system (for example, when the process has terminated due to an unhandled exception), or by a programmer-inserted instruction, or manually by the interactive user. \"Wolf fence\" algorithm: Edward Gauss described this simple but very useful and now famous algorithm in a 1982 article for Communications of the ACM as follows: \"There's one wolf in Alaska; how do you find it? First build a fence down the middle of the state, wait for the wolf to howl, determine which side of the fence it is on. Repeat process on that side only, until you get to the point where you can see the wolf.\" [ 9 ] This is implemented e.g. in the Git version control system as the command git bisect , which uses the above algorithm to determine which commit introduced a particular bug. Record and replay debugging is the technique of creating a program execution recording (e.g. using Mozilla's free rr debugging tool; enabling reversible debugging/execution), which can be replayed and interactively debugged. Useful for remote debugging and debugging intermittent, non-deterministic, and other hard-to-reproduce defects. Time travel debugging is the process of stepping back in time through source code (e.g. using Undo LiveRecorder ) to understand what is happening during execution of a computer program; to allow users to interact with the program; to change the history if desired and to watch how the program responds. Delta debugging \u2013  a technique of automating test case simplification. [ 10 ] :\u200ap.123 Saff Squeeze \u2013  a technique of isolating failure within the test using progressive inlining of parts of the failing test. [ 11 ] [ 12 ] Causality tracking : There are techniques to track the cause effect chains in the computation. [ 13 ] Those techniques can be tailored for specific bugs, such as null pointer dereferences. [ 14 ] Automatic bug fixing [ edit ] This section is an excerpt from Automatic bug fixing . [ edit ] Automatic bug-fixing is the automatic repair of software bugs without the intervention of a human programmer. [ 15 ] [ 16 ] [ 17 ] It is also commonly referred to as automatic patch generation , automatic bug repair , or automatic program repair . [ 17 ] The typical goal of such techniques is to automatically generate correct patches to eliminate bugs in software programs without causing software regression . [ 18 ] Debugging for embedded systems [ edit ] In contrast to the general purpose computer software design environment, a primary characteristic of embedded environments is the sheer number of different platforms available to the developers (CPU architectures, vendors, operating systems, and their variants). Embedded systems are, by definition, not general-purpose designs: they are typically developed for a single task (or small range of tasks), and the platform is chosen specifically to optimize that application. Not only does this fact make life tough for embedded system developers, it also makes debugging and testing of these systems harder as well, since different debugging tools are needed for different platforms. Despite the challenge of heterogeneity mentioned above, some debuggers have been developed commercially as well as research prototypes. Examples of commercial solutions come from Green Hills Software , [ 19 ] Lauterbach GmbH [ 20 ] and Microchip's MPLAB-ICD (for in-circuit debugger). Two examples of research prototype tools are Aveksha [ 21 ] and Flocklab. [ 22 ] They all leverage a functionality available on low-cost embedded processors, an On-Chip Debug Module (OCDM), whose signals are exposed through a standard JTAG interface . They are benchmarked based on how much change to the application is needed and the rate of events that they can keep up with. In addition to the typical task of identifying bugs in the system, embedded system debugging also seeks to collect information about the operating states of the system that may then be used to analyze the system: to find ways to boost its performance or to optimize other important characteristics (e.g. energy consumption, reliability, real-time response, etc.). Anti-debugging [ edit ] Anti-debugging is \"the implementation of one or more techniques within computer code that hinders attempts at reverse engineering or debugging a target process\". [ 23 ] It is actively used by recognized publishers in copy-protection schemas, but is also used by malware to complicate its detection and elimination. [ 24 ] Techniques used in anti-debugging include: API-based: check for the existence of a debugger using system information Exception-based: check to see if exceptions are interfered with Process and thread blocks: check whether process and thread blocks have been manipulated Modified code: check for code modifications made by a debugger handling software breakpoints Hardware- and register-based: check for hardware breakpoints and CPU registers Timing and latency: check the time taken for the execution of instructions Detecting and penalizing debugger [ 24 ] An early example of anti-debugging existed in early versions of Microsoft Word which, if a debugger was detected, produced a message that said, \"The tree of evil bears bitter fruit. Now trashing program disk.\", after which it caused the floppy disk drive to emit alarming noises with the intent of scaring the user away from attempting it again. [ 25 ] [ 26 ] See also [ edit ] Assertion (software development) Debugging pattern Magic debug values Shotgun debugging Software bug Software testing Time travel debugging Trace table Troubleshooting References [ edit ] ^ \"InfoWorld Oct 5, 1981\" . 5 October 1981. Archived from the original on September 18, 2019 . Retrieved July 17, 2019 . ^ \"Archived copy\" . Archived from the original on 2019-11-21 . Retrieved 2019-12-17 . {{ cite web }} :  CS1 maint: archived copy as title ( link ) ^ S. Gill, The Diagnosis of Mistakes in Programmes on the EDSAC Archived 2020-03-06 at the Wayback Machine , Proceedings of the Royal Society of London. Series A, Mathematical and Physical Sciences, Vol. 206, No. 1087 (May 22, 1951), pp. 538-554 ^ Robert V. D. Campbell, Evolution of automatic computation Archived 2019-09-18 at the Wayback Machine , Proceedings of the 1952 ACM national meeting (Pittsburgh), p 29-32, 1952. ^ Alex Orden, Solution of systems of linear inequalities on a digital computer , Proceedings of the 1952 ACM national meeting (Pittsburgh), p. 91-95, 1952. ^ Howard B. Demuth, John B. Jackson, Edmund Klein, N. Metropolis, Walter Orvedahl, James H. Richardson, MANIAC doi=10.1145/800259.808982, Proceedings of the 1952 ACM national meeting (Toronto), p. 13-16 ^ The Compatible Time-Sharing System Archived 2012-05-27 at the Wayback Machine , M.I.T. Press, 1963 ^ \"Postmortem Debugging\" . Dr. Dobb's . Archived from the original on 2019-12-17 . Retrieved 2019-12-17 . ^ E. J. Gauss (1982). \"Pracniques: The 'Wolf Fence' Algorithm for Debugging\" . Communications of the ACM . 25 (11): 780. doi : 10.1145/358690.358695 . S2CID 672811 . ^ Zeller, Andreas (2005). Why Programs Fail: A Guide to Systematic Debugging . Morgan Kaufmann. ISBN 1-55860-866-4 . ^ \"Kent Beck, Hit 'em High, Hit 'em Low: Regression Testing and the Saff Squeeze\" . Archived from the original on 2012-03-11. ^ Rainsberger, J.B. (28 March 2022). \"The Saff Squeeze\" . The Code Whisperer . Retrieved 28 March 2022 . ^ Zeller, Andreas (2002-11-01). \"Isolating cause-effect chains from computer programs\". ACM SIGSOFT Software Engineering Notes . 27 (6): 1\u2013 10. doi : 10.1145/605466.605468 . ISSN 0163-5948 . S2CID 12098165 . ^ Bond, Michael D.; Nethercote, Nicholas; Kent, Stephen W.; Guyer, Samuel Z.; McKinley, Kathryn S. (2007). \"Tracking bad apples\". Proceedings of the 22nd annual ACM SIGPLAN conference on Object oriented programming systems and applications - OOPSLA '07 . p.\u00a0405. doi : 10.1145/1297027.1297057 . ISBN 9781595937865 . S2CID 2832749 . ^ Rinard, Martin C. (2008). \"Technical perspective Patching program errors\". Communications of the ACM . 51 (12): 86. doi : 10.1145/1409360.1409381 . S2CID 28629846 . ^ Harman, Mark (2010). \"Automated patching techniques\". Communications of the ACM . 53 (5): 108. doi : 10.1145/1735223.1735248 . S2CID 9729944 . ^ a b Gazzola, Luca; Micucci, Daniela; Mariani, Leonardo (2019). \"Automatic Software Repair: A Survey\" (PDF) . IEEE Transactions on Software Engineering . 45 (1): 34\u2013 67. doi : 10.1109/TSE.2017.2755013 . hdl : 10281/184798 . S2CID 57764123 . ^ Tan, Shin Hwei; Roychoudhury, Abhik (2015). \"relifix: Automated repair of software regressions\". 2015 IEEE/ACM 37th IEEE International Conference on Software Engineering . IEEE. pp. 471\u2013 482. doi : 10.1109/ICSE.2015.65 . ISBN 978-1-4799-1934-5 . S2CID 17125466 . ^ \"SuperTrace Probe hardware debugger\" . www.ghs.com . Archived from the original on 2017-12-01 . Retrieved 2017-11-25 . ^ \"Debugger and real-time trace tools\" . www.lauterbach.com . Archived from the original on 2022-01-25 . Retrieved 2020-06-05 . ^ Tancreti, Matthew; Hossain, Mohammad Sajjad; Bagchi, Saurabh; Raghunathan, Vijay (2011). \"Aveksha\". Proceedings of the 9th ACM Conference on Embedded Networked Sensor Systems . SenSys '11. New York, NY, USA: ACM. pp. 288\u2013 301. doi : 10.1145/2070942.2070972 . ISBN 9781450307185 . S2CID 14769602 . ^ Lim, Roman; Ferrari, Federico; Zimmerling, Marco; Walser, Christoph; Sommer, Philipp; Beutel, Jan (2013). \"FlockLab\". Proceedings of the 12th international conference on Information processing in sensor networks . IPSN '13. New York, NY, USA: ACM. pp. 153\u2013 166. doi : 10.1145/2461381.2461402 . ISBN 9781450319591 . S2CID 447045 . ^ Shields, Tyler (2008-12-02). \"Anti-Debugging Series \u2013 Part I\" . Veracode . Archived from the original on 2016-10-19 . Retrieved 2009-03-17 . ^ a b \"Software Protection through Anti-Debugging Michael N Gagnon, Stephen Taylor, Anup Ghosh\" (PDF) . Archived from the original (PDF) on 2011-10-01 . Retrieved 2010-10-25 . ^ Ross J. Anderson (2001-03-23). Security Engineering . Wiley. p.\u00a0684. ISBN 0-471-38922-6 . ^ \"Microsoft Word for DOS 1.15\" . Archived from the original on 2013-05-14 . Retrieved 2013-06-22 . Further reading [ edit ] Agans, David J. (2002). Debugging: The Nine Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems . AMACOM. ISBN 0-8144-7168-4 . Blunden, Bill (2003). Software Exorcism: A Handbook for Debugging and Optimizing Legacy Code . APress. ISBN 1-59059-234-4 . Ford, Ann R.; Teorey, Toby J. (2002). Practical Debugging in C++ . Prentice Hall. ISBN 0-13-065394-2 . Gr\u00f6tker, Thorsten; Holtmann, Ulrich; Keding, Holger; Wloka, Markus (2012). The Developer's Guide to Debugging, Second Edition . Createspace. ISBN 978-1-4701-8552-7 . Metzger, Robert C. (2003). Debugging by Thinking: A Multidisciplinary Approach . Digital Press. ISBN 1-55558-307-5 . Myers, Glenford J (2004). The Art of Software Testing . John Wiley & Sons Inc. ISBN 0-471-04328-1 . Robbins, John (2000). Debugging Applications . Microsoft Press. ISBN 0-7356-0886-5 . Telles, Matthew A.; Hsieh, Yuan (2001). The Science of Debugging . The Coriolis Group. ISBN 1-57610-917-8 . Vostokov, Dmitry (2008). Memory Dump Analysis Anthology Volume 1 . OpenTask. ISBN 978-0-9558328-0-2 . Zeller, Andreas (2009). Why Programs Fail, Second Edition: A Guide to Systematic Debugging . Morgan Kaufmann. ISBN 978-0-1237-4515-6 . Peggy Aldrich Kidwell, Stalking the Elusive Computer Bug , IEEE Annals of the History of Computing, 1998. External links [ edit ] Wikiquote has quotations related to Debugging . The Wikibook Computer Programming Principles has a page on the topic of: Debugging Crash dump analysis patterns \u2013  in-depth articles on analyzing and finding bugs in crash dumps The Essentials of Debugging \u2013  how to improve your debugging skills Plug-in Based Debugging For Embedded Systems Embedded Systems test and debug \u2013 about digital input generation \u2013  results of a survey about embedded system test and debug, Byte Paradigm (archived from the original on January 12, 2012) Authority control databases National United States Czech Republic Israel Other Yale LUX Retrieved from \" https://en.wikipedia.org/w/index.php?title=Debugging&oldid=1326837324 \" Category : Debugging Hidden categories: CS1 maint: archived copy as title Webarchive template wayback links Articles with short description Short description is different from Wikidata All articles with unsourced statements Articles with unsourced statements from February 2016 Articles with excerpts This page was last edited on 11 December 2025, at 04:25 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Debugging 39 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_testing",
    "title": "Software testing - Wikipedia",
    "content": "Software testing - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Economics 2 History 3 Goals Toggle Goals subsection 3.1 Finding bugs 3.2 Ensuring requirements are satisfied 3.3 Code coverage 4 Categories Toggle Categories subsection 4.1 Automated testing 4.2 Levels 4.2.1 Unit testing 4.2.2 Integration testing 4.2.3 System testing 4.3 Static, dynamic, and passive testing 4.4 Exploratory 4.5 Preset testing vs adaptive testing 4.6 Black/white box 4.6.1 White-box testing 4.6.2 Black-box testing 4.6.2.1 Visual testing 4.6.3 Grey-box testing 4.7 Installation testing 4.8 Compatibility testing 4.9 Smoke and sanity testing 4.10 Regression testing 4.11 Acceptance testing 4.12 Alpha testing 4.13 Beta testing 4.14 Functional vs non-functional testing 4.15 Continuous testing 4.16 Destructive testing 4.17 Software performance testing 4.18 Usability testing 4.19 Accessibility testing 4.19.1 Common standards for compliance 4.20 Security testing 4.21 Internationalization and localization 4.22 Development testing 4.23 A/B testing 4.24 Concurrent testing 4.25 Conformance testing or type testing 4.26 Output comparison testing 4.27 Property testing 4.28 Metamorphic testing 4.29 VCR testing 4.30 Contract Testing 5 Teamwork Toggle Teamwork subsection 5.1 Roles 5.2 Processes 5.2.1 Waterfall development 5.2.2 Agile development 5.2.3 Sample process 6 Quality Toggle Quality subsection 6.1 Software verification and validation 6.2 Software quality assurance 6.3 Measures 6.4 Artifacts 6.4.1 Test plan 6.4.2 Traceability matrix 6.4.3 Test case 6.4.4 Test script 6.4.5 Test suite 6.4.6 Test fixture or test data 6.4.7 Test harness 6.4.8 Test run 6.5 Certifications 7 Controversy 8 See also 9 References 10 Further reading 11 External links Toggle the table of contents Software testing 49 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u09ac\u09be\u0982\u09b2\u09be \u0411\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f \u0411\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f (\u0442\u0430\u0440\u0430\u0448\u043a\u0435\u0432\u0456\u0446\u0430) \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u010ce\u0161tina Deutsch Eesti Espa\u00f1ol Euskara \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 \u0540\u0561\u0575\u0565\u0580\u0565\u0576 \u0939\u093f\u0928\u094d\u0926\u0940 Ido Bahasa Indonesia Italiano \u05e2\u05d1\u05e8\u05d9\u05ea \u0c95\u0ca8\u0ccd\u0ca8\u0ca1 \u10e5\u10d0\u10e0\u10d7\u10e3\u10da\u10d8 \u049a\u0430\u0437\u0430\u049b\u0448\u0430 Latvie\u0161u Magyar \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 Bahasa Melayu Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas Qaraqalpaqsha Rom\u00e2n\u0103 \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0dc3\u0dd2\u0d82\u0dc4\u0dbd Simple English Sloven\u010dina \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Suomi Svenska \u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikibooks Wikiversity Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Checking software against a standard Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e TestingCup \u2013 Polish Championship in Software Testing, Katowice , May 2016 Software testing is the act of checking whether software meets its intended objectives and satisfies expectations. Software testing can provide objective, independent information about the quality of software and the risk of its failure to a user or sponsor or any other stakeholder. [ 1 ] Software testing can determine the correctness of software for specific scenarios but cannot determine correctness for all scenarios. [ 2 ] [ 3 ] It cannot find all bugs . Based on the criteria for measuring correctness from an oracle , software testing employs principles and mechanisms that might recognize a problem. Examples of oracles include specifications , contracts , [ 4 ] comparable products, past versions of the same product, inferences about intended or expected purpose, user or customer expectations, relevant standards, and applicable laws. Software testing can be functional or non-functional in nature. Software testing is often dynamic in nature: running the software to verify actual output matches expected. It can also be static in nature: reviewing code and its associated documentation . Software testing is often used to answer the question: Does the software do what it is supposed to do and what it needs to do? Information learned from software testing may be used to improve the process by which software is developed. [ 5 ] :\u200a41\u201343 A commonly suggested approach to automated testing is the \"test pyramid,\" wherein most of the tests are unit tests , followed by a smaller set of integration tests and finally a few end-to-end (e2e) tests . [ 6 ] [ 7 ] [ 8 ] Economics [ edit ] A study conducted by NIST in 2002 reported that software bugs cost the U.S. economy $59.5 billion annually. More than a third of this cost could be avoided if better software testing was performed. [ 9 ] [ dubious \u2013 discuss ] Outsourcing software testing because of costs is very common, with China, the Philippines, and India being preferred destinations. [ 10 ] History [ edit ] Glenford J. Myers initially introduced the separation of debugging from testing in 1979. [ 11 ] Although his attention was on breakage testing (\"A successful test case is one that detects an as-yet undiscovered error.\" [ 11 ] :\u200a16 ), it illustrated the desire of the software engineering community to separate fundamental development activities, such as debugging, from that of verification.\nSoftware testing typically includes handling software bugs \u2013 a defect in the code that causes an undesirable result. [ 12 ] :\u200a31 Bugs generally slow testing progress and involve programmer assistance to debug and fix. Not all defects cause a failure. For example, a defect in dead code will not be considered a failure. A defect that does not cause failure at one point in time may lead to failure later due to environmental changes. Examples of environment change include running on new computer hardware , changes in data , and interacting with different software. [ 13 ] Goals [ edit ] Software testing is typically goal driven. Finding bugs [ edit ] Software testing typically includes handling software bugs \u2013 a defect in the code that causes an undesirable result. [ 12 ] :\u200a31 Bugs generally slow testing progress and involve programmer assistance to debug and fix. Not all defects cause a failure. For example, a defect in dead code will not be considered a failure. A defect that does not cause failure at one point in time may lead to failure later due to environmental changes. Examples of environment change include running on new computer hardware , changes in data , and interacting with different software. [ 14 ] A single defect may result in multiple failure symptoms. Ensuring requirements are satisfied [ edit ] Software testing may involve a Requirements gap \u2013 omission from the design for a requirement. [ 5 ] :\u200a426 Requirement gaps can often be non-functional requirements such as testability , scalability , maintainability , performance , and security . Code coverage [ edit ] A fundamental limitation of software testing is that testing under all combinations of inputs and preconditions (initial state) is not feasible, even with a simple product. [ 3 ] :\u200a17\u201318 [ 15 ] Defects that manifest in unusual conditions are difficult to find in testing. Also, non-functional dimensions of quality (how it is supposed to be versus what it is supposed to do ) \u2013 usability , scalability , performance , compatibility , and reliability \u2013 can be subjective; something that constitutes sufficient value to one person may not to another. Although testing for every possible input is not feasible, testing can use combinatorics to maximize coverage while minimizing tests. [ 16 ] Categories [ edit ] Main article: Software testing tactics Testing can be categorized many ways. [ 17 ] Automated testing [ edit ] This paragraph is an excerpt from Test automation . [ edit ] Test automation is the use of software (separate from the software being tested) for controlling the execution of tests and comparing actual outcome with predicted. [ 18 ] Test automation supports testing the system under test (SUT) without manual interaction which can lead to faster test execution and testing more often. Test automation is a key aspect of continuous testing and often for continuous integration and continuous delivery (CI/CD). [ 19 ] Levels [ edit ] Software testing can be categorized into levels based on how much of the software system is the focus of a test. [ 20 ] [ 21 ] [ 22 ] [ 23 ] Unit testing [ edit ] This paragraph is an excerpt from Unit testing . [ edit ] Unit testing , a.k.a. component or module testing, is a form of software testing by which isolated source code is tested to validate expected behavior. [ 24 ] Integration testing [ edit ] This paragraph is an excerpt from Integration testing . [ edit ] Integration testing is a form of software testing in which multiple software components, modules, or services are tested together to verify they work as expected when combined. The focus is on testing the interactions and data exchange between integrated parts, rather than testing components in isolation. System testing [ edit ] This paragraph is an excerpt from System testing . [ edit ] System testing , a.k.a. end-to-end (E2E) testing, is testing conducted on a complete software system . Static, dynamic, and passive testing [ edit ] There are many approaches to software testing. Reviews , walkthroughs , or inspections are referred to as static testing, whereas executing programmed code with a given set of test cases is referred to as dynamic testing . [ 25 ] [ 26 ] Static testing is often implicit, like proofreading, plus when programming tools/text editors check source code structure or compilers (pre-compilers) check syntax and data flow as static program analysis . Dynamic testing takes place when the program itself is run. Dynamic testing may begin before the program is 100% complete in order to test particular sections of code and are applied to discrete functions or modules. [ 25 ] [ 26 ] Typical techniques for these are either using stubs /drivers or execution from a debugger environment. [ 26 ] Static testing involves verification , whereas dynamic testing also involves validation . [ 26 ] Passive testing means verifying the system's behavior without any interaction with the software product. Contrary to active testing, testers do not provide any test data but look at system logs and traces. They mine for patterns and specific behavior in order to make some kind of decisions. [ 27 ] This is related to offline runtime verification and log analysis . Exploratory [ edit ] This section is an excerpt from Exploratory testing . [ edit ] Exploratory testing is an approach to software testing that is concisely described as simultaneous learning, test design and test execution. Cem Kaner , who coined the term in 1984, [ 28 ] defines exploratory testing as \"a style of software testing that emphasizes the personal freedom and responsibility of the individual tester to continually optimize the quality of his/her work by treating test-related learning, test design, test execution, and test result interpretation as mutually supportive activities that run in parallel throughout the project.\" [ 29 ] Preset testing vs adaptive testing [ edit ] The type of testing strategy to be performed depends on whether the tests to be applied to the IUT should be decided before the testing plan starts to be executed (preset testing [ 30 ] ) or whether each input to be applied to the IUT can be dynamically dependent on the outputs obtained during the application of the previous tests (adaptive testing [ 31 ] [ 32 ] ). Black/white box [ edit ] Software testing can often be divided into white-box and black-box. These two approaches are used to describe the point of view that the tester takes when designing test cases. A hybrid approach called grey-box that includes aspects of both boxes may also be applied to software testing methodology. [ 33 ] [ 34 ] White-box testing [ edit ] Main article: White-box testing White box testing diagram White-box testing (also known as clear box testing, glass box testing, transparent box testing, and structural testing) verifies the internal structures or workings of a program, as opposed to the functionality exposed to the end-user. In white-box testing, an internal perspective of the system (the source code), as well as programming skills are used to design test cases. The tester chooses inputs to exercise paths through the code and determines the appropriate outputs. [ 33 ] [ 34 ] This is analogous to testing nodes in a circuit, e.g., in-circuit testing (ICT). While white-box testing can be applied at the unit , integration , and system levels of the software testing process, it is usually done at the unit level. [ 35 ] It can test paths within a unit, paths between units during integration, and between subsystems during a system\u2013level test. Though this method of test design can uncover many errors or problems, it might not detect unimplemented parts of the specification or missing requirements. Techniques used in white-box testing include: [ 34 ] [ 36 ] API testing \u2013 testing of the application using public and private APIs (application programming interfaces) Code coverage \u2013 creating tests to satisfy some criteria of code coverage (for example, the test designer can create tests to cause all statements in the program to be executed at least once) Fault injection methods \u2013 intentionally introducing faults to gauge the efficacy of testing strategies Mutation testing methods Static testing methods Code coverage tools can evaluate the completeness of a test suite that was created with any method, including black-box testing. This allows the software team to examine parts of a system that are rarely tested and ensures that the most important function points have been tested. [ 37 ] Code coverage as a software metric can be reported as a percentage for: [ 33 ] [ 37 ] [ 38 ] Function coverage , which reports on functions executed Statement coverage , which reports on the number of lines executed to complete the test Decision coverage , which reports on whether both the True and the False branch of a given test has been executed 100% statement coverage ensures that all code paths or branches (in terms of control flow ) are executed at least once. This is helpful in ensuring correct functionality, but not sufficient since the same code may process different inputs correctly or incorrectly. [ 39 ] Black-box testing [ edit ] Main article: Black-box testing Black box diagram Black-box testing (also known as functional testing) describes designing test cases without knowledge of the implementation, without reading the source code. The testers are only aware of what the software is supposed to do, not how it does it. [ 40 ] Black-box testing methods include: equivalence partitioning , boundary value analysis , all-pairs testing , state transition tables , decision table testing, fuzz testing , model-based testing , use case testing, exploratory testing , and specification-based testing. [ 33 ] [ 34 ] [ 38 ] Specification-based testing aims to test the functionality of software according to the applicable requirements. [ 41 ] This level of testing usually requires thorough test cases to be provided to the tester, who then can simply verify that for a given input, the output value (or behavior), either \"is\" or \"is not\" the same as the expected value specified in the test case. Test cases are built around specifications and requirements, i.e., what the application is supposed to do. It uses external descriptions of the software, including specifications, requirements, and designs, to derive test cases. These tests can be functional or non-functional , though usually functional. Specification-based testing may be necessary to assure correct functionality, but it is insufficient to guard against complex or high-risk situations. [ 42 ] Black box testing can be used to any level of testing although usually not at the unit level. [ 35 ] Component interface testing Component interface testing is a variation of black-box testing , with the focus on the data values beyond just the related actions of a subsystem component. [ 43 ] The practice of component interface testing can be used to check the handling of data passed between various units, or subsystem components, beyond full integration testing between those units. [ 44 ] [ 45 ] The data being passed can be considered as \"message packets\" and the range or data types can be checked for data generated from one unit and tested for validity before being passed into another unit. One option for interface testing is to keep a separate log file of data items being passed, often with a timestamp logged to allow analysis of thousands of cases of data passed between units for days or weeks. Tests can include checking the handling of some extreme data values while other interface variables are passed as normal values. [ 44 ] Unusual data values in an interface can help explain unexpected performance in the next unit. Visual testing [ edit ] The aim of visual testing is to provide developers with the ability to examine what was happening at the point of software failure by presenting the data in such a way that the developer can easily find the information he or she requires, and the information is expressed clearly. [ 46 ] [ 47 ] At the core of visual testing is the idea that showing someone a problem (or a test failure), rather than just describing it, greatly increases clarity and understanding. Visual testing, therefore, requires the recording of the entire test process \u2013 capturing everything that occurs on the test system in video format. Output videos are supplemented by real-time tester input via picture-in-a-picture webcam and audio commentary from microphones. Visual testing provides a number of advantages. The quality of communication is increased drastically because testers can show the problem (and the events leading up to it) to the developer as opposed to just describing it, and the need to replicate test failures will cease to exist in many cases. The developer will have all the evidence he or she requires of a test failure and can instead focus on the cause of the fault and how it should be fixed. Ad hoc testing and exploratory testing are important methodologies for checking software integrity because they require less preparation time to implement, while the important bugs can be found quickly. [ 48 ] In ad hoc testing, where testing takes place in an improvised impromptu way, the ability of the tester(s) to base testing off documented methods and then improvise variations of those tests can result in a more rigorous examination of defect fixes. [ 48 ] However, unless strict documentation of the procedures is maintained, one of the limits of ad hoc testing is lack of repeatability. [ 48 ] Further information: Graphical user interface testing Grey-box testing [ edit ] Main article: Gray box testing Grey-box testing (American spelling: gray-box testing) involves using knowledge of internal data structures and algorithms for purposes of designing tests while executing those tests at the user, or black-box level. The tester will often have access to both \"the source code and the executable binary.\" [ 49 ] Grey-box testing may also include reverse engineering (using dynamic code analysis) to determine, for instance, boundary values or error messages. [ 49 ] Manipulating input data and formatting output do not qualify as grey-box, as the input and output are clearly outside of the \"black box\" that we are calling the system under test. This distinction is particularly important when conducting integration testing between two modules of code written by two different developers, where only the interfaces are exposed for the test. By knowing the underlying concepts of how the software works, the tester makes better-informed testing choices while testing the software from outside. Typically, a grey-box tester will be permitted to set up an isolated testing environment with activities, such as seeding a database . The tester can observe the state of the product being tested after performing certain actions such as executing SQL statements against the database and then executing queries to ensure that the expected changes have been reflected. Grey-box testing implements intelligent test scenarios based on limited information. This will particularly apply to data type handling, exception handling , and so on. [ 50 ] With the concept of grey-box testing, this \"arbitrary distinction\" between black- and white-box testing has faded somewhat. [ 35 ] Installation testing [ edit ] This section is an excerpt from Installation testing . [ edit ] Most software systems have installation procedures that are needed before they can be used for their main purpose. Testing these procedures to achieve an installed software system that may be used is known as installation testing . [ 51 ] :\u200a139 These procedures may involve full or partial upgrades, and install/uninstall processes. A user must select a variety of options. Dependent files and libraries must be allocated, loaded or located. Valid hardware configurations must be present. Software systems may need connectivity to connect to other software systems. [ 51 ] :\u200a145 Compatibility testing [ edit ] Main article: Compatibility testing A common cause of software failure (real or perceived) is a lack of its compatibility with other application software , operating systems (or operating system versions , old or new), or target environments that differ greatly from the original (such as a terminal or GUI application intended to be run on the desktop now being required to become a Web application , which must render in a Web browser ). For example, in the case of a lack of backward compatibility , this can occur because the programmers develop and test software only on the latest version of the target environment, which not all users may be running. This results in the unintended consequence that the latest work may not function on earlier versions of the target environment, or on older hardware that earlier versions of the target environment were capable of using. Sometimes such issues can be fixed by proactively abstracting operating system functionality into a separate program module or library . Smoke and sanity testing [ edit ] Main article: Smoke testing (software) Sanity testing determines whether it is reasonable to proceed with further testing. Smoke testing consists of minimal attempts to operate the software, designed to determine whether there are any basic problems that will prevent it from working at all. Such tests can be used as build verification test . Regression testing [ edit ] Main article: Regression testing Regression testing focuses on finding defects after a major code change has occurred. Specifically, it seeks to uncover software regressions , as degraded or lost features, including old bugs that have come back. Such regressions occur whenever software functionality that was previously working correctly, stops working as intended. Typically, regressions occur as an unintended consequence of program changes, when the newly developed part of the software collides with the previously existing code. Regression testing is typically the largest test effort in commercial software development, [ 52 ] due to checking numerous details in prior software features, and even new software can be developed while using some old test cases to test parts of the new design to ensure prior functionality is still supported. Common methods of regression testing include re-running previous sets of test cases and checking whether previously fixed faults have re-emerged. The depth of testing depends on the phase in the release process and the risk of the added features. They can either be complete, for changes added late in the release or deemed to be risky, or be very shallow, consisting of positive tests on each feature, if the changes are early in the release or deemed to be of low risk. Acceptance testing [ edit ] Main article: Acceptance testing Acceptance testing is system-level testing to ensure the software meets customer expectations. [ 53 ] [ 54 ] [ 55 ] [ 56 ] Acceptance testing may be performed as part of the hand-off process between any two phases of development. [ citation needed ] Tests are frequently grouped into these levels by where they are performed in the software development process, or by the level of specificity of the test. [ 56 ] User acceptance testing (UAT) Operational acceptance testing (OAT) Contractual and regulatory acceptance testing Alpha and beta testing Sometimes, UAT is performed by the customer, in their environment and on their own hardware. OAT is used to conduct operational readiness (pre-release) of a product, service or system as part of a quality management system . OAT is a common type of non-functional software testing, used mainly in software development and software maintenance projects. This type of testing focuses on the operational readiness of the system to be supported, or to become part of the production environment. Hence, it is also known as operational readiness testing (ORT) or operations readiness and assurance (OR&A) testing. Functional testing within OAT is limited to those tests that are required to verify the non-functional aspects of the system. In addition, the software testing should ensure that the portability of the system, as well as working as expected, does not also damage or partially corrupt its operating environment or cause other processes within that environment to become inoperative. [ 57 ] Contractual acceptance testing is performed based on the contract's acceptance criteria defined during the agreement of the contract, while regulatory acceptance testing is performed based on the relevant regulations to the software product. Both of these two tests can be performed by users or independent testers. Regulation acceptance testing sometimes involves the regulatory agencies auditing the test results. [ 56 ] Alpha testing [ edit ] Alpha testing is simulated or actual operational testing by potential users/customers or an independent test team at the developers' site. Alpha testing is often employed for off-the-shelf software as a form of internal acceptance testing before the software goes to beta testing. [ 58 ] Beta testing [ edit ] See also: Software release life cycle \u00a7\u00a0Beta Beta testing comes after alpha testing and can be considered a form of external user acceptance testing . Versions of the software, known as beta versions , are released to a limited audience outside of the programming team known as beta testers. The software is released to groups of people so that further testing can ensure the product has few faults or bugs . Beta versions can be made available to the open public to increase the feedback field to a maximal number of future users and to deliver value earlier, for an extended or even indefinite period of time ( perpetual beta ). [ 59 ] Functional vs non-functional testing [ edit ] Functional testing refers to activities that verify a specific action or function of the code. These are usually found in the code requirements documentation, although some development methodologies work from use cases or user stories. Functional tests tend to answer the question of \"can the user do this\" or \"does this particular feature work.\" Non-functional testing refers to aspects of the software that may not be related to a specific function or user action, such as scalability or other performance , behavior under certain constraints , or security . Testing will determine the breaking point, the point at which extremes of scalability or performance leads to unstable execution. Non-functional requirements tend to be those that reflect the quality of the product, particularly in the context of the suitability perspective of its users. Continuous testing [ edit ] Main article: Continuous testing Continuous testing is the process of executing automated tests as part of the software delivery pipeline to obtain immediate feedback on the business risks associated with a software release candidate. [ 60 ] [ 61 ] Continuous testing includes the validation of both functional requirements and non-functional requirements ; the scope of testing extends from validating bottom-up requirements or user stories to assessing the system requirements associated with overarching business goals. [ 62 ] [ 63 ] Destructive testing [ edit ] Main article: Destructive testing Destructive testing attempts to cause the software or a sub-system to fail. It verifies that the software functions properly even when it receives invalid or unexpected inputs, thereby establishing the robustness of input validation and error-management routines. [ citation needed ] Software fault injection , in the form of fuzzing , is an example of failure testing. Various commercial non-functional testing tools are linked from the software fault injection page; there are also numerous open-source and free software tools available that perform destructive testing. Further information: Exception handling and Recovery testing Software performance testing [ edit ] Main article: Software performance testing Performance testing is generally executed to determine how a system or sub-system performs in terms of responsiveness and stability under a particular workload. It can also serve to investigate, measure, validate or verify other quality attributes of the system, such as scalability, reliability and resource usage. Load testing is primarily concerned with testing that the system can continue to operate under a specific load, whether that be large quantities of data or a large number of users . This is generally referred to as software scalability . The related load testing activity of when performed as a non-functional activity is often referred to as endurance testing . Volume testing is a way to test software functions even when certain components (for example a file or database) increase radically in size. Stress testing is a way to test reliability under unexpected or rare workloads. Stability testing (often referred to as load or endurance testing) checks to see if the software can continuously function well in or above an acceptable period. There is little agreement on what the specific goals of performance testing are. The terms load testing, performance testing, scalability testing , and volume testing, are often used interchangeably. Real-time software systems have strict timing constraints. To test if timing constraints are met, real-time testing is used. Usability testing [ edit ] Usability testing is to check if the user interface is easy to use and understand. It is concerned mainly with the use of the application. This is not a kind of testing that can be automated; actual human users are needed, being monitored by skilled UI designers . Usability testing can use structured models to check how well an interface works. The Stanton, Theofanos, and Joshi (2015) model looks at user experience, and the Al-Sharafat and Qadoumi (2016) model is for expert evaluation, helping to assess usability in digital applications. [ 64 ] Accessibility testing [ edit ] Accessibility testing is done to ensure that the software is accessible to persons with disabilities. Some of the common web accessibility tests are Ensuring that the color contrast between the font and the background color is appropriate Font Size Alternate Texts for multimedia content Ability to use the system using the computer keyboard in addition to the mouse. Common standards for compliance [ edit ] Americans with Disabilities Act of 1990 Section 508 Amendment to the Rehabilitation Act of 1973 Web Accessibility Initiative (WAI) of the World Wide Web Consortium (W3C) Security testing [ edit ] Security testing is essential for software that processes confidential data to prevent system intrusion by hackers . The International Organization for Standardization (ISO) defines this as a \"type of testing conducted to evaluate the degree to which a test item, and associated data and information, are protected so that unauthorised persons or systems cannot use, read or modify them, and authorized persons or systems are not denied access to them.\" [ 65 ] Internationalization and localization [ edit ] Testing for internationalization and localization validates that the software can be used with different languages and geographic regions. The process of pseudolocalization is used to test the ability of an application to be translated to another language, and make it easier to identify when the localization process may introduce new bugs into the product. Globalization testing verifies that the software is adapted for a new culture, such as different currencies or time zones. [ 66 ] Actual translation to human languages must be tested, too. Possible localization and globalization failures include: Some messages may be untranslated. Software is often localized by translating a list of strings out of context, and the translator may choose the wrong translation for an ambiguous source string. Technical terminology may become inconsistent, if the project is translated by several people without proper coordination or if the translator is imprudent. Literal word-for-word translations may sound inappropriate, artificial or too technical in the target language. Untranslated messages in the original language may be hard coded in the source code, and thus untranslatable. Some messages may be created automatically at run time and the resulting string may be ungrammatical, functionally incorrect, misleading or confusing. Software may use a keyboard shortcut that has no function on the source language's keyboard layout , but is used for typing characters in the layout of the target language. Software may lack support for the character encoding of the target language. Fonts and font sizes that are appropriate in the source language may be inappropriate in the target language; for example, CJK characters may become unreadable if the font is too small. A string in the target language may be longer than the software can handle. This may make the string partly invisible to the user or cause the software to crash or malfunction. Software may lack proper support for reading or writing bi-directional text . Software may display images with text that was not localized. Localized operating systems may have differently named system configuration files and environment variables and different formats for date and currency . Development testing [ edit ] Main article: Development testing Development testing is a software development process that involves the synchronized application of a broad spectrum of defect prevention and detection strategies in order to reduce software development risks, time, and costs. It is performed by the software developer or engineer during the construction phase of the software development lifecycle. Development testing aims to eliminate construction errors before code is promoted to other testing; this strategy is intended to increase the quality of the resulting software as well as the efficiency of the overall development process. Depending on the organization's expectations for software development, development testing might include static code analysis , data flow analysis, metrics analysis, peer code reviews, unit testing, code coverage analysis, traceability , and other software testing practices. A/B testing [ edit ] Main article: A/B testing A/B testing is a method of running a controlled experiment to determine if a proposed change is more effective than the current approach. Customers are routed to either a current version (control) of a feature, or to a modified version (treatment) and data is collected to determine which version is better at achieving the desired outcome. Concurrent testing [ edit ] Main article: Concurrent testing Concurrent or concurrency testing assesses the behaviour and performance of software and systems that use concurrent computing , generally under normal usage conditions. Typical problems this type of testing will expose are deadlocks, race conditions and problems with shared memory/resource handling. Conformance testing or type testing [ edit ] Main article: Conformance testing In software testing, conformance testing verifies that a product performs according to its specified standards. Compilers, for instance, are extensively tested to determine whether they meet the recognized standard for that language. Output comparison testing [ edit ] Creating a display expected output, whether as data comparison of text or screenshots of the UI, [ 3 ] :\u200a195 is sometimes called snapshot testing or Golden Master Testing unlike many other forms of testing, this cannot detect failures automatically and instead requires that a human evaluate the output for inconsistencies. Property testing [ edit ] Not to be confused with property testing algorithms . Property testing is a testing technique where, instead of asserting that specific inputs produce specific expected outputs, the practitioner randomly generates many inputs, runs the program on all of them, and asserts the truth of some \"property\" that should be true for every pair of input and output. For example, every output from a serialization function should be accepted by the corresponding deserialization function, and every output from a sort function should be a monotonically increasing list containing exactly the same elements as its input. Property testing libraries allow the user to control the strategy by which random inputs are constructed, to ensure coverage of degenerate cases, or inputs featuring specific patterns that are needed to fully exercise aspects of the implementation under test. Property testing is also sometimes known as \"generative testing\" or \"QuickCheck testing\" since it was introduced and popularized by the Haskell library QuickCheck . [ 67 ] Metamorphic testing [ edit ] Main article: Metamorphic testing Metamorphic testing (MT) is a property-based software testing technique, which can be an effective approach for addressing the test oracle problem and test case generation problem. The test oracle problem is the difficulty of determining the expected outcomes of selected test cases or to determine whether the actual outputs agree with the expected outcomes. VCR testing [ edit ] VCR testing, also known as \"playback testing\" or \"record/replay\" testing, is a testing technique for increasing the reliability and speed of regression tests that involve a component that is slow or unreliable to communicate with, often a third-party API outside of the tester's control. It involves making a recording (\"cassette\") of the system's interactions with the external component, and then replaying the recorded interactions as a substitute for communicating with the external system on subsequent runs of the test. The technique was popularized in web development by the Ruby library vcr . Contract Testing [ edit ] Contract testing, not to be confused with the aforementioned legally-motivated contractual acceptance testing, is a methodology consisting of testing the intergration point between any two software services by checking if the requests and responses sent between each conform to a shared set of expectations commonly referred to as a contract. It is often used in the context of distributed systems , service-oriented software architectures , and microservices . [ 68 ] [ 69 ] Teamwork [ edit ] Roles [ edit ] In an organization, testers may be in a separate team from the rest of the software development team or they may be integrated into one team. Software testing can also be performed by non-dedicated software testers. In the 1980s, the term software tester started to be used to denote a separate profession. Notable software testing roles and titles include: [ 70 ] test manager , test lead , test analyst , test designer , tester , automation developer , and test administrator . [ 71 ] Processes [ edit ] Organizations that develop software, perform testing differently, but there are common patterns. [ 2 ] Waterfall development [ edit ] Further information: Capability Maturity Model Integration and Waterfall model In waterfall development , testing is generally performed after the code is completed, but before the product is shipped to the customer. [ 72 ] This practice often results in the testing phase being used as a project buffer to compensate for project delays, thereby compromising the time devoted to testing. [ 11 ] :\u200a145\u2013146 Some contend that the waterfall process allows for testing to start when the development project starts and to be a continuous process until the project finishes. [ 73 ] Agile development [ edit ] Agile software development commonly involves testing while the code is being written and organizing teams with both programmers and testers and with team members performing both programming and testing. One agile practice, test-driven software development (TDD), is a way of unit testing such that unit-level testing is performed while writing the product code. [ 74 ] Test code is updated as new features are added and failure conditions are discovered (bugs fixed). Commonly, the unit test code is maintained with the project code, integrated in the build process, and run on each build and as part of regression testing. Goals of this continuous integration is to support development and reduce defects. [ 75 ] [ 74 ] Even in organizations that separate teams by programming and testing functions, many often have the programmers perform unit testing . [ 76 ] Sample process [ edit ] The sample below is common for waterfall development. The same activities are commonly found in other development models, but might be described differently. Requirements analysis : testing should begin in the requirements phase of the software development life cycle . During the design phase, testers work to determine what aspects of a design are testable and with what parameters those tests work. Test planning: test strategy , test plan , testbed creation. Since many activities will be carried out during testing, a plan is needed. Test development: test procedures, test scenarios , test cases , test datasets, test scripts to use in testing software. Test execution: testers execute the software based on the plans and test documents then report any errors found to the development team. This part could be complex when running tests with a lack of programming knowledge. Test reporting: once testing is completed, testers generate metrics and make final reports on their test effort and whether the software tested is ready for release. Test result analysis: or defect analysis , is done by the development team usually along with the client, in order to decide what defects should be assigned, fixed, rejected (i.e. found software working properly) or deferred to be dealt with later. Defect retesting: once a defect has been dealt with by the development team, it is retested by the testing team. Regression testing : it is common to have a small test program built of a subset of tests, for each integration of new, modified, or fixed software, in order to ensure that the latest delivery has not ruined anything and that the software product as a whole is still working correctly. Test closure: once the test meets the exit criteria, the activities such as capturing the key outputs, lessons learned, results, logs, documents related to the project are archived and used as a reference for future projects. Quality [ edit ] Main article: Software quality Software verification and validation [ edit ] Main articles: Verification and validation (software) and Software quality control Software testing is used in association with verification and validation : [ 77 ] Verification: Have we built the software right? (i.e., does it implement the requirements). Validation: Have we built the right software? (i.e., do the deliverables satisfy the customer). The terms verification and validation are commonly used interchangeably in the industry; it is also common to see these two terms defined with contradictory definitions. According to the IEEE Standard Glossary of Software Engineering Terminology : [ 12 ] :\u200a80\u201381 Verification is the process of evaluating a system or component to determine whether the products of a given development phase satisfy the conditions imposed at the start of that phase. Validation is the process of evaluating a system or component during or at the end of the development process to determine whether it satisfies specified requirements. And, according to the ISO 9000 standard: Verification is confirmation by examination and through provision of objective evidence that specified requirements have been fulfilled. Validation is confirmation by examination and through provision of objective evidence that the requirements for a specific intended use or application have been fulfilled. The contradiction is caused by the use of the concepts of requirements and specified requirements but with different meanings. In the case of IEEE standards, the specified requirements, mentioned in the definition of validation, are the set of problems, needs and wants of the stakeholders that the software must solve and satisfy. Such requirements are documented in a Software Requirements Specification (SRS). And, the products mentioned in the definition of verification, are the output artifacts of every phase of the software development process. These products are, in fact, specifications such as Architectural Design Specification, Detailed Design Specification, etc. The SRS is also a specification, but it cannot be verified (at least not in the sense used here \u2013 more on this subject below). But, for the ISO 9000, the specified requirements are the set of specifications, as just mentioned above, that must be verified. A specification, as previously explained, is the product of a software development process phase that receives another specification as input. A specification is verified successfully when it correctly implements its input specification. All the specifications can be verified except the SRS because it is the first one (it can be validated, though). An example scenario be that the Design Specification must implement the SRS, and the Construction phase artifacts must implement the Design Specification. So, when these words are defined in common terms, the apparent contradiction disappears. Both the SRS and the software must be validated. The SRS can be validated statically by consulting with the stakeholders. Nevertheless, running some partial implementation of the software or a prototype of any kind (dynamic testing) and obtaining positive feedback from them, can further increase the certainty that the SRS is correctly formulated. On the other hand, the software, as a final and running product (not its artifacts and documents, including the source code) must be validated dynamically with the stakeholders by executing the software and having them to try it. Some might argue that, for SRS, the input is the words of stakeholders and, therefore, SRS validation is the same as SRS verification. Thinking this way is not advisable as it only causes more confusion. It is better to think of verification as a process involving a formal and technical input document. Software quality assurance [ edit ] In some organizations, software testing is part of a software quality assurance (SQA) process. [ 3 ] :\u200a347 In SQA, software process specialists and auditors are concerned with the software development process rather than just the artifacts such as documentation, code and systems. They examine and change the software engineering process itself to reduce the number of faults that end up in the delivered software: the so-called defect rate. What constitutes an acceptable defect rate depends on the nature of the software; a flight simulator video game would have much higher defect tolerance than software for an actual airplane. Although there are close links with SQA, testing departments often exist independently, and there may be no SQA function in some companies. Software testing is an activity to investigate software under test in order to provide quality-related information to stakeholders. By contrast, QA ( quality assurance ) is the implementation of policies and procedures intended to prevent defects from reaching customers. Measures [ edit ] Quality measures include such topics as correctness , completeness, security and ISO/IEC 9126 requirements such as capability, reliability , efficiency , portability , maintainability , compatibility, and usability . There are a number of frequently used software metrics , or measures, which are used to assist in determining the state of the software or the adequacy of the testing. Artifacts [ edit ] A software testing process can produce several artifacts . The actual artifacts produced are a factor of the software development model used, stakeholder and organisational needs. Test plan [ edit ] Main article: Test plan A test plan is a document detailing the approach that will be taken for intended test activities. The plan may include aspects such as objectives, scope, processes and procedures, personnel requirements, and contingency plans. [ 53 ] The test plan could come in the form of a single plan that includes all test types (like an acceptance or system test plan) and planning considerations, or it may be issued as a master test plan that provides an overview of more than one detailed test plan (a plan of a plan). [ 53 ] A test plan can be, in some cases, part of a wide \" test strategy \" which documents overall testing approaches, which may itself be a master test plan or even a separate artifact. Traceability matrix [ edit ] These paragraphs are an excerpt from Traceability matrix . [ edit ] In software development , a traceability matrix (TM) [ 78 ] :\u200a244 is a document, usually in the form of a table, used to assist in determining the completeness of a relationship by correlating any two baselined documents using a many-to-many relationship comparison. [ 78 ] :\u200a3\u201322 It is often used with high-level requirements (these often consist of marketing requirements) and detailed requirements of the product to the matching parts of high-level design , detailed design, test plan , and test cases . Test case [ edit ] Main article: Test case (software) A test case normally consists of a unique identifier, requirement references from a design specification, preconditions, events, a series of steps (also known as actions) to follow, input, output, expected result, and the actual result. Clinically defined, a test case is an input and an expected result. [ 79 ] This can be as terse as \"for condition x your derived result is y\", although normally test cases describe in more detail the input scenario and what results might be expected. It can occasionally be a series of steps (but often steps are contained in a separate test procedure that can be exercised against multiple test cases, as a matter of economy) but with one expected result or expected outcome. The optional fields are a test case ID, test step, or order of execution number, related requirement(s), depth, test category, author, and check boxes for whether the test is automatable and has been automated. Larger test cases may also contain prerequisite states or steps, and descriptions. A test case should also contain a place for the actual result. These steps can be stored in a word processor document, spreadsheet, database, or other common repositories. In a database system, you may also be able to see past test results, who generated the results, and what system configuration was used to generate those results. These past results would usually be stored in a separate table. Test script [ edit ] A test script is a procedure or programming code that replicates user actions. Initially, the term was derived from the product of work created by automated regression test tools. A test case will be a baseline to create test scripts using a tool or a program. Test suite [ edit ] This section is an excerpt from Test suite . [ edit ] In software development , a test suite , less commonly known as a validation suite, is a collection of test cases that are intended to be used to test a software program to show that it has some specified set of behaviors. [ 80 ] A test suite often contains detailed instructions or goals for each collection of test cases and information on the system configuration to be used during testing. A group of test cases may also contain prerequisite states or steps and descriptions of the following tests. Test fixture or test data [ edit ] Main article: Test fixture In most cases, multiple sets of values or data are used to test the same functionality of a particular feature. All the test values and changeable environmental components are collected in separate files and stored as test data. It is also useful to provide this data to the client and with the product or a project. There are techniques to generate Test data. Test harness [ edit ] Main article: Test harness The software, tools, samples of data input and output, and configurations are all referred to collectively as a test harness . Test run [ edit ] A test run is a collection of test cases or test suites that the user is executing and comparing the expected with the actual results. Once complete, a report or all executed tests may be generated. Certifications [ edit ] Further information: Certification \u00a7\u00a0In software testing Several certification programs exist to support the professional aspirations of software testers and quality assurance specialists. A few practitioners argue that the testing field is not ready for certification, as mentioned in the controversy section. Controversy [ edit ] Some of the major software testing controversies include: Agile vs. traditional Should testers learn to work under conditions of uncertainty and constant change or should they aim at process \"maturity\" ? The agile testing movement has received growing popularity since the early 2000s mainly in commercial circles, [ 81 ] [ 82 ] whereas government and military [ 83 ] software providers use this methodology but also the traditional test-last models (e.g., in the Waterfall model ). [ citation needed ] Manual vs. automated testing Some writers believe that test automation is so expensive relative to its value that it should be used sparingly. [ 84 ] The test automation then can be considered as a way to capture and implement the requirements. As a general rule, the larger the system and the greater the complexity, the greater the ROI in test automation. Also, the investment in tools and expertise can be amortized over multiple projects with the right level of knowledge sharing within an organization. Is the existence of the ISO 29119 software testing standard justified? Significant opposition has formed out of the ranks of the context-driven school of software testing about the ISO 29119 standard. Professional testing associations, such as the International Society for Software Testing, have attempted to have the standard withdrawn. [ 85 ] [ 86 ] Some practitioners declare that the testing field is not ready for certification [ 87 ] No certification now offered actually requires the applicant to show their ability to test software. No certification is based on a widely accepted body of knowledge. Certification itself cannot measure an individual's productivity, their skill, or practical knowledge, and cannot guarantee their competence, or professionalism as a tester. [ 88 ] Studies used to show the relative expense of fixing defects There are opposing views on the applicability of studies used to show the relative expense of fixing defects depending on their introduction and detection. For example: It is commonly believed that the earlier a defect is found, the cheaper it is to fix it. The following table shows the cost of fixing the defect depending on the stage it was found. [ 89 ] For example, if a problem in the requirements is found only post-release, then it would cost 10\u2013100 times more to fix than if it had already been found by the requirements review. With the advent of modern continuous deployment practices and cloud-based services, the cost of re-deployment and maintenance may lessen over time. Cost to fix a defect Time detected Requirements Architecture Construction System test Post-release Time introduced Requirements 1\u00d7 3\u00d7 5\u201310\u00d7 10\u00d7 10\u2013100\u00d7 Architecture \u2013 1\u00d7 10\u00d7 15\u00d7 25\u2013100\u00d7 Construction \u2013 \u2013 1\u00d7 10\u00d7 10\u201325\u00d7 The data from which this table is extrapolated is scant. Laurent Bossavit says in his analysis: The \"smaller projects\" curve turns out to be from only two teams of first-year students, a sample size so small that extrapolating to \"smaller projects in general\" is totally indefensible. The GTE study does not explain its data, other than to say it came from two projects, one large and one small. The paper cited for the Bell Labs \"Safeguard\" project specifically disclaims having collected the fine-grained data that Boehm's data points suggest. The IBM study (Fagan's paper) contains claims that seem to contradict Boehm's graph and no numerical results that clearly correspond to his data points. Boehm doesn't even cite a paper for the TRW data, except when writing for \"Making Software\" in 2010, and there he cited the original 1976 article. There exists a large study conducted at TRW at the right time for Boehm to cite it, but that paper doesn't contain the sort of data that would support Boehm's claims. [ 90 ] See also [ edit ] Data validation \u2013 Process of ensuring computer data is both correct and useful Cross-browser testing \u2013 Checking web applications in various browsers Database testing \u2013 testing of databases Domain testing Dynamic program analysis \u2013 Analysis of software performed when running a program Formal verification \u2013 Proving or disproving the correctness of certain intended algorithms Graphical user interface testing Independent test organization \u2013 Organization that tests according to agreed requirements Manual testing \u2013 Testing software without automation Orthogonal array testing Pair testing \u2013 Software testing technique Reverse semantic traceability \u2013 Quality control technique Software testing tactics Test management tool \u2013 Stores test steps, test planning and reporting Trace table \u2013 Software testing technique Web testing \u2013 Software testing that focuses on web applications SDET \u2013 Software Development Engineer in Test References [ edit ] ^ Kaner, Cem (November 17, 2006). Exploratory Testing (PDF) . Quality Assurance Institute Worldwide Annual Software Testing Conference. Orlando, FL . Retrieved November 22, 2014 . ^ a b Pan, Jiantao (Spring 1999). \"Software Testing\" (coursework). Carnegie Mellon University . Retrieved November 21, 2017 . ^ a b c d Kaner, Cem ; Falk, Jack; Nguyen, Hung Quoc (1999). Testing Computer Software (2nd\u00a0ed.). New York: John Wiley and Sons. ISBN 978-0-471-35846-6 . ^ Leitner, Andreas; Ciupa, Ilinca; Oriol, Manuel; Meyer, Bertrand ; Fiva, Arno (September 2007). Contract Driven Development = Test Driven Development \u2013 Writing Test Cases (PDF) . ESEC/FSE'07: European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering 2007. Dubrovnik, Croatia . Retrieved December 8, 2017 . ^ a b Kolawa, Adam; Huizinga, Dorota (2007). Automated Defect Prevention: Best Practices in Software Management . Wiley-IEEE Computer Society Press. ISBN 978-0-470-04212-0 . ^ Cohn, Mike (2009). Succeeding with Agile: Software Development Using Scrum . Addison-Wesley Professional. ISBN 978-0321579362 . ^ Molina, Alessandro (2021). Crafting Test-Driven Software with Python: Write test suites that scale with your applications' needs and complexity using Python and PyTest . Packt Publishing. ISBN 978-1838642655 . ^ Fernandes da Costa, Lucas (2021). Testing JavaScript Applications . Manning. ISBN 978-1617297915 . ^ \"The Economic Impacts of Inadequate Infrastructure for Software Testing\" (PDF) . National Institute of Standards and Technology . May 2002 . Retrieved December 19, 2017 . ^ Vashistha, Avinash; Khan, Imrana (October 2009). \"Top 50 Emerging Global Outsourcing Cities: A Global Services-Tholons Study\" . Retrieved October 25, 2025 . ^ a b c Myers, Glenford J. (1979). The Art of Software Testing . John Wiley and Sons. ISBN 978-0-471-04328-7 . ^ a b c IEEE Standard Glossary of Software Engineering Terminology , IEEE, 1990, doi : 10.1109/IEEESTD.1990.101064 , ISBN 978-1-55937-067-7 ^ \"Certified Tester Foundation Level Syllabus\" . International Software Testing Qualifications Board . March 31, 2011. Section 1.1.2. Archived from the original (pdf) on October 28, 2017 . Retrieved December 15, 2017 . ^ \"Certified Tester Foundation Level Syllabus\" . International Software Testing Qualifications Board . March 31, 2011. Section 1.1.2. Archived from the original (pdf) on October 28, 2017 . Retrieved December 15, 2017 . ^ \"Certified Tester Foundation Level Syllabus\" (PDF) . International Software Testing Qualifications Board . July 1, 2005. Principle 2, Section 1.3. Archived from the original (PDF) on December 17, 2008 . Retrieved December 15, 2017 . ^ Ramler, Rudolf; Kopetzky, Theodorich; Platz, Wolfgang (April 17, 2012). Combinatorial Test Design in the TOSCA Testsuite: Lessons Learned and Practical Implications . IEEE Fifth International Conference on Software Testing and Validation (ICST). Montreal, QC, Canada. doi : 10.1109/ICST.2012.142 . ^ Kaner, Cem; Bach, James; Pettichord, Bret (2001). Lessons Learned in Software Testing: A Context-Driven Approach . Wiley. pp. 31 \u201343. ISBN 978-0-471-08112-8 . ^ Kolawa, Adam; Huizinga, Dorota (2007). Automated Defect Prevention: Best Practices in Software Management . Wiley-IEEE Computer Society Press. p.\u00a074. ISBN 978-0-470-04212-0 . ^ O\u2019Connor, Rory V.; Akkaya, Mariye Umay; Kemaneci, Kerem; Yilmaz, Murat; Poth, Alexander; Messnarz, Richard (October 15, 2015). Systems, Software and Services Process Improvement: 22nd European Conference, EuroSPI 2015, Ankara, Turkey, September 30 -- October 2, 2015. Proceedings . Springer. ISBN 978-3-319-24647-5 . ^ Bourque, Pierre; Fairley, Richard E., eds. (2014). \"Chapter 5\" . Guide to the Software Engineering Body of Knowledge . 3.0. IEEE Computer Society. ISBN 978-0-7695-5166-1 . Retrieved January 2, 2018 . ^ Bourque, P.; Fairley, R.D., eds. (2014). \"Chapter 4: Software Testing\" (PDF) . SWEBOK v3.0: Guide to the Software Engineering Body of Knowledge . IEEE. pp.\u00a04\u20131\u20134\u201317. ISBN 978-0-7695-5166-1 . Archived from the original (PDF) on June 19, 2018 . Retrieved July 13, 2018 . ^ Dooley, J. (2011). Software Development and Professional Practice . APress. pp. 193\u2013 4. ISBN 978-1-4302-3801-0 . ^ Wiegers, K. (2013). Creating a Software Engineering Culture . Addison-Wesley. pp. 211\u2013 2. ISBN 978-0-13-348929-3 . ^ Kolawa, Adam; Huizinga, Dorota (2007). Automated Defect Prevention: Best Practices in Software Management . Wiley-IEEE Computer Society Press. p.\u00a075. ISBN 978-0-470-04212-0 . ^ a b Graham, D.; Van Veenendaal, E.; Evans, I. (2008). Foundations of Software Testing . Cengage Learning. pp. 57\u2013 58. ISBN 978-1-84480-989-9 . ^ a b c d Oberkampf, W.L.; Roy, C.J. (2010). Verification and Validation in Scientific Computing . Cambridge University Press. pp. 154\u2013 5. ISBN 978-1-139-49176-1 . ^ Lee, D.; Netravali, A.N.; Sabnani, K.K.; Sugla, B.; John, A. (1997). \"Passive testing and applications to network management\". Proceedings 1997 International Conference on Network Protocols . IEEE Comput. Soc. pp. 113\u2013 122. doi : 10.1109/icnp.1997.643699 . ISBN 978-0-8186-8061-8 . S2CID 42596126 . ^ Cem Kaner,  \" A Tutorial in Exploratory Testing Archived 2013-06-12 at the Wayback Machine \", p.2 ^ Cem Kaner, A Tutorial in Exploratory Testing Archived 2013-06-12 at the Wayback Machine , p. 36. ^ Lee, D.; Yannakakis, M. (1996). \"Principles and methods of testing finite state machines-a survey\" . Proceedings of the IEEE . 84 (8): 1090\u2013 1123. doi : 10.1109/5.533956 . ^ Petrenko, A.; Yevtushenko, N. (2011). \"Adaptive testing of deterministic implementations specified by nondeterministic FSMs\" . In Testing Software and Systems: 23rd IFIP WG 6.1 International Conference, ICTSS 2011, Paris, France, November 7-10 . Lecture Notes in Computer Science. Vol.\u00a07019. Springer Berlin Heidelberg. pp. 162\u2013 178. doi : 10.1007/978-3-642-24580-0_12 . ISBN 978-3-642-24579-4 . ^ Petrenko, A.; Yevtushenko, N. (2014). \"Adaptive testing of nondeterministic systems with FSM\". In 2014 IEEE 15th International Symposium on High-Assurance Systems Engineering . IEEE. pp. 224\u2013 228. doi : 10.1109/HASE.2014.39 . ISBN 978-1-4799-3466-9 . ^ a b c d Limaye, M.G. (2009). Software Testing . Tata McGraw-Hill Education. pp. 108\u2013 11. ISBN 978-0-07-013990-9 . ^ a b c d Saleh, K.A. (2009). Software Engineering . J. Ross Publishing. pp. 224\u2013 41. ISBN 978-1-932159-94-3 . ^ a b c Ammann, P.; Offutt, J. (2016). Introduction to Software Testing . Cambridge University Press. p.\u00a026. ISBN 978-1-316-77312-3 . ^ Everatt, G.D.; McLeod Jr., R. (2007). \"Chapter 7: Functional Testing\". Software Testing: Testing Across the Entire Software Development Life Cycle . John Wiley & Sons. pp. 99\u2013 121. ISBN 978-0-470-14634-7 . ^ a b Cornett, Steve (c. 1996). \"Code Coverage Analysis\" . Bullseye Testing Technology. Introduction . Retrieved November 21, 2017 . ^ a b Black, R. (2011). Pragmatic Software Testing: Becoming an Effective and Efficient Test Professional . John Wiley & Sons. pp. 44\u2013 6. ISBN 978-1-118-07938-6 . ^ As a simple example, the C function int f ( int x ){ return x * x -6 * x + 8 ;} consists of only one statement. All tests against a specification f ( x ) >= 0 will succeed, except if x = 3 happens to be chosen. ^ Patton, Ron (2005). Software Testing (2nd\u00a0ed.). Indianapolis: Sams Publishing. ISBN 978-0-672-32798-8 . ^ Laycock, Gilbert T. (1993). The Theory and Practice of Specification Based Software Testing (PDF) (dissertation thesis). Department of Computer Science, University of Sheffield . Retrieved January 2, 2018 . ^ Bach, James (June 1999). \"Risk and Requirements-Based Testing\" (PDF) . Computer . 32 (6): 113\u2013 114 . Retrieved August 19, 2008 . ^ Mathur, A.P. (2011). Foundations of Software Testing . Pearson Education India. p.\u00a063. ISBN 978-81-317-5908-0 . ^ a b Clapp, Judith A. (1995). Software Quality Control, Error Analysis, and Testing . William Andrew. p.\u00a0313. ISBN 978-0-8155-1363-6 . Retrieved January 5, 2018 . ^ Mathur, Aditya P. (2007). Foundations of Software Testing . Pearson Education India. p.\u00a018. ISBN 978-81-317-1660-1 . ^ L\u00f6nnberg, Jan (October 7, 2003). Visual testing of software (PDF) (MSc thesis). Helsinki University of Technology . Retrieved January 13, 2012 . ^ Chima, Raspal. \"Visual testing\" . TEST Magazine . Archived from the original on July 24, 2012 . Retrieved January 13, 2012 . ^ a b c Lewis, W.E. (2016). Software Testing and Continuous Quality Improvement (3rd\u00a0ed.). CRC Press. pp. 68\u2013 73. ISBN 978-1-4398-3436-7 . ^ a b Ransome, J.; Misra, A. (2013). Core Software Security: Security at the Source . CRC Press. pp. 140\u2013 3. ISBN 978-1-4665-6095-6 . ^ \"SOA Testing Tools for Black, White and Gray Box\" (white paper). Crosscheck Networks. Archived from the original on October 1, 2018 . Retrieved December 10, 2012 . ^ a b Myers, G. (2004). Sandler, C; Badgett, T; Thomas, M. (eds.). The Art of Software Testing (2\u00a0ed.). Wiley. ISBN 9780471469124 . ^ Ammann, Paul; Offutt, Jeff (January 28, 2008). Introduction to Software Testing . Cambridge University Press . p.\u00a0215. ISBN 978-0-521-88038-1 . Retrieved November 29, 2017 . ^ a b c Lewis, W.E. (2016). Software Testing and Continuous Quality Improvement (3rd\u00a0ed.). CRC Press. pp. 92\u2013 6. ISBN 978-1-4398-3436-7 . ^ Machado, P.; Vincenzi, A.; Maldonado, J.C. (2010). \"Chapter 1: Software Testing: An Overview\" . In Borba, P.; Cavalcanti, A.; Sampaio, A.; Woodcook, J. (eds.). Testing Techniques in Software Engineering . Springer Science & Business Media. pp. 13\u2013 14. ISBN 978-3-642-14334-2 . ^ Clapp, J.A.; Stanten, S.F.; Peng, W.W.; et\u00a0al. (1995). Software Quality Control, Error Analysis, and Testing . Nova Data Corporation. p.\u00a0254. ISBN 978-0-8155-1363-6 . ^ a b c \"ISTQB CTFL Syllabus 2018\" (PDF) . ISTQB - International Software Testing Qualifications Board . Archived (PDF) from the original on March 24, 2022 . Retrieved April 11, 2022 . ^ Woods, Anthony J. (June 5, 2015). \"Operational Acceptance \u2013 an application of the ISO 29119 Software Testing standard\" (Whitepaper). Capgemini Australia . Retrieved January 9, 2018 . ^ \"Standard Glossary of Terms used in Software Testing\" (PDF) . Version 3.1. International Software Testing Qualifications Board . Retrieved January 9, 2018 . ^ O'Reilly, Tim (September 30, 2005). \"What is Web 2.0\" . O'Reilly Media. Section 4. End of the Software Release Cycle . Retrieved January 11, 2018 . ^ Auerbach, Adam (August 3, 2015). \"Part of the Pipeline: Why Continuous Testing Is Essential\" . TechWell Insights . TechWell Corp . Retrieved January 12, 2018 . ^ Philipp-Edmonds, Cameron (December 5, 2014). \"The Relationship between Risk and Continuous Testing: An Interview with Wayne Ariola\" . Stickyminds . Retrieved January 16, 2018 . ^ Ariola, Wayne; Dunlop, Cynthia (October 2015). DevOps: Are You Pushing Bugs to Clients Faster? (PDF) . Pacific Northwest Software Quality Conference . Retrieved January 16, 2018 . ^ Auerbach, Adam (October 2, 2014). \"Shift Left and Put Quality First\" . TechWell Insights . TechWell Corp . Retrieved January 16, 2018 . ^ Taqi, Farwa; Batool, Syeda Hina; Arshad, Alia (May 23, 2024). \"Development and Validation of Cloud Applications Usability Development Scale\" . International Journal of Human\u2013Computer Interaction : 1\u2013 16. doi : 10.1080/10447318.2024.2351715 . ISSN 1044-7318 . ^ \"Section 4.38\". ISO/IEC/IEEE 29119-1:2013 \u2013 Software and Systems Engineering \u2013 Software Testing \u2013 Part 1 \u2013 Concepts and Definitions . International Organization for Standardization . Retrieved January 17, 2018 . ^ \"Globalization Step-by-Step: The World-Ready Approach to Testing. Microsoft Developer Network\" . Microsoft Developer Network. Archived from the original on June 23, 2012 . Retrieved January 13, 2012 . ^ Claessen, Koen; Hughes, John (2000). \"QuickCheck\" . Proceedings of the fifth ACM SIGPLAN international conference on Functional programming . Icfp '00. pp. 268\u2013 279. doi : 10.1145/351240.351266 . ISBN 978-1-58113-202-1 . S2CID 5668071 . ^ \"What is Contract Testing and its Significance?\" . BrowserStack . Retrieved November 15, 2025 . ^ Fowler, Martin. \"bliki: Contract Test\" . martinfowler.com . Retrieved November 15, 2025 . ^ Gelperin, David ; Hetzel, Bill (June 1, 1988). \"The growth of software testing\" . Communications of the ACM . 31 (6): 687\u2013 695. doi : 10.1145/62959.62965 . S2CID 14731341 . ^ Gregory, Janet; Crispin, Lisa (2014). More Agile Testing . Addison-Wesley Professional. pp. 23\u2013 39. ISBN 978-0-13-374956-4 . ^ \"Software Testing Lifecycle\" . etestinghub . Testing Phase in Software Testing . Retrieved January 13, 2012 . ^ Dustin, Elfriede (2002). Effective Software Testing . Addison-Wesley Professional. p.\u00a03. ISBN 978-0-201-79429-8 . ^ a b \"What is Test Driven Development (TDD)?\" . Agile Alliance . December 5, 2015 . Retrieved March 17, 2018 . ^ \"Test-Driven Development and Continuous Integration for Mobile Applications\" . Microsoft Developer Network . January 14, 2009 . Retrieved March 17, 2018 . ^ Brown, Chris; Cobb, Gary; Culbertson, Robert (April 12, 2002). Introduction to Rapid Software Testing . ^ Tran, Eushiuan (1999). \"Verification/Validation/Certification\" (coursework). Carnegie Mellon University . Retrieved August 13, 2008 . ^ a b Gotel, Orlena; Cleland-Huang, Jane ; Hayes, Jane Huffman; Zisman, Andrea; Egyed, Alexander; Gr\u00fcnbacher, Paul; Dekhtyar, Alex; Antoniol, Giuliano; Maletic, Jonathan (January 1, 2012). Cleland-Huang, Jane; Gotel, Orlena; Zisman, Andrea (eds.). Software and Systems Traceability . Springer London. doi : 10.1007/978-1-4471-2239-5_1 . ISBN 9781447122388 . ^ IEEE (1998). IEEE standard for software test documentation . New York: IEEE. ISBN 978-0-7381-1443-9 . ^ Pinto, Leandro Sales; Sinha, Saurabh; Orso, Alessandro (November 11, 2012). \"Understanding myths and realities of test-suite evolution\" . Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering . Association for Computing Machinery. pp. 1\u2013 11. doi : 10.1145/2393596.2393634 . ISBN 9781450316149 . S2CID 9072512 . ^ Strom, David (July 1, 2009). \"We're All Part of the Story\" . Software Test & Performance Collaborative. Archived from the original on August 31, 2009. ^ Griffiths, M. (2005). \"Teaching agile project management to the PMI\". Agile Development Conference (ADC'05) . ieee.org. pp. 318\u2013 322. doi : 10.1109/ADC.2005.45 . ISBN 978-0-7695-2487-0 . S2CID 30322339 . ^ Willison, John S. (April 2004). \"Agile Software Development for an Agile Force\" . CrossTalk (April 2004). STSC. Archived from the original on October 29, 2005. ^ An example is Mark Fewster, Dorothy Graham: Software Test Automation. Addison Wesley, 1999, ISBN 978-0-201-33140-0 . ^ \"stop29119\" . commonsensetesting.org . Archived from the original on October 2, 2014. ^ Paul Krill (August 22, 2014). \"Software testers balk at ISO 29119 standards proposal\" . InfoWorld . ^ Kaner, Cem (2001). \"NSF grant proposal to 'lay a foundation for significant improvements in the quality of academic and commercial courses in software testing' \" (PDF) . Archived from the original (PDF) on November 27, 2009 . Retrieved October 13, 2006 . ^ Kaner, Cem (2003). Measuring the Effectiveness of Software Testers (PDF) . STAR East. Archived from the original (PDF) on March 26, 2010 . Retrieved January 18, 2018 . ^ McConnell, Steve (2004). Code Complete (2nd\u00a0ed.). Microsoft Press. p. 29 . ISBN 978-0-7356-1967-8 . ^ Bossavit, Laurent (November 20, 2013). \"The cost of defects: an illustrated history\". The Leprechauns of Software Engineering: How folklore turns into fact and what to do about it . leanpub. Further reading [ edit ] Meyer, Bertrand (August 2008). \"Seven Principles of Software Testing\" (PDF) . Computer . Vol.\u00a041, no.\u00a08. pp. 99\u2013 101. doi : 10.1109/MC.2008.306 . Retrieved November 21, 2017 . External links [ edit ] Wikimedia Commons has media related to Software testing . At Wikiversity , you can learn more and teach others about Software testing at the Department of Software testing \"Software that makes Software better\" Economist.com Software Testing With Large Language Models: Survey, Landscape, and Vision v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control flow Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Computational problem Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human-centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human\u2013computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Specialized Platform\nDevelopment Thermodynamic computing Category Outline Glossaries v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons v t e Software testing Test levels Acceptance testing System integration testing System testing Integration testing Unit testing Test types, techniques, tactics A/B testing Benchmark Compatibility testing Concolic testing Concurrent testing Conformance testing Continuous testing Destructive testing Development testing Differential testing Dynamic program analysis Installation testing Negative testing Random testing Regression testing Security testing Smoke testing (software) Software performance testing Stress testing Symbolic execution Test automation Usability testing [x]-box style Black-box testing All-pairs testing Exploratory testing Fuzz testing Model-based testing Scenario testing Grey-box testing White-box testing API testing Mutation testing Static testing See also Graphical user interface testing Manual testing Orthogonal array testing Pair testing Soak testing Software reliability testing Stress testing Web testing Authority control databases : National Czech Republic Latvia Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_testing&oldid=1328117219 \" Categories : Software testing Software engineering terminology Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata Use mdy dates from December 2021 All accuracy disputes Articles with disputed statements from September 2014 Articles with excerpts All articles with unsourced statements Articles with unsourced statements from January 2008 Articles with unsourced statements from July 2012 Articles with unsourced statements from February 2011 Commons category link from Wikidata This page was last edited on 17 December 2025, at 23:56 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software testing 49 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_design",
    "title": "Software design - Wikipedia",
    "content": "Software design - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Part of the overall process 2 Code as design 3 Artifacts 4 Iterative Design 5 Design principles 6 Design concepts 7 Design considerations 8 Modeling language 9 See also 10 References Toggle the table of contents Software design 32 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Az\u0259rbaycanca \u09ac\u09be\u0982\u09b2\u09be Dansk Deutsch Eesti Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Bahasa Indonesia \u00cdslenska Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Jawa Magyar \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 Bahasa Melayu \u65e5\u672c\u8a9e Norsk bokm\u00e5l Portugu\u00eas Qaraqalpaqsha Rom\u00e2n\u0103 \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0421\u0440\u043f\u0441\u043a\u0438 / srpski T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e Zazaki \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Process of planning software solutions Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Software design is the process of conceptualizing how a software system will work before it is implemented or modified. [ 1 ] Software design also refers to the direct result of the design process \u2013 the concepts of how the software will work which may be formally documented or may be maintained less formally, including via oral tradition . The design process enables a designer to model aspects of a software system before it exists with the intent of making the effort of writing the code more efficiently. Creativity, past experience, a sense of what makes \"good\" software, and a commitment to quality are success factors for a competent design. A software design can be compared to an architected plan for a house . High-level plans represent the totality of the house (e.g., a three-dimensional rendering of the house). Lower-level plans provide guidance for constructing each detail (e.g., the plumbing lay). Similarly, the software design model provides a variety of views of the proposed software solution. Part of the overall process [ edit ] In terms of the waterfall development process , software design is the activity that occurs after requirements analysis and before coding . [ 2 ] Requirements analysis determines what the system needs to do without determining how it will do it, and thus, multiple designs can be imagined that satisfy the requirements. The design can be created while coding, without a plan or requirements analysis, [ 3 ] but for more complex projects this is less feasible. Completing a design prior to coding allows for multidisciplinary designers and subject-matter experts to collaborate with programmers to produce software that is useful and technically sound. Sometimes, a simulation or prototype is created to model the system in an effort to determine a valid and good design. Code as design [ edit ] A common point of confusion with the term design in software is that the process applies at multiple levels of abstraction such as a high-level software architecture and lower-level components, functions and algorithms . A relatively formal process may occur at high levels of abstraction but at lower levels, the design process is almost always less formal where the only artifact of design may be the code itself. To the extent that this is true, software design refers to the design of the design. Edsger W. Dijkstra referred to this layering of semantic levels as the \"radical novelty\" of computer programming, [ 4 ] and Donald Knuth used his experience writing TeX to describe the futility of attempting to design a program prior to implementing it: T E X would have been a complete failure if I had merely specified it and not participated fully in its initial implementation. The process of implementation constantly led me to unanticipated questions and to new insights about how the original specifications could be improved. [ 5 ] Artifacts [ edit ] A design process may include the production of art Software design documentation such as flow chart , use case , Pseudocode , Unified Modeling Language model and other Fundamental modeling concepts . For user centered software, design may involve user experience design yielding a storyboard to help determine those specifications. Documentation may be reviewed to allow constraints, specifications and even requirements to be adjusted prior to coding. Iterative Design [ edit ] Software systems inherently deal with uncertainties, and the size of software components can significantly influence a system's outcomes, both positively and negatively. Neal Ford and Mark Richards propose an iterative approach to address the challenge of identifying and right-sizing components. This method emphasizes continuous refinement as teams develop a more nuanced understanding of system behavior and requirements. [ 6 ] The approach typically involves a cycle with several stages: [ 6 ] A high-level partitioning strategy is established, often categorized as technical or domain-based. Guidelines for the smallest meaningful deployable unit, referred to as \"quanta,\" are defined. While these foundational decisions are made early, they may be revisited later in the cycle if necessary. Initial components are identified based on the established strategy. Requirements are assigned to the identified components. The roles and responsibilities of each component are analyzed to ensure clarity and minimize overlap. Architectural characteristics, such as scalability, fault tolerance, and maintainability, are evaluated. Components may be restructured based on feedback from development teams. This cycle serves as a general framework and can be adapted to different domains. Design principles [ edit ] Design principles enable a software engineer to navigate the design process. Davis [ 7 ] suggested principles which have been refined over time as: The design process should not suffer from \"tunnel vision\" A good designer should consider alternative approaches, judging each based on the requirements of the problem, the resources available to do the job. The design should be traceable to the analysis model Because a single element of the design model can often be traced back to multiple requirements, it is necessary to have a means for tracking how requirements have been satisfied by the design model. The design should not reinvent the wheel Systems are constructed using a set of design patterns, many of which have likely been encountered before. These patterns should always be chosen as an alternative to reinvention. Time is short and resources are limited; design time should be invested in representing (truly new) ideas by integrating patterns that already exist (when applicable). The design should \"minimize the intellectual distance\" between the software and the problem as it exists in the real world That is, the structure of the software design should, whenever possible, mimic the structure of the problem domain. The design should exhibit uniformity and integration A design is uniform if it appears fully coherent. In order to achieve this outcome, rules of style and format should be defined for a design team before design work begins. A design is integrated if care is taken in defining interfaces between design components. The design should be structured to accommodate change The design concepts discussed in the next section enable a design to achieve this principle. The design should be structured to degrade gently, even when aberrant data, events, or operating conditions are encountered Well-designed software should never \"bomb\"; it should be designed to accommodate unusual circumstances, and if it must terminate processing, it should do so in a graceful manner. Design is not coding, coding is not design Even when detailed procedural designs are created for program components, the level of abstraction of the design model is higher than the source code. The only design decisions made at the coding level should address the small implementation details that enable the procedural design to be coded. The design should be assessed for quality as it is being created, not after the fact A variety of design concepts and design measures are available to assist the designer in assessing quality throughout the development process. The design should be reviewed to minimize conceptual (semantic) errors There is sometimes a tendency to focus on minutiae when the design is reviewed, missing the forest for the trees. A design team should ensure that major conceptual elements of the design (omissions, ambiguity, inconsistency) have been addressed before worrying about the syntax of the design model. Design concepts [ edit ] Design concepts provide a designer with a foundation from which more sophisticated methods can be applied. Design concepts include: Abstraction Reducing the information content of a concept or an observable phenomenon, typically to retain only information that is relevant for a particular purpose. It is an act of Representing essential features without including the background details or explanations. Architecture The overall structure of the software and the ways in which that structure provides conceptual integrity for a system. Good software architecture will yield a good return on investment with respect to the desired outcome of the project, e.g. in terms of performance, quality, schedule and cost. Control hierarchy A program structure that represents the organization of a program component and implies a hierarchy of control. Data structure Representing the logical relationship between elements of data. Design pattern A designer may identify a design aspect of the system that has solved in the past. The reuse of such patterns can increase software development velocity. [ 8 ] Information hiding Modules should be specified and designed so that information contained within a module is inaccessible to other modules that have no need for such information. Modularity Dividing the solution into parts (modules). Refinement The process of elaboration. A hierarchy is developed by decomposing a macroscopic statement of function in a step-wise fashion until programming language statements are reached. In each step, one or several instructions of a given program are decomposed into more detailed instructions. Abstraction and Refinement are complementary concepts. Software procedure Focuses on the processing of each module individually. Structural partitioning The program structure can be divided horizontally and vertically. Horizontal partitions define separate branches of modular hierarchy for each major program function. Vertical partitioning suggests that control and work should be distributed top-down in the program structure. Grady Booch mentions abstraction , encapsulation , modularization , and hierarchy as fundamental software design principles. [ 9 ] The phrase principles of hierarchy, abstraction, modularization, and encapsulation (PHAME) refers to these principles. [ 10 ] Design considerations [ edit ] There are many aspects to consider in the design of software. The importance of each should reflect the goals and expectations to which the software is being created. Notable aspects include: Compatibility The software is able to operate with other products that are designed for interoperability with another product.  For example, a piece of software may be backward-compatible with an older version of itself. Extensibility New capabilities can be added to the software without major changes to the underlying architecture. Fault-tolerance The software is resistant to and able to recover from component failure. Maintainability A measure of how easily bug fixes or functional modifications can be accomplished. High maintainability can be the product of modularity and extensibility. Modularity The resulting software comprises well defined, independent components which leads to better maintainability. The components could be then implemented and tested in isolation before being integrated to form a desired software system. This allows division of work in a software development project. Overhead How the consumption of resources required for overhead impacts the resources needed to achieve system requirements. Performance The software performs its tasks within a time-frame that is acceptable for the user, and does not require too much memory. Portability The software should be usable across a number of different conditions and environments. Reliability The software is able to perform a required function under stated conditions for a specified period of time. Reusability The ability to use some or all of the aspects of the preexisting software in other projects with little to no modification. Robustness The software is able to operate under stress or tolerate unpredictable or invalid input.  For example, it can be designed with resilience to low memory conditions. Scalability The software adapts well to increasing data or added features or number of users. According to Marc Brooker: \"a system is scalable in the range where marginal cost of additional workload is nearly constant.\" Serverless technologies fit this definition but you need to consider total cost of ownership not just the infra cost. [ 11 ] Security The software is able to withstand and resist hostile acts and influences. Usability The software user interface must be usable for its target user/audience. Default values for the parameters must be chosen so that they are a good choice for the majority of the users. [ 12 ] Modeling language [ edit ] A modeling language can be used to express information, knowledge or systems in a structure that is defined by a consistent set of rules. These rules are used for interpretation of the components within the structure. A modeling language can be graphical or textual. Examples of graphical modeling languages for software design include: Architecture description language (ADL) A language used to describe and represent the software architecture of a software system . Business Process Modeling Notation (BPMN) An example of a Process Modeling language. EXPRESS and EXPRESS-G (ISO 10303-11) An international standard general-purpose data modeling language. Extended Enterprise Modeling Language (EEML) Commonly used for business process modeling across a number of layers. Flowchart Schematic representations of algorithms or other step-wise processes. Fundamental Modeling Concepts (FMC) A modeling language for software-intensive systems. IDEF A family of modeling languages, the most notable of which include IDEF0 for functional modeling, IDEF1X for information modeling, and IDEF5 for modeling ontologies . Jackson Structured Programming (JSP) A method for structured programming based on correspondences between data stream structure and program structure. LePUS3 An object-oriented visual Design Description Language and a formal specification language that is suitable primarily for modeling large object-oriented ( Java , C++ , C# ) programs and design patterns . Unified Modeling Language (UML) A general modeling language to describe software both structurally and behaviorally.  It has a graphical notation and allows for extension with a Profile (UML) . Alloy (specification language) A general purpose specification language for expressing complex structural constraints and behavior in a software system. It provides a concise language base on first-order relational logic. Systems Modeling Language (SysML) A general-purpose modeling language for systems engineering. Service-oriented modeling framework (SOMF) [ 13 ] See also [ edit ] Wikimedia Commons has media related to Software design . Aspect-oriented software development \u2013 Programming paradigm Pages displaying short descriptions of redirect targets Design rationale \u2013 Explicit listing of design decisions Graphic design \u2013 Interdisciplinary branch of design and fine arts Interaction design \u2013 Specialization of design focused on the experience users have of a product or service Icon design \u2013 Genre of graphic design Outline of software \u2013 Topical guide to software Outline of software development \u2013 Overview of and topical guide to software development Outline of software engineering \u2013 Overview of and topical guide to software engineering Search-based software engineering \u2013 Application of metaheuristic search techniques to software engineering Software Design Description \u2013 Written design description of a software product Pages displaying short descriptions of redirect targets Software development \u2013 Creation and maintenance of software User experience \u2013 Human interaction with a particular product, system or service User interface design \u2013 Planned operator\u2013machine interaction Web design \u2013 Creation and maintenance of websites Zero One Infinity \u2013 Software design rule Pages displaying short descriptions of redirect targets References [ edit ] ^ Ralph, P. and Wand, Y. (2009). A proposal for a formal definition of the design concept. In Lyytinen, K., Loucopoulos, P., Mylopoulos, J. , and Robinson, W., editors, Design Requirements Workshop (LNBIP 14), pp. 103\u2013136. Springer-Verlag, p. 109 doi : 10.1007/978-3-540-92966-6_6 . ^ Freeman, Peter; David Hart (2004). \"A Science of design for software-intensive systems\". Communications of the ACM . 47 (8): 19\u201321 [20]. doi : 10.1145/1012037.1012054 . S2CID 14331332 . ^ Ralph, P., and Wand, Y. A Proposal for a Formal Definition of the Design Concept. In, Lyytinen, K., Loucopoulos, P., Mylopoulos, J., and Robinson, W., (eds.), Design Requirements Engineering: A Ten-Year Perspective: Springer-Verlag, 2009, pp. 103-136 ^ Dijkstra, E. W. (1988). \"On the cruelty of really teaching computing science\" . Retrieved 2014-01-10 . ^ Knuth, Donald E. (1989). \"Notes on the Errors of TeX\" (PDF) . ^ a b Fundamentals of Software Architecture: An Engineering Approach . O'Reilly Media. 2020. ISBN 978-1492043454 . ^ Davis, A:\"201 Principles of Software Development\", McGraw Hill, 1995. ^ Judith Bishop. \"C# 3.0 Design Patterns: Use the Power of C# 3.0 to Solve Real-World Problems\" . C# Books from O'Reilly Media . Retrieved 2012-05-15 . If you want to speed up the development of your .NET applications, you're ready for C# design patterns -- elegant, accepted and proven ways to tackle common programming problems. ^ Booch, Grady; et\u00a0al. (2004). Object-Oriented Analysis and Design with Applications (3rd\u00a0ed.). MA, US: Addison Wesley. ISBN 0-201-89551-X . Retrieved 30 January 2015 . ^ Suryanarayana, Girish (November 2014). Refactoring for Software Design Smells . Morgan Kaufmann. p.\u00a0258. ISBN 978-0128013977 . ^ Building Serverless Applications on Knative . O'Reilly Media. ISBN 9781098142049 . ^ Carroll, John, ed. (1995). Scenario-Based Design: Envisioning Work and Technology in System Development . New York: John Wiley & Sons. ISBN 0471076597 . ^ Bell, Michael (2008). \"Introduction to Service-Oriented Modeling\". Service-Oriented Modeling: Service Analysis, Design, and Architecture . Wiley & Sons. ISBN 978-0-470-14111-3 . ^ Roger S. Pressman (2001). Software engineering: a practitioner's approach . McGraw-Hill. ISBN 0-07-365578-3 . v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control flow Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Computational problem Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human-centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human\u2013computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Specialized Platform\nDevelopment Thermodynamic computing Category Outline Glossaries v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons v t e Design Outline Designer Disciplines Communication design Advertising Book design Brand design Exhibit design Film title design Graphic design Motion Postage stamp design Print design Illustration Information design Instructional design News design Photography Retail design Signage / Traffic sign design Typography / Type design Video design Visual merchandising Environmental design Architecture Architectural lighting design Building design Passive solar Ecological design Environmental impact design Garden design Computer-aided Healthy community design Hotel design Interior architecture Interior design EID Keyline design Landscape architecture Sustainable Landscape design Spatial design Urban design Industrial design Automotive design Automotive suspension design CMF design Corrugated box design Electric guitar design Furniture design Sustainable Hardware interface design Motorcycle design Packaging and labeling Photographic lens design Product design Production design Sensory design Service design Interaction design Experience design EED Game design Level design Video game design Hardware interface design Icon design Immersive design Information design Interactive design Sonic interaction design User experience design User interface design Web design Other applied arts Public art design Ceramic / glass design Fashion design Costume design Jewellery design Floral design Game art design Property design Scenic design Sound design Stage/set lighting design Textile design Other design & engineering Algorithm design Behavioural design Boiler design Database design Drug design Electrical system design Experimental design Filter design Geometric design Work design Integrated circuit design Circuit design Physical design Power network design Mechanism design Nuclear weapon design Nucleic acid design Organization design Process design Processor design Protein design Research design Social design Software design Spacecraft design Strategic design Systems design Test design Approaches Active Activity-centered Adaptive web Affective Brainstorming By committee By contract C-K theory Closure Configuration Contextual Continuous Cradle-to-cradle Creative problem-solving Creativity techniques Critical Design fiction Defensive Design\u2013bid\u2013build Design\u2013build architect-led Diffuse Domain-driven Ecological design Energy neutral Engineering design process Probabilistic design Ergonomic Error-tolerant Evidence-based Fault-tolerant Feminist For assembly For behaviour change For manufacturability For Six Sigma For testing For the environment For X Framework-oriented Functional Generative Geodesign HCD High-level Hostile Inclusive Integrated Integrated topside Intelligence-based Iterative KISS principle Low-level Metadesign Mind mapping Modular New Wave Object-oriented Open Over Parametric Participatory Platform-based Policy-based Prevention through Process-centered Public interest Opinion poll Public opinion Rational Regenerative Reliability engineering Research-based Responsibility-driven RWD Safe-life Speculative Sustainable Systemic SOD Tableless web Theory of constraints Top-down and bottom-up Transformation Transgenerational TRIZ Universal Design for All Usage-centered Use-centered User-centered Empathic User innovation Value-driven Value sensitive Privacy by Quality by Secure by Design choice computing controls culture flow justice leadership management marker methods pattern research science sprint strategy theory thinking Tools Intellectual property Organizations Awards Tools AAD Architectural model Blueprint Comprehensive layout CAD CAID Virtual home design software CAutoD Design quality indicator Electronic design automation Flowchart Mockup Design specification Design system Prototype Sketch Storyboard Technical drawing HTML editor Website wireframe Intellectual property Clean-room design Community design Design around Design infringement Design patent Fashion design copyright Geschmacksmuster Industrial design rights European Union Organizations American Institute of Graphic Arts Chartered Society of Designers Design and Industries Association Design Council International Forum Design Design Research Society Awards European Design Award German Design Award Good Design Award (Museum of Modern Art) Good Design Award (Chicago Athenaeum) Graphex IF Product Design Award James Dyson Award Prince Philip Designers Prize Related topics Agile Concept art Conceptual design Creative industries Cultural icon .design Dominant design Enterprise architecture Form factor Futures studies Indie design Innovation management Intelligent design Lean startup New product development OODA loop Philosophy of design Process simulation Reference design Slow design STEAM fields Unintelligent design Visualization Wicked problem Design attributes brief change classic competition architectural student director education elements engineer firm history knowledge language life load museum optimization paradigm principles rationale review specification studies studio technology Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_design&oldid=1328004217 \" Categories : Software engineering Software design Software architecture Computer occupations Hidden categories: Articles with short description Short description is different from Wikidata Commons category link is on Wikidata Pages displaying short descriptions of redirect targets via Module:Annotated link This page was last edited on 17 December 2025, at 09:58 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software design 32 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_construction",
    "title": "Software construction - Wikipedia",
    "content": "Software construction - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Activities Toggle Activities subsection 1.1 Coding 1.2 Integration 1.3 Testing 1.4 Reuse 1.5 Quality assurance 1.6 Re-design 2 Language 3 Best practices Toggle Best practices subsection 3.1 Minimize complexity 3.2 Anticipate change 3.3 Construct for verification 3.4 Information hiding 3.5 Reuse 3.6 Standards 3.7 Data abstraction 3.8 Defensive programming 3.9 Error handling 4 Coding aspects Toggle Coding aspects subsection 4.1 State-based logic 4.2 Table-driven logic 4.3 Runtime configuration 4.4 Internationalization 5 See also 6 Notes 7 References 8 External links Toggle the table of contents Software construction 10 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u0641\u0627\u0631\u0633\u06cc \ud55c\uad6d\uc5b4 \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 Norsk bokm\u00e5l O\u02bbzbekcha / \u045e\u0437\u0431\u0435\u043a\u0447\u0430 \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Creating working software Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Software construction is the process of creating working software via coding and integration . The process includes unit and integration testing although does not include higher level testing such as system testing . [ 1 ] Construction is an aspect of the software development lifecycle and is integrated in the various software development process models with varying focus on construction as an activity separate from other activities. In the waterfall model , a software development effort consists of sequential phases including requirements analysis , design , and planning which are prerequisites for starting construction. In an iterative model such as scrum , evolutionary prototyping , or extreme programming , construction as an activity that occurs concurrently or overlapping other activities. [ 1 ] Construction planning may include defining the order in which components are created and integrated, the software quality management processes, and the allocation of tasks to teams and developers. [ 1 ] To facilitate project management , numerous construction aspects can be measured; these include the amount of code developed, modified, reused, and destroyed, code complexity, code inspection statistics, faults-fixed and faults-found rates, and effort expended. These measurements can be useful for aspects such as ensuring quality and improving the process. [ 1 ] Activities [ edit ] Construction includes many activities. Coding [ edit ] The following are a few of the key aspects of the coding activity: [ 2 ] Naming Choice of name for each identifier. One study showed that the effort required to debug a program is minimized when variable names are between 10 and 16 characters. [ 3 ] Logic Organization into statements and routines [ 4 ] Highly cohesive routines proved to be less error prone than routines with lower cohesion.  A study of 450 routines found that 50 percent of the highly cohesive routines were fault free compared to only 18 percent of routines with low cohesion.  Another study of a different 450 routines found that routines with the highest coupling -to-cohesion ratios had 7 times as many errors as those with the lowest coupling-to-cohesion ratios and were 20 times as costly to fix. Although studies showed inconclusive results regarding the correlation between routine sizes and the rate of errors in them, but one study found that routines with fewer than 143 lines of code were 2.4 times less expensive to fix than larger routines. Another study showed that the code needed to be changed least when routines averaged 100 to 150 lines of code.  Another study found that structural complexity and amount of data in a routine were correlated with errors regardless of its size. Interfaces between routines are some of the most error-prone areas of a program.  One study showed that 39 percent of all errors were errors in communication between routines. Unused parameters are correlated with an increased error rate. In one study, only 17 to 29 percent of routines with more than one unreferenced variable had no errors, compared to 46 percent in routines with no unused variables. The number of parameters of a routine should be 7 at maximum as research has found that people generally cannot keep track of more than about seven chunks of information at once. One experiment showed that designs which access arrays sequentially, rather than randomly, result in fewer variables and fewer variable references. [ 5 ] One experiment found that loops-with-exit are more comprehensible than other kinds of loops. [ 6 ] Regarding the level of nesting in loops and conditionals, studies have shown that programmers have difficulty comprehending more than three levels of nesting. [ 6 ] [ 7 ] Control flow complexity has been shown to correlate with low reliability and frequent errors. [ 7 ] Modularity Structuring and refactoring the code into classes , packages and other structures. When considering containment , the maximum number of data members in a class shouldn't exceed 7\u00b12. Research has shown that this number is the number of discrete items a person can remember while performing other tasks.  When considering inheritance , the number of levels in the inheritance tree should be limited.  Deep inheritance trees have been found to be significantly associated with increased fault rates.   When considering the number of routines in a class, it should be kept as small as possible.  A study on C++ programs has found an association between the number of routines and the number of faults. [ 8 ] A study by NASA showed that the putting the code into well-factored classes can double the code reusability compared to the code developed using functional design. [ 8 ] [ 4 ] Error handling Encoding logic to handle both planned and unplanned errors and exceptions . Resource management Managing computational resource use via exclusion mechanisms and discipline in accessing serially reusable resources, including threads or database locks . Security Prevention of code-level security breaches such as buffer overrun and array index overflow. Optimization Optimization while avoiding premature optimization . Documentation Both embedded in the code as comments and as external documents . Integration [ edit ] Integration is about combining separately constructed parts. Concerns include planning the sequence in which components will be integrated, creating scaffolding to support interim versions of the software, determining the degree of testing and quality work performed on components before they are integrated, and determining points in the project at which interim versions are tested. [ 1 ] Testing [ edit ] Testing can reduce the time between when faulty logic is inserted in the code and when it is detected. In some cases, testing is performed after code has been written, but in test-first programming , test cases are created before code is written. Construction includes at least two forms of testing, often performed by the developer who wrote the code: [ 1 ] unit testing and integration testing . Reuse [ edit ] Software reuse entails more than creating and using libraries . It requires formalizing the practice of reuse by integrating reuse processes and activities into the software life cycle. The tasks related to reuse in software construction during coding and testing may include: [ 1 ] selection of the reusable code, evaluation of code or test re-usability, reporting reuse metrics. Quality assurance [ edit ] Techniques for ensuring quality as software is constructed include: [ 9 ] Testing One study found that the average defect detection rates of Unit testing and integration testing are 30% and 35% respectively. [ 10 ] Software inspection With respect to software inspection , one study found that the average defect detection rate of formal code inspections is 60%. Regarding the cost of finding defects, a study found that code reading detected 80% more faults per hour than testing.  Another study shown that it costs six times more to detect design defects by using testing than by using inspections.  A study by IBM showed that only 3.5 hours were needed to find a defect through code inspections versus 15\u201325 hours through testing.  Microsoft has found that it takes 3 hours to find and fix a defect by using code inspections and 12 hours to find and fix a defect by using testing.  In a 700 thousand lines program, it was reported that code reviews were several times as cost-effective as testing. [ 10 ] Studies found that inspections result in 20% - 30% fewer defects per 1000 lines of code than less formal review practices and that they increase productivity by about 20%.  Formal inspections will usually take 10% - 15% of the project budget and will reduce overall project cost.  Researchers found that having more than 2 - 3 reviewers on a formal inspection doesn't increase the number of defects found, although the results seem to vary depending on the kind of material being inspected. [ 11 ] Technical review With respect to technical review , one study found that the average defect detection rates of informal code reviews and desk checking are 25% and 40% respectively. [ 10 ] Walkthroughs were found to have a defect detection rate of 20% - 40%, but were found also to be expensive especially when project pressures increase.  Code reading was found by NASA to detect 3.3 defects per hour of effort versus 1.8 defects per hour for testing.  It also finds 20% - 60% more errors over the life of the project than different kinds of testing.  A study of 13 reviews about review meetings, found that 90% of the defects were found in preparation for the review meeting while only around 10% were found during the meeting. [ 11 ] Static analysis With respect to Static analysis (IEEE1028), studies have shown that a combination of these techniques needs to be used to achieve a high defect detection rate.  Other studies showed that different people tend to find different defects.  One study found that the extreme programming practices of pair programming , desk checking , unit testing , integration testing , and regression testing can achieve a 90% defect detection rate. [ 10 ] An experiment involving experienced programmers found that on average they were able to find 5 errors (9 at best) out of 15 errors by testing. [ 12 ] 80% of the errors tend to be concentrated in 20% of the project's classes and routines. 50% of the errors are found in 5% of the project's classes.  IBM was able to reduce the customer reported defects by a factor of ten to one and to reduce their maintenance budget by 45% in its IMS system by repairing or rewriting only 31 out of 425 classes.  Around 20% of a project's routines contribute to 80% of the development costs.  A classic study by IBM found that few error-prone routines of OS/360 were the most expensive entities. They had around 50 defects per 1000 lines of code and fixing them costs 10 times what it took to develop the whole system. [ 12 ] Re-design [ edit ] In order to account for the unanticipated gaps in the software design , design modifications may be made during construction. [ 13 ] Language [ edit ] Types of languages used for construction include: [ 14 ] General-purpose programming language \u2013 the most flexible type of language Configuration language \u2013 developers choose from a limited set of options to create a custom software installation Toolkit language \u2013 used to build applications out of toolkits Programmers working in a language they have used for three years or more are about 30 percent more productive than programmers with equivalent experience who are new to a language.  High-level languages such as C++, Java, Smalltalk, and Visual Basic yield 5 to 15 times better productivity, reliability, simplicity, and comprehensibility than low-level languages such as assembly and C.  Equivalent code has been shown to need fewer lines to be implemented in high level languages than in lower level languages. [ 15 ] Best practices [ edit ] Many factors contribute to software quality and minimize cost of ownership . Minimize complexity [ edit ] Minimizing programming complexity is mainly driven by the limited ability of people to effectively process complex information. Complexity can be reduced via construction-focused quality techniques. [ 16 ] Anticipate change [ edit ] Anticipating change helps developers build extensible software \u2013 code that can be enhanced without disrupting the inherent design. [ 16 ] Research over 25 years shows that the cost of rework can be 10 to 100 times (5 to 10 times for smaller projects) more expensive than getting the requirements right the first time. Given that 25% of the requirements change during development on average project, the need to reduce the cost of rework elucidates the need for anticipating change. [ 17 ] Construct for verification [ edit ] Constructing for verification means building software in such a way that faults can be ferreted out readily by the developers as well as during independent testing and operational activities. Specific techniques that support constructing for verification include following coding standards to support code reviews , unit testing , organizing code to support automated testing , and restricted use of complex or hard-to-understand language structures, among others. [ 16 ] Information hiding [ edit ] Information hiding proved to be a useful design technique in large programs that made them easier to modify by a factor of 4. Low fan-out is one of the design characteristics found to be beneficial by researchers. [ 18 ] Reuse [ edit ] Software reuse can realize significant productivity, quality, and cost benefits. The primary benefits are achieved by reusing existing  software assets, and reuse is supported by creating software designed for future reuse. [ 16 ] Standards [ edit ] Standards, whether external (created by international organizations) or internal (created at the corporate level), that directly affect construction issues include: [ 16 ] Documentation standards for format and content Modelling standards such as UML Coding standards Data abstraction [ edit ] Data abstraction is a characteristic of source code that represents information in a form that is similar to its meaning, while hiding implementation details. [ 19 ] Academic research showed that data abstraction makes programs about 30% easier to understand than functional programs. [ 8 ] Object-oriented languages support a series of runtime mechanisms that increase the flexibility and adaptability of the programs like data abstraction , encapsulation , modularity , inheritance , polymorphism , and reflection . [ 20 ] [ 21 ] Defensive programming [ edit ] Defensive programming is the protection a routine from being broken by invalid inputs. [ 22 ] Assertions are executable predicates which are placed in a program that allow runtime checks of the program. [ 20 ] Design by contract is a development approach in which preconditions and postconditions are included for each routine. Error handling [ edit ] Error handling refers to the practice of coding for error conditions that may arise when a program runs. Exception handling is a programming-language construct or hardware mechanism designed to handle the occurrence of exceptions, special conditions that change the normal flow of program execution. [ 23 ] Fault tolerance is a collection of techniques that increase software reliability by detecting errors and then recovering from them if possible or containing their effects if recovery is not possible. [ 22 ] Coding aspects [ edit ] State-based logic [ edit ] State-based programming consists of using a finite state machine to implement logic. [ 22 ] Table-driven logic [ edit ] Table-driven logic uses information formatted as a table to drive execution. [ 24 ] Runtime configuration [ edit ] Runtime configuration is a technique that binds variable values and program settings when the program is running, usually by updating and reading configuration files. Internationalization [ edit ] Internationalization and localization is the activity of preparing a program to support multiple locales and supporting various locales. [ 24 ] See also [ edit ] Software engineering Software development Notes [ edit ] ^ a b c d e f g SWEBOK Pierre Bourque; Robert Dupuis; Alain Abran; James W. Moore, eds. (2004). \"Chapter 4: Software Construction\". Guide to the Software Engineering Body of Knowledge . IEEE Computer Society . pp.\u00a04\u20131\u20134\u20135. ISBN 0-7695-2330-7 . ^ SWEBOK 2014 , p.\u00a03-6. ^ McConnell 2004 , Chapter 11. ^ a b McConnell 2004 , Chapter 7. ^ McConnell 2004 , Chapter 12. ^ a b McConnell 2004 , Chapter 16. ^ a b McConnell 2004 , Chapter 19. ^ a b c McConnell 2004 , Chapter 6. ^ SWEBOK 2014 , p.\u00a03-7. ^ a b c d McConnell 2004 , Chapter 20. ^ a b McConnell 2004 , Chapter 21. ^ a b McConnell 2004 , Chapter 22. ^ SWEBOK 2014 , p.\u00a03-5. ^ SWEBOK 2014 , p.\u00a03-5 - 3-6. ^ McConnell 2004 , Chapter 4. ^ a b c d e SWEBOK 2014 , p.\u00a03-3. ^ McConnell 2004 , Chapter 3. ^ McConnell 2004 , Chapter 5. ^ Thayer 2013 , p.\u00a0140. sfn error: no target: CITEREFThayer2013 ( help ) ^ a b SWEBOK 2014 , p.\u00a03-8. ^ Thayer 2013 , pp.\u00a0140\u2013141. sfn error: no target: CITEREFThayer2013 ( help ) ^ a b c SWEBOK 2014 , p.\u00a03-9. ^ Thayer 2013 , p.\u00a0142. sfn error: no target: CITEREFThayer2013 ( help ) ^ a b SWEBOK 2014 , p.\u00a03-10. References [ edit ] Pierre Bourque; Richard E. Fairley, eds. (2014). \"Chapter 3: Software Construction\". Guide to the Software Engineering Body of Knowledge Version 3.0 . IEEE Computer Society . ISBN 978-0-7695-5166-1 . McConnell, Steven (2004). Code Complete (2nd\u00a0ed.). Microsoft Press. ISBN 978-0-7356-1967-8 . Thayer, Richard; Dorfman, Merlin (2013). Software Engineering Essentials . Vol.\u00a0I: The Development Process (Fourth\u00a0ed.). Software Management Training Press, Carmichael, California. ISBN 978-0-9852707-0-4 . External links [ edit ] Guide to the Software Engineering Body of Knowledge - 2004 Version By IEEE Computer Society Guide to the Software Engineering Body of Knowledge, Version 3.0, IEEE Computer Society, 2014 Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_construction&oldid=1327617717 \" Category : Software engineering Hidden categories: Harv and Sfn no-target errors Articles with short description Short description is different from Wikidata CS1: long volume value This page was last edited on 15 December 2025, at 09:10 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software construction 10 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Cleanroom_software_engineering",
    "title": "Cleanroom software engineering - Wikipedia",
    "content": "Cleanroom software engineering - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Philosophy 3 Central principles 4 References 5 Further reading 6 External links Toggle the table of contents Cleanroom software engineering 10 languages \u010ce\u0161tina Deutsch Espa\u00f1ol Magyar \u65e5\u672c\u8a9e Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Suomi \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Software design methodology Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e The cleanroom software engineering process is a software development process intended to produce software with a certifiable level of reliability . The central principles are software development based on formal methods, incremental implementation under statistical quality control, and statistically sound testing. History [ edit ] The cleanroom process was originally developed by Harlan Mills and several of his colleagues including Alan Hevner at IBM . [ 1 ] The cleanroom process first saw use in the mid to late 1980s. Demonstration projects within the military began in the early 1990s. [ 2 ] Recent work on the cleanroom process has examined fusing cleanroom with the automated verification capabilities provided by specifications expressed in CSP . [ 3 ] Philosophy [ edit ] The focus of the cleanroom process is on defect prevention rather than defect removal. The name \"cleanroom\" was chosen to evoke the cleanrooms used in the electronics industry to prevent the introduction of defects during the fabrication of semiconductors . Central principles [ edit ] The basic principles of the cleanroom process are Software development based on formal methods Software tool support based on some mathematical formalism includes model checking , process algebras , and Petri nets . The Box Structure Method might be one such means of specifying and designing a software product. [ 4 ] Verification that the design correctly implements the specification is performed through team review, often with software tool support. Incremental implementation under statistical quality control Cleanroom development uses an iterative approach, in which the product is developed in increments that gradually increase the implemented functionality. The quality of each increment is measured against pre-established standards to verify that the development process is proceeding acceptably. A failure to meet quality standards results in the cessation of testing for the current increment and a return to the design phase. Statistically sound testing Software testing in the cleanroom process is carried out as a statistical experiment. Based on the formal specification, a representative subset of software input/output trajectories is selected and tested. This sample is then statistically analyzed to produce an estimate of the reliability of the software and a level of confidence in that estimate. References [ edit ] ^ Mills, H. ; M. Dyer; R. Linger (September 1987). \"Cleanroom Software Engineering\" (PDF) . IEEE Software . 4 (5): 19\u2013 25. Bibcode : 1987ISoft...4e..19M . doi : 10.1109/MS.1987.231413 . S2CID 383170 . ^ Foreman, John (2005). \"Cleanroom Software Engineering Reference\" . Software Technology Roadmap . Software Engineering Institute (SEI) . Retrieved 2006-04-27 . ^ Guy H. Broadfoot and P. J. Hopcroft (2005). \"Introducing formal methods into industry using Cleanroom and CSP\". Dedicated Systems e-Magazine. S2CID 14066854 . {{ cite journal }} : Cite journal requires |journal= ( help ) ^ Linger, R. (April 1994). \"Cleanroom Process Model\". IEEE Software . 11 (2): 50\u2013 58. Bibcode : 1994ISoft..11b..50L . CiteSeerX 10.1.1.130.8642 . doi : 10.1109/52.268956 . S2CID 206447346 . Further reading [ edit ] Stavely, Allan (1999). Toward Zero-Defect Programming . Addison-Wesley. Stacy J. Prowell and Carmen J. Trammell and Richard C. Linger and Jesse H. Poore (1999). Cleanroom Software Engineering: Technology and Process . Addison-Wesley. Jesse H. Poore and Carmen J. Trammell (1996). Cleanroom Software Engineering: A Reader . NCC Blackwell. External links [ edit ] An introduction v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Cleanroom_software_engineering&oldid=1313153145 \" Category : Software quality Hidden categories: CS1 errors: missing periodical Articles with short description Short description matches Wikidata Use American English from April 2019 All Wikipedia articles written in American English This page was last edited on 24 September 2025, at 15:59 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Cleanroom software engineering 10 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_maintenance",
    "title": "Software maintenance - Wikipedia",
    "content": "Software maintenance - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Software life cycle Toggle Software life cycle subsection 2.1 Transition from release to maintenance to end of the lifespan 2.2 Change cycle 3 Categories of software maintenance 4 Maintainability 5 Workforce 6 Alternatives to maintenance 7 Research 8 References 9 Sources Toggle the table of contents Software maintenance 30 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 Deutsch Eesti Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais Galego \ud55c\uad6d\uc5b4 \u0540\u0561\u0575\u0565\u0580\u0565\u0576 Hrvatski Ido Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Magyar \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0421\u0440\u043f\u0441\u043a\u0438 / srpski \u0ba4\u0bae\u0bbf\u0bb4\u0bcd T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0627\u0631\u062f\u0648 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Modification of software after delivery Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Software maintenance is the modification of software after delivery. Software maintenance is often considered lower skilled and less rewarding than new development. As such, it is a common target for outsourcing or offshoring . Usually, the team developing the software is different from those who will be maintaining it. The developers lack an incentive to write the code to be easily maintained. Software is often delivered incomplete and almost always contains some bugs that the maintenance team must fix. Software maintenance often initially includes the development of new functionality, but as the product nears the end of its lifespan, maintenance is reduced to the bare minimum and then cut off entirely before the product is withdrawn. Each maintenance cycle begins with a change request typically originating from an end user. That request is evaluated and if it is decided to implement it, the programmer studies the existing code to understand how it works before implementing the change. Testing to make sure the existing functionality is retained and the desired new functionality is added often comprises most of the maintenance cost. Software maintenance is not as well studied as other phases of the software life cycle, despite comprising most of the cost. Understanding has not changed significantly since the 1980s. Software maintenance can be categorized into several types depending on whether it is preventative or reactive and whether it is seeking to add functionality or preserve existing functionality, the latter typically in the face of a changed environment. History [ edit ] In the early 1970s, companies began to separate out software maintenance with its own team of engineers to free up software development teams from support tasks. [ 1 ] In 1972, R. G. Canning published \"The Maintenance 'Iceberg ' \", in which he contended that software maintenance was an extension of software development with an additional input: the existing system. [ 1 ] The discipline of software maintenance has changed little since then. [ 2 ] One twenty-first century innovation has been companies deliberately releasing incomplete software and planning to finish it post-release. This type of change, and others that expand functionality, is often called software evolution instead of maintenance. [ 2 ] Software life cycle [ edit ] Diagram for a traditional software development life cycle from 1988 Despite testing and quality assurance , virtually all software contains bugs where the system does not work as intended. Post-release maintenance is necessary to remediate these bugs when they are found. [ 3 ] Most software is a combination of pre-existing commercial off-the-shelf (COTS) and open-source software components with custom-written code. COTS and open-source software is typically updated over time, which can reduce the maintenance burden, but the modifications to these software components will need to be adjusted for in the final product. [ 4 ] Unlike software development , which is focused on meeting specified requirements, software maintenance is driven by events\u2014such as user requests or detection of a bug. [ 5 ] Its main purpose is to preserve the usefulness of the software, usually in the face of changing requirements. [ 6 ] If conceived of as part of the software development life cycle , maintenance is the last and typically the longest phase of the cycle, [ 7 ] [ 8 ] comprising 80 to 90 percent of the lifecycle cost. [ 9 ] Other models consider maintenance separate from software development, instead as part of the software maintenance life cycle (SMLC). [ 8 ] SMLC models typically include understanding the code, modifying it, and revalidating it. [ 8 ] Transition from release to maintenance to end of the lifespan [ edit ] Diagram showing the steps for software retirement Frequently, software is delivered in an incomplete state. Developers will test a product until running out of time or funding, because they face fewer consequences for an imperfect product than going over time or budget. [ 10 ] The transition from the development to the maintenance team is often inefficient, without lists of known issues or validation tests, which the maintenance team will  likely recreate. [ 11 ] After release, members of the development team are likely to be reassigned or otherwise become unavailable. The maintenance team will require additional resources for the first year after release, both for technical support and fixing defects left over from development. [ 10 ] Initially, software may go through a period of enhancements after release. New features are added according to user feedback. At some point, the company may decide that it is no longer profitable to make functional improvements, and restrict support to bug fixing and emergency updates. Changes become increasingly difficult and expensive due to lack of expertise or decaying architecture due to software aging . After a product is no longer maintained, and does not receive even this limited level of updating, some vendors will seek to extract revenue from the software as long as possible, even though the product is likely to become increasingly avoided. Eventually, the software will be withdrawn from the market, although it may remain in use. During this process, the software becomes a legacy system . [ 12 ] Change cycle [ edit ] The first step in the change cycle is receiving a change request from a customer and analyzing it to confirm the problem and decide whether to implement the change. [ 13 ] This may require input from multiple departments; for example, the marketing team can help evaluate whether the change is expected to bring more business. [ 14 ] Software development effort estimation is a difficult problem, including for maintenance change requests, [ 15 ] but the request is likely to be declined if it is too expensive or infeasible. [ 16 ] If it is decided to implement the request, it can be assigned to a scheduled release and implemented. [ 16 ] Although agile methodology does not have a maintenance phase, [ 17 ] the change cycle can be enacted as a scrum sprint . [ 18 ] Understanding existing code is an essential step before modifying it. [ 2 ] The rate of understanding depends both on the code base as well as the skill of the programmer. [ 19 ] Following coding conventions such as using clear function and variable names that correspond to their purpose makes understanding easier. [ 20 ] Use of conditional loop statements only if the code could execute more than once, and eliminating code that will never execute can also increase understandability. [ 21 ] Experienced programmers have an easier time understanding what the code does at a high level. [ 22 ] Software visualization is sometimes used to speed up this process. [ 23 ] Modification to the code may take place in any way. On the one hand, it is common to haphazardly apply a quick fix without being granted enough time to update the code documentation . [ 24 ] On the other hard structured iterative enhancement can begin by changing the top-level requirements document and propagating the change down to lower levels of the system. [ 25 ] Modification often includes code refactoring (improving the structure without changing functionality) and restructuring (improving structure and functionality at the same time). [ 26 ] Unlike commercial software, free and open source software change cycles are largely restricted to coding and testing, with minimal documentation. Open-source software projects instead rely on mailing lists and a large number of contributors to understand the code base and fix bugs efficiently. [ 27 ] An additional problem with maintenance is that nearly every change to code will introduce new bugs or unexpected ripple effects , which require another round of fixes. [ 2 ] Testing can consume most of the maintenance resource for safety-critical code, due to the need to revalidate the entire software if any changes are made. [ 28 ] Revalidation may include code review , regression testing with a subset of unit tests , integration tests , and system tests . [ 26 ] The goal of the testing is to verify that previous functionality is retained, and the new functionality has been added. [ 29 ] Categories of software maintenance [ edit ] The key purpose of software maintenance is ensuring that the product continues to meet usability requirements. At times, this may mean extending the product's capabilities beyond what was initially envisioned. [ 30 ] According to the ISO / IEC 14764 specification, software maintenance can be classified into four types: [ 31 ] Corrective maintenance : modification of software to fix a bug or other failure to meet requirements, typically reported by an end user. [ 31 ] [ 32 ] Preventive maintenance : forward-looking modification of software after delivery to ensure it continues to meet requirements or fix problems that have not manifested yet. [ 33 ] [ 31 ] This type of maintenance is performed especially on systems that are required to be highly safe or available. [ 33 ] Software rejuvenation is one form of preventative maintenance to clean up state and prevent future problems. [ 33 ] Adaptive maintenance: modification of software performed after delivery to ensure its continuing usability in a changed or changing environment. [ 31 ] [ 33 ] Perfective maintenance: enhancement of software after delivery to improve qualities such as user experience , processing efficiency, and maintainability . [ 33 ] [ 34 ] Perfective maintenance is necessary if other types of maintenance are carried out, because modification of an existing code base will otherwise increase complexity and cause the existing structure to deteriorate. [ 34 ] Perfective maintenance may include rewriting documentation , code refactoring , and performance tuning. [ 33 ] According to some estimates, enhancement (the latter two categories) comprises some 80 percent of software maintenance. [ 35 ] Maintainability [ edit ] Maintainability is the quality of software enabling it to be easily modified without breaking existing functionality. [ 31 ] According to the  ISO/IEC 14764 specification, activity to ensure software maintainability prior to release counts as part of software maintenance. [ 5 ] Many software development organizations neglect maintainability, even though doing so will increase long-term costs. [ 36 ] Technical debt is incurred when programmers, often out of laziness or urgency to meet a deadline, choose quick and dirty solutions rather than build maintainability into their code. [ 37 ] A common cause is underestimates in software development effort estimation , leading to insufficient resources allocated to development. [ 38 ] One important aspect is having a large amount of automated software tests that can detect if existing functionality is compromised by a change. [ 31 ] A maintainability index can be calculated with certain formulae from lines-of-code measures , McCabe measures and Halstead complexity measures . The measurement and tracking of maintainability are intended to help reduce or reverse a system's tendency toward \"code entropy\" or degraded integrity, and to indicate when it becomes cheaper and/or less risky to rewrite the code than it is to change it. A challenge with maintainability is that many software engineering courses do not emphasize it, and give out one-and-done assignments that have clear and unchanging specifications. [ 39 ] Software engineering courses do not cover systems as complex as occur in the real world. [ 40 ] Development engineers who know that they will not be responsible for maintaining the software do not have an incentive to build in maintainability. [ 2 ] Workforce [ edit ] Maintenance is often considered an unrewarding job for software engineers , who, if assigned to maintenance, were more likely to quit. [ 41 ] [ 42 ] It often pays less than a comparable job in software development. [ 42 ] The task is often assigned to temporary workers or lesser-skilled staff, [ 2 ] [ 43 ] although maintenance engineers are also typically older than developers, partly because they must be familiar with outdated technologies. [ 43 ] In 2008, around 900,000 of the 1.3 million software engineers and programmers working in the United States were doing maintenance. [ 44 ] Companies started separate teams for maintenance, which led to outsourcing this work to a different company, and by the turn of the twenty-first century, sometimes offshoring the work to another country\u2014whether as part of the original company or a separate entity. [ 45 ] [ 9 ] The typical sources of outsourcing are developed countries such as the United States, the United Kingdom, Japan, and Australia, while destinations are usually lower-cost countries such as China, India, Russia, and Ireland. [ 46 ] Reasons for offshoring include taking advantage of lower labor costs, enabling around-the-clock support, reducing time pressure on developers, and to move support closer to the market for the product. [ 47 ] Downsides of offshoring include communication barriers in the form of such factors as time zone and organizational disjunction and cultural differences. [ 9 ] Despite many employers considering maintenance lower-skilled work and the phase of software development most suited to offshoring, [ 9 ] [ 48 ] it requires close communication with the customer and rapid response, both of which are hampered by these communication difficulties. [ 9 ] Alternatives to maintenance [ edit ] In software engineering, the term legacy system does not have a fixed meaning, but often refers to older systems which are large, difficult to modify, and also necessary for current business needs. Often legacy systems are written in obsolete programming languages , lack documentation, have a deteriorating structure after years of changes, and depend on experts to keep it operational. [ 49 ] When dealing with these systems, at some point so much technical debt accumulates that maintenance is not practical or economical. [ 12 ] Other choices include: Freezing\u2014do no more work on the legacy system. [ 50 ] This option may be chosen if the vendor wants to continue to extract revenue as long as possible while avoiding maintenance costs. [ 12 ] Outsourcing functionality of the legacy system to a different company, especially if it is not considered a core business function. [ 50 ] Discarding the existing legacy system and redeveloping a new application from scratch to fulfill the same purpose as the legacy system. [ 50 ] However, this approach is inefficient due to discarding a working system, and with this approach there is a danger that the new system will not fulfill changing business requirements. [ 50 ] Wrapping the legacy application in an abstraction layer to simplify outdated interfaces. [ 50 ] The source code is not modified but the new interface allows a tried and tested component to be accessed by newer applications. This approach does not fix any of the issues with maintaining a legacy system. [ 51 ] Databases, functions, and entire applications may be wrapped in this way. [ 52 ] Migrating the legacy system to a new platform, which can reduce the expense of new software development by reusing the  implementation, design, specification, and requirements of the legacy system. [ 53 ] Migration can take 5 to 10 years, but results in greater flexibility and long-term savings in software maintenance. [ 54 ] As much as 80 percent of the expense is in testing; that is, ensuring that the new system has the same output as the old system. [ 55 ] After the new system is finished, there needs to be a transition from the old system to the new system with minimum disruption to business functions. [ 55 ] Research [ edit ] Despite taking up the lion's share of software development resources, maintenance is the least studied phase of software development. [ 56 ] [ 57 ] Much of the literature has focused on how to develop maintainable code from the outset, with less focus on motivating engineers to make maintainability a priority. [ 58 ] As of 2020 [update] , automated solutions for code refactoring to reduce maintenance effort are an active area of research, [ 59 ] as is machine-learning enhanced maintainability assessment. [ 60 ] References [ edit ] ^ a b Tripathy & Naik 2014 , p.\u00a025. ^ a b c d e f Offutt, Jeff (January 2018). \"Overview of Software Maintenance and Evolution\" . George Mason University Department of Computer Science . Retrieved 5 May 2024 . ^ Tripathy & Naik 2014 , p.\u00a04. ^ Tripathy & Naik 2014 , pp.\u00a05\u20136. ^ a b Tripathy & Naik 2014 , p.\u00a026. ^ Madhusudhan et al. 2017 , p.\u00a0761. ^ Varga 2018 , p.\u00a03. ^ a b c Tripathy & Naik 2014 , p.\u00a07. ^ a b c d e Ulziit et al. 2015 , p.\u00a0764. ^ a b Reifer 2012 , p.\u00a022. ^ Reifer 2012 , p.\u00a021. ^ a b c Tripathy & Naik 2014 , p.\u00a089. ^ Madhusudhan et al. 2017 , p.\u00a0763. ^ Tripathy & Naik 2014 , p.\u00a0120. ^ Madhusudhan et al. 2017 , p.\u00a0762. ^ a b Tripathy & Naik 2014 , p.\u00a0123. ^ Ali et al. 2024 , p.\u00a0126. ^ Ali et al. 2024 , p.\u00a0130. ^ Tripathy & Naik 2014 , p.\u00a0296. ^ Tripathy & Naik 2014 , pp.\u00a0296\u2013297. ^ Tripathy & Naik 2014 , p.\u00a0309. ^ Tripathy & Naik 2014 , p.\u00a0297. ^ Tripathy & Naik 2014 , pp.\u00a0318\u2013319. ^ Tripathy & Naik 2014 , pp.\u00a085\u201386. ^ Tripathy & Naik 2014 , p.\u00a086. ^ a b Tripathy & Naik 2014 , p.\u00a094. ^ Tripathy & Naik 2014 , p.\u00a059. ^ Reifer 2012 , p.\u00a05. ^ Tripathy & Naik 2014 , p.\u00a098. ^ Varga 2018 , p.\u00a04. ^ a b c d e f Varga 2018 , p.\u00a05. ^ Tripathy & Naik 2014 , pp.\u00a026\u201327. ^ a b c d e f Tripathy & Naik 2014 , p.\u00a027. ^ a b Varga 2018 , pp.\u00a05\u20136. ^ Varga 2018 , p.\u00a05 fn 4. ^ Varga 2018 , p.\u00a012. ^ Varga 2018 , pp.\u00a06\u20137. ^ Varga 2018 , p.\u00a07. ^ Varga 2018 , pp.\u00a07\u20138. ^ Varga 2018 , p.\u00a09. ^ Madhusudhan et al. 2017 , p.\u00a0764. ^ a b Reifer 2012 , p.\u00a07. ^ a b Reifer 2012 , p.\u00a08. ^ Reifer 2012 , p.\u00a01. ^ Rahman et al. 2024 , p.\u00a01. ^ Rahman et al. 2021 , Research Background. ^ Ulziit et al. 2015 , p.\u00a0763. ^ Reifer 2012 , p.\u00a02. ^ Tripathy & Naik 2014 , pp.\u00a0187\u2013188. ^ a b c d e Tripathy & Naik 2014 , p.\u00a0188. ^ Tripathy & Naik 2014 , p.\u00a0189. ^ Tripathy & Naik 2014 , p.\u00a0191. ^ Tripathy & Naik 2014 , pp.\u00a0188\u2013189. ^ Tripathy & Naik 2014 , p.\u00a0195. ^ a b Tripathy & Naik 2014 , p.\u00a0196. ^ Madhusudhan et al. 2017 , p.\u00a0759. ^ Ulziit et al. 2015 , p.\u00a0766. ^ Reifer 2012 , pp.\u00a04\u20135. ^ Baqais & Alshayeb 2020 , p.\u00a0459. ^ Alsolai & Roper 2020 , p.\u00a0106214. Sources [ edit ] Ali, Muhammad; Cheema, Sehrish Munawar; Naz, Ammerha; Pires, Ivan Miguel (2024). \"SAMSEF: An Agile Software Maintenance Leveraging Scrum Framework for Improved Efficiency and Effectiveness\". Good Practices and New Perspectives in Information Systems and Technologies . Lecture Notes in Networks and Systems. Vol.\u00a0989. Springer Nature Switzerland. pp. 126\u2013 136. doi : 10.1007/978-3-031-60227-6_11 . ISBN 978-3-031-60226-9 . Alsolai, Hadeel; Roper, Marc (2020). \"A systematic literature review of machine learning techniques for software maintainability prediction\" (PDF) . Information and Software Technology . 119 106214. doi : 10.1016/j.infsof.2019.106214 . Baqais, Abdulrahman Ahmed Bobakr; Alshayeb, Mohammad (2020). \"Automatic software refactoring: a systematic literature review\". Software Quality Journal . 28 (2): 459\u2013 502. doi : 10.1007/s11219-019-09477-y . Madhusudhan, V.; Suma, V.; Rao, Jawahar J. (2017). Software Maintenance: From the Perspective of Effort and Cost Requirement . Proceedings of the International Conference on Data Engineering and Communication Technology. Springer. pp. 759\u2013 768. ISBN 978-981-10-1678-3 . Rahman, Hanif Ur; da Silva, Alberto Rodrigues; Alzayed, Asaad; Raza, Mushtaq (2024). \"A Systematic Literature Review on Software Maintenance Offshoring Decisions\". Information and Software Technology . 172 107475. doi : 10.1016/j.infsof.2024.107475 . Rahman, Hanif Ur; Raza, Mushtaq; Afsar, Palwasha; Khan, Habib Ullah (2021). \"Empirical Investigation of Influencing Factors Regarding Offshore Outsourcing Decision of Application Maintenance\". IEEE Access . 9 : 58589\u2013 58608. Bibcode : 2021IEEEA...958589R . doi : 10.1109/ACCESS.2021.3073315 . hdl : 10576/37687 . ISSN 2169-3536 . Reifer, Donald J. (2012). Software Maintenance Success Recipes . CRC Press. ISBN 978-1-4398-5167-8 . Tripathy, Priyadarshi; Naik, Kshirasagar (2014). Software Evolution and Maintenance: A Practitioner's Approach . John Wiley & Sons. ISBN 978-0-470-60341-3 . Ulziit, Bayarbuyan; Warraich, Zeeshan Akhtar; Gencel, Cigdem; Petersen, Kai (2015). \"A conceptual framework of challenges and solutions for managing global software maintenance\". Journal of Software: Evolution and Process . 27 (10): 763\u2013 792. doi : 10.1002/smr.1720 . Varga, Ervin (2018). Unraveling Software Maintenance and Evolution: Thinking Outside the Box . Springer. ISBN 978-3-319-71303-8 . v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control flow Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Computational problem Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human-centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human\u2013computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Specialized Platform\nDevelopment Thermodynamic computing Category Outline Glossaries v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons v t e IEEE standards Current 488 693 730 754 Revision 854 828 829 896 1003 1014 1016 1076 1149.1 1154 1164 1275 1278 1284 1355 1394 1451 1497 1516 1541 1547 1584 1588 1596 1603 1613 1619 1666 1667 1675 1685 1722 1733 1800 1801 1815 1849 1850 1855 1900 1901 1902 1904 1905 2030 2050 11073 12207 14764 16085 16326 29148 42010 802 series 802 .2 .4 .5 .6 .7 .8 .9 .10 .12 .14 .16 WiMAX \u00b7 d \u00b7 e .17 .18 .20 .21 .22 .24 802.1 D p Q Qav Qat Qay Qaz Qbb w X AB ad AE ag ah ak aq AS AX ( LACP ) BA 802.3 ( Ethernet ) -1983 a b d e i j u x y z ab ac ad ae af ah ak an aq at au av az ba bt bu by bz ca cb cc cd ce cg ch ck cm cn cp cq cr cs ct cu cv cw cx cy cz da db dd de df 802.11 ( Wi-Fi ) -1997 legacy mode a b c d e f g h i j k n ( Wi-Fi 4 ) p r s u v w y z aa ac ( Wi-Fi 5 ) ad ( WiGig ) ae af ah ai aj ak aq ax ( Wi-Fi 6 ) ay az ba bb bc bd be ( Wi-Fi 7 ) bf bh bi bk bn ( Wi-Fi 8 ) 802.15 .1 ( Bluetooth ) .2 .3 .4 ( Zigbee ) .4a .4b .4c .4d .4e .4f .4g .4z .5 .6 .7 Proposed P1363 P1699 P1823 P1906.1 Superseded 754-1985 830 1219 1233 1362 1364 1471 Category v t e International Organization for Standardization (ISO) standards List of ISO standards \u2013 ISO romanizations \u2013 IEC standards 1\u20139999 1 2 3 4 6 7 9 16 17 31 -0 -1 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 68-1 128 216 217 226 228 233 259 261 262 302 306 361 500 518 519 639 -1 -2 -3 -5 -6 646 657 668 690 704 732 764 838 843 860 898 965 999 1000 1004 1007 1073-1 1073-2 1155 1413 1538 1629 1745 1989 2014 2015 2022 2033 2047 2108 2145 2146 2240 2281 2533 2709 2711 2720 2788 2848 2852 2921 3029 3103 3166 -1 -2 -3 3297 3307 3601 3602 3864 3901 3950 3977 4031 4157 4165 4217 4909 5218 5426 5427 5428 5725 5775 5776 5800 5807 5964 6166 6344 6346 6373 6385 6425 6429 6438 6523 6709 6943 7001 7002 7010 7027 7064 7098 7185 7200 7498 -1 7637 7736 7810 7811 7812 7813 7816 7942 8000 8093 8178 8217 8373 8501-1 8571 8583 8601 8613 8632 8651 8652 8691 8805/8806 8807 8820-5 8859 -1 -2 -3 -4 -5 -6 -7 -8 -8-I -9 -10 -11 -12 -13 -14 -15 -16 8879 9000/9001 9036 9075 9126 9141 9227 9241 9293 9314 9362 9407 9496 9506 9529 9564 9592/9593 9594 9660 9797-1 9897 9899 9945 9984 9985 9995 10000\u201319999 10006 10007 10116 10118-3 10160 10161 10165 10179 10206 10218 10279 10303 -11 -21 -22 -28 -238 10383 10585 10589 10628 10646 10664 10746 10861 10957 10962 10967 11073 11170 11172 11179 11404 11544 11783 11784 11785 11801 11889 11898 11940 ( -2 ) 11941 11941 (TR) 11992 12006 12052 12182 12207 12234-2 12620 13211 -1 -2 13216 13250 13399 13406-2 13450 13485 13490 13567 13568 13584 13616 13816 13818 14000 14031 14224 14289 14396 14443 14496 -2 -3 -6 -10 -11 -12 -14 -17 -20 14617 14644 14649 14651 14698 14764 14882 14971 15022 15189 15288 15291 15398 15408 15444 -3 -9 15445 15438 15504 15511 15686 15693 15706 -2 15707 15897 15919 15924 15926 15926 WIP 15930 15938 16023 16262 16355-1 16485 16612-2 16750 16949 (TS) 17024 17025 17100 17203 17369 17442 17506 17799 18004 18014 18181 18245 18629 18760 18916 19005 19011 19092 -1 -2 19114 19115 19125 19136 19407 19439 19500 19501 19502 19503 19505 19506 19507 19508 19509 19510 19600 19752 19757 19770 19775-1 19794-5 19831 20000\u201329999 20000 20022 20121 20400 20802 20830 21000 21001 21047 21122 21500 21778 21827 22000 22275 22300 22301 22395 22537 23000 23003 23008 23009 23090-3 23092 23094-1 23094-2 23270 23271 23360 23941 24517 24613 24617 24707 24728 25178 25964 26000 26262 26300 26324 27000 series 27000 27001 27002 27005 27006 27729 28000 29110 29148 29199-2 29500 30000+ 30170 31000 32000 37001 38500 39075 40314 40500 42010 45001 50001 55000 56000 80000 Category Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_maintenance&oldid=1303327031 \" Categories : Software maintenance IEEE standards ISO/IEC standards Hidden categories: Articles with short description Short description is different from Wikidata Good articles Articles containing potentially dated statements from 2020 All articles containing potentially dated statements This page was last edited on 30 July 2025, at 09:33 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software maintenance 30 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Incremental_build_model",
    "title": "Incremental build model - Wikipedia",
    "content": "Incremental build model - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Incremental model 2 Tasks involved 3 See also 4 Citations 5 References 6 External links Toggle the table of contents Incremental build model 5 languages Catal\u00e0 \u0641\u0627\u0631\u0633\u06cc Bahasa Indonesia Magyar \u7cb5\u8a9e Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Method of Software development Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e The incremental build model is a method of software development where the product is designed , implemented, and tested incrementally (a little more is added each time) until the product is finished. It involves both development and maintenance. The product is defined as finished when it satisfies all of its requirements. This model combines the elements of the waterfall model with the iterative philosophy of prototyping .\nAccording to the Project Management Institute , an incremental approach is an \"adaptive development approach in which the deliverable is produced successively, adding\nfunctionality until the deliverable contains the necessary and\nsufficient capability to be considered complete.\" [ 1 ] :\u200aSection 3. Definitions The product is decomposed into several components, each of which is designed and built separately (termed as builds). [ 1 ] :\u200aSection 3.5 Each component is delivered to the client when it is complete. This allows partial utilization of the product and avoids a long\ndevelopment time. It also avoids a large initial capital outlay and subsequent long waiting periods. This model of development also helps ease the traumatic effect of introducing a completely new system all at once. Incremental model [ edit ] The incremental model applies the waterfall model incrementally. [ 2 ] The series of releases is referred to as \u201cincrements,\" with each increment providing more functionality to the customers. After the first increment, a core product is delivered, which can already be used by the customer. Based on customer feedback, a plan is developed for the next increments, and modifications are made accordingly. This process continues, with increments being delivered until the complete product is delivered. The incremental philosophy is also used in the agile process model (see agile modeling ). [ 2 ] [ 1 ] :\u200aSection 2.3.3 The Incremental model can be applied to DevOps . DevOps centers around the idea of minimizing the risk and cost of a DevOps adoption whilst building the necessary in-house skillset and momentum. [ 3 ] Characteristics of Incremental Model The system is broken down into many mini-development projects. Partial systems are built to produce the final system. First tackled the highest priority requirements. The requirement of a portion is frozen once the incremented portion is developed. Advantages [ 4 ] [ 5 ] After each iteration, regression testing should be conducted. During this testing, faulty elements of the software can be quickly identified because few changes are made within any single iteration. It is generally easier to test and debug than other methods of software development because relatively smaller changes are made during each iteration. This allows for more targeted and rigorous testing of each element within the overall product. Customers can respond to features and review the product for any needed or useful changes. Initial product delivery is faster and costs less. Disadvantages [ 6 ] The resulting cost may exceed the cost of the organization. As additional functionality is added to the product, problems may arise related to system architecture which were not evident in earlier prototypes Tasks involved [ edit ] Tasks In Incremental Model These tasks are common to all the models: [ 2 ] Communication: helps to understand the objective. Planning: required as many people (software teams) to work on the same project but with different functions at the same time. Modeling: involves business modeling, data modeling, and process modeling. Construction: this involves the reuse of software components and automatic code. Deployment: integration of all the increments. See also [ edit ] Iterative and incremental development Rapid application development Incremental approach Citations [ edit ] ^ a b c Project Management Institute 2021 . ^ a b c Pressman, Roger (2010). Software Engineering: A Practitioner's Approach . Boston: McGraw Hill. pp. 41\u2013 42. ISBN 9780073375977 . ^ Kim, Gene (22 January 2013). \"DevOps distilled, Part 1: The three underlying principles\" (PDF) . IBM DeveloperWorks . ^ www.softdevteam.com/ Incremental- lifecycle.asp ^ What is Incremental model - advantages, disadvantages and when to use it ^ \"Methodology:: Development Methods\" . Archived from the original on 2016-03-03 . Retrieved 2011-09-17 . References [ edit ] Project Management Institute (2021). A guide to the project management body of knowledge (PMBOK guide) . Project Management Institute (7th\u00a0ed.). Newtown Square, PA. ISBN 978-1-62825-664-2 . {{ cite book }} :  CS1 maint: location missing publisher ( link ) External links [ edit ] Methodology::Development Models Archived 2016-03-03 at the Wayback Machine Incremental lifecycle What is Incremental model - advantages, disadvantages and when to use it Incremental Model in Software Engineering v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Incremental_build_model&oldid=1290124417 \" Category : Software development process Hidden categories: Articles with short description Short description is different from Wikidata CS1 maint: location missing publisher Webarchive template wayback links This page was last edited on 12 May 2025, at 23:48 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Incremental build model 5 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Agile_software_development",
    "title": "Agile software development - Wikipedia",
    "content": "Agile software development - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Values and principles Toggle Values and principles subsection 2.1 Values 2.2 Principles 3 Overview Toggle Overview subsection 3.1 Iterative, incremental, and evolutionary 3.2 Efficient and face-to-face communication 3.2.1 Information radiator 3.3 Very short feedback loop and adaptation cycle 3.4 Quality focus 4 Philosophy Toggle Philosophy subsection 4.1 Adaptive vs. predictive 4.2 Agile vs. waterfall 4.3 Code vs. documentation 5 Methods Toggle Methods subsection 5.1 Agile software development practices 5.1.1 Acceptance test-driven development 5.1.2 Agile modeling 5.1.3 Agile testing 5.1.4 Backlogs 5.1.5 Behavior-driven development 5.1.6 Continuous integration 5.1.7 Cross-functional team 5.1.8 Daily stand-up 5.2 Method tailoring 5.3 Large-scale, offshore and distributed 5.4 Regulated domains 6 Experience and adoption Toggle Experience and adoption subsection 6.1 Measuring agility 6.1.1 Internal assessments 6.1.2 Public surveys 6.2 Common agile software development pitfalls 6.2.1 Lack of overall product design 6.2.2 Adding stories to an iteration in progress 6.2.3 Lack of sponsor support 6.2.4 Insufficient training 6.2.5 Product owner role is not properly filled 6.2.6 Teams are not focused 6.2.7 Excessive preparation/planning 6.2.8 Problem-solving in the daily standup 6.2.9 Assigning tasks 6.2.10 Scrum master as a contributor 6.2.11 Lack of test automation 6.2.12 Allowing technical debt to build up 6.2.13 Attempting to take on too much in an iteration 6.2.14 Fixed time, resources, scope, and quality 6.2.15 Developer burnout 7 Agile management Toggle Agile management subsection 7.1 Applications outside software development 8 Criticism 9 See also 10 References 11 Further reading 12 External links Toggle the table of contents Agile software development 48 languages Afrikaans \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u0411\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u010ce\u0161tina Dansk Deutsch Eesti \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais Galego \ud55c\uad6d\uc5b4 \u0540\u0561\u0575\u0565\u0580\u0565\u0576 Igbo Bahasa Indonesia Italiano \u05e2\u05d1\u05e8\u05d9\u05ea \u0c95\u0ca8\u0ccd\u0ca8\u0ca1 Latvie\u0161u Lietuvi\u0173 Magyar \u1019\u103c\u1014\u103a\u1019\u102c\u1018\u102c\u101e\u102c Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas Qaraqalpaqsha Rom\u00e2n\u0103 \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip Sloven\u0161\u010dina \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Srpskohrvatski / \u0441\u0440\u043f\u0441\u043a\u043e\u0445\u0440\u0432\u0430\u0442\u0441\u043a\u0438 Suomi Svenska \u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0c24\u0c46\u0c32\u0c41\u0c17\u0c41 \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 \u101b\u1001\u102d\u102f\u1004\u103a Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikibooks Wikiversity Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Umbrella term for certain approaches to software development Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Agile software development is an umbrella term for approaches to developing software that reflect the values and principles agreed upon by The Agile Alliance, a group of 17 software practitioners, in 2001. [ 1 ] As documented in their Manifesto for Agile Software Development , the practitioners value: [ 2 ] Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan The practitioners cite inspiration from new practices at the time including extreme programming , scrum , dynamic systems development method , adaptive software development , and being sympathetic to the need for an alternative to documentation-driven, heavyweight software development processes. [ 3 ] Many software development practices emerged from the agile mindset. These agile-based practices, sometimes called Agile (with a capital A), [ 4 ] include requirements, discovery, and solutions improvement through the collaborative effort of self-organizing and cross-functional teams with their customer(s) / end user(s) . [ 5 ] [ 6 ] While there is much anecdotal evidence that the agile mindset and agile-based practices improve the software development process, the empirical evidence is limited and less than conclusive. [ 7 ] [ 8 ] [ 9 ] History [ edit ] Iterative and incremental software development methods can be traced back as early as 1957, [ 10 ] with evolutionary project management [ 11 ] [ 12 ] and adaptive software development [ 13 ] emerging in the early 1970s. [ 14 ] During the 1990s, a number of lightweight software development methods evolved in reaction to the prevailing heavyweight methods (often referred to collectively as waterfall ) that critics described as overly regulated, planned, and micromanaged . [ 15 ] These lightweight methods included rapid application development (RAD), from 1991; [ 16 ] [ 17 ] the unified process (UP) and dynamic systems development method (DSDM), both from 1994; Scrum , from 1995; Crystal Clear and extreme programming (XP), both from 1996; and feature-driven development (FDD), from 1997. Although these all originated before the publication of the Agile Manifesto , they are now collectively referred to as agile software development methods. [ 3 ] Already since 1991 similar changes had been underway in manufacturing [ 18 ] [ 19 ] and management thinking [ 20 ] derived from lean management . In 2001, seventeen software developers met at a resort in Snowbird, Utah to discuss lightweight development methods. They were Kent Beck (Extreme Programming), Ward Cunningham (Extreme Programming), Dave Thomas ( Pragmatic Programming , Ruby), Jeff Sutherland (Scrum), Ken Schwaber (Scrum), Jim Highsmith (Adaptive Software Development), Alistair Cockburn (Crystal), Robert C. Martin ( SOLID ), Mike Beedle (Scrum), Arie van Bennekum, Martin Fowler ( OOAD and UML ), James Grenning, Andrew Hunt (Pragmatic Programming, Ruby), Ron Jeffries (Extreme Programming), Jon Kern , Brian Marick (Ruby, Test-driven development ), and Steve Mellor ( OOA ). The group, The Agile Alliance, published the Manifesto for Agile Software Development . [ 2 ] In 2005, a group headed by Cockburn and Highsmith wrote an addendum of project management principles, the PM Declaration of Interdependence, [ 21 ] to guide software project management according to agile software development methods. In 2009, a group working with Martin wrote an extension of software development principles, the Software Craftsmanship Manifesto , to guide agile software development according to professional conduct and mastery. In 2011, the Agile Alliance created the Guide to Agile Practices (renamed the Agile Glossary in 2016), [ 22 ] an evolving open-source compendium of the working definitions of agile practices, terms, and elements, along with interpretations and experience guidelines from the worldwide community of agile practitioners. Values and principles [ edit ] Values [ edit ] The agile manifesto reads: [ 2 ] We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value: Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan That is, while there is value in the items on the right, we value the items on the left more. Scott Ambler explained: [ 23 ] Tools and processes are important, but it is more important to have competent people working together effectively. Good documentation is useful in helping people to understand how the software is built and how to use it, but the main point of development is to create software, not documentation. A contract is important but is not a substitute for working closely with customers to discover what they need. A project plan is important, but it must not be too rigid to accommodate changes in technology or the environment, stakeholders' priorities, and people's understanding of the problem and its solution. Introducing the manifesto on behalf of the Agile Alliance, Jim Highsmith said, The Agile movement is not anti-methodology, in fact many of us want to restore credibility to the word methodology. We want to restore a balance. We embrace modeling, but not in order to file some diagram in a dusty corporate repository. We embrace documentation, but not hundreds of pages of never-maintained and rarely-used tomes. We plan, but recognize the limits of planning in a turbulent environment. Those who would brand proponents of XP or SCRUM or any of the other Agile Methodologies as \"hackers\" are ignorant of both the methodologies and the original definition of the term hacker. \u2014\u200aJim Highsmith, History: The Agile Manifesto [ 24 ] Principles [ edit ] The values are based on these principles: [ 25 ] Customer satisfaction by early and continuous delivery of valuable software. Welcome changing requirements, even in late development. Deliver working software frequently (weeks rather than months). Close, daily cooperation between business people and developers. Projects are built around motivated individuals, who should be trusted. Face-to-face conversation is the best form of communication (co-location). Working software is the primary measure of progress. Sustainable development, able to maintain a constant pace. Continuous attention to technical excellence and good design. Simplicity\u2014the art of maximizing the amount of work not done\u2014is essential. Best architectures , requirements, and designs emerge from self-organizing teams. Regularly, the team reflects on how to become more effective, and adjusts accordingly. Overview [ edit ] Iterative, incremental, and evolutionary [ edit ] Most agile development methods break product development work into small increments that minimize the amount of up-front planning and design. Iterations, or sprints, are short time frames ( timeboxes ) [ 26 ] that typically last from one to four weeks. [ 27 ] :\u200a20 Each iteration involves a cross-functional team working in all functions: planning , analysis , design , coding , unit testing , and acceptance testing . At the end of the iteration a working product is demonstrated to stakeholders. This minimizes overall risk and allows the product to adapt to changes quickly. [ 28 ] [ 29 ] An iteration might not add enough functionality to warrant a market release, but the goal is to have an available release (with minimal bugs ) at the end of each iteration. [ 30 ] Through incremental development, products have room to \" fail often and early \" throughout each iterative phase instead of drastically on a final release date. [ 31 ] Multiple iterations might be required to release a product or new features. Working software is the primary measure of progress. [ 25 ] Efficient and face-to-face communication [ edit ] The 6th principle of the agile manifesto for software development states, \"The most efficient and effective method of conveying information to and within a development team is face-to-face conversation\". The manifesto, written in 2001 when video conferencing was not widely used, states this in relation to the communication of information, not necessarily that a team should be co-located. The principle of co-location is that co-workers on the same team should be situated together to better establish the identity as a team and to improve communication. [ 32 ] This enables face-to-face interaction , ideally in front of a whiteboard, that reduces the cycle time typically taken when questions and answers are mediated through phone, persistent chat , wiki, or email. [ 33 ] With the widespread adoption of remote working during the COVID-19 pandemic and changes to tooling, more studies have been conducted [ 34 ] around co-location and distributed working which show that co-location is increasingly less relevant. No matter which development method is followed, every team should include a customer representative (known as product owner in Scrum ). This representative is agreed by stakeholders to act on their behalf and makes a personal commitment to being available for developers to answer questions throughout the iteration. At the end of each iteration, the project stakeholders together with the customer representative review progress and re-evaluate priorities with a view to optimizing the return on investment (ROI) and ensuring alignment with customer needs and company goals. The importance of stakeholder satisfaction, detailed by frequent interaction and review at the end of each phase, is why the approach is often denoted as a customer-centered methodology . [ 35 ] Information radiator [ edit ] In agile software development, an information radiator is a (normally large) physical display, board with sticky notes or similar, located prominently near the development team, where passers-by can see it. [ 36 ] It presents an up-to-date summary of the product development status. [ 37 ] A build light indicator may also be used to inform a team about the current status of their product development. Very short feedback loop and adaptation cycle [ edit ] A common characteristic in agile software development is the daily stand-up (known as daily scrum in the Scrum framework). In a brief session (e.g., 15 minutes), team members review collectively how they are progressing toward their goal and agree whether they need to adapt their approach. To keep to the agreed time limit, teams often use simple coded questions (such as what they completed the previous day, what they aim to complete that day, and whether there are any impediments or risks to progress), and delay detailed discussions and problem resolution until after the stand-up. [ 38 ] Quality focus [ edit ] Pair programming , an agile development technique used in XP Specific tools and techniques, such as continuous integration , automated unit testing , pair programming , test-driven development , design patterns , behavior-driven development , domain-driven design , code refactoring and other techniques are often used to improve quality and enhance product development agility. [ 39 ] This is predicated on designing and building quality in from the beginning and being able to demonstrate software for customers at any point, or at least at the end of every iteration. [ 40 ] Philosophy [ edit ] Compared to traditional software engineering, agile software development mainly targets complex systems and product development with dynamic, indeterministic and non-linear properties . Accurate estimates, stable plans, and predictions are often hard to get in early stages, and confidence in them is likely to be low. Agile practitioners use their free will to reduce the \" leap of faith \" that is needed before any evidence of value can be obtained. [ 41 ] Requirements and design are held to be emergent . Big up-front specifications would probably cause a lot of waste in such cases, i.e., are not economically sound. These basic arguments and previous industry experiences , learned from years of successes and failures, have helped shape agile development's favor of adaptive, iterative and evolutionary development. [ 42 ] Adaptive vs. predictive [ edit ] Development methods exist on a continuum from adaptive to predictive . [ 43 ] Agile software development methods lie on the adaptive side of this continuum. One key of adaptive development methods is a rolling wave approach to schedule planning, which identifies milestones but leaves flexibility in the path to reach them, and also allows for the milestones themselves to change. [ 44 ] Adaptive methods focus on adapting quickly to changing realities. When the needs of a project change, an adaptive team changes as well. An adaptive team has difficulty describing exactly what will happen in the future. The further away a date is, the more vague an adaptive method is about what will happen on that date. An adaptive team cannot report exactly what tasks they will do next week, but only which features they plan for next month. When asked about a release six months from now, an adaptive team might be able to report only the mission statement for the release, or a statement of expected value vs. cost. Predictive methods, in contrast, focus on analyzing and planning the future in detail and cater for known risks. In the extremes, a predictive team can report exactly what features and tasks are planned for the entire length of the development process. Predictive methods rely on effective early phase analysis, and if this goes very wrong, the project may have difficulty changing direction. Predictive teams often institute a change control board to ensure they consider only the most valuable changes. Risk analysis can be used to choose between adaptive ( agile or value-driven ) and predictive ( plan-driven ) methods. [ 45 ] Barry Boehm and Richard Turner suggest that each side of the continuum has its own home ground , as follows: [ 46 ] Home grounds of different development methods Value-driven methods (agile) Plan-driven methods (waterfall) Formal methods Low criticality High criticality Extreme criticality Senior developers Junior developers(?) Senior developers Requirements change often Requirements do not change often Limited requirements, limited features, see Wirth's law [ clarification needed ] Small number of developers Large number of developers Requirements that can be modeled Culture that responds to change Culture that demands order Extreme quality Agile vs. waterfall [ edit ] One of the differences between agile software development methods and waterfall is the approach to quality and testing. In the waterfall model , work moves through software development life cycle (SDLC) phases\u2014with one phase being completed before another can start\u2014hence the testing phase is separate and follows a build phase . In agile software development, however, testing is completed in the same iteration as programming. Because testing is done in every iteration\u2014which develops a small piece of the software\u2014users can frequently use those new pieces of software and validate the value. After the users know the real value of the updated piece of software, they can make better decisions about the software's future. Having a value retrospective and software re-planning session in each iteration\u2014 Scrum typically has iterations of just two weeks\u2014helps the team continuously adapt its plans so as to maximize the value it delivers. This follows a pattern similar to the plan-do-check-act (PDCA) cycle, as the work is planned , done , checked (in the review and retrospective), and any changes agreed are acted upon. This iterative approach supports a product rather than a project mindset. This provides greater flexibility throughout the development process; whereas on projects the requirements are defined and locked down from the very beginning, making it difficult to change them later. Iterative product development allows the software to evolve in response to changes in business environment or market requirements. Code vs. documentation [ edit ] In a letter to IEEE Computer , Steven Rakitin expressed cynicism about agile software development, calling it \"yet another attempt to undermine the discipline of software engineering\" and translating \"working software over comprehensive documentation\" as \"we want to spend all our time coding. Remember, real programmers don't write documentation.\" [ 47 ] This is disputed by proponents of agile software development, who state that developers should write documentation if that is the best way to achieve the relevant goals, but that there are often better ways to achieve those goals than writing static documentation. [ 48 ] Scott Ambler states that documentation should be \"just barely good enough\" (JBGE), [ 49 ] that too much or comprehensive documentation would usually cause waste, and developers rarely trust detailed documentation because it's usually out of sync with code, [ 48 ] while too little documentation may also cause problems for maintenance, communication, learning and knowledge sharing. Alistair Cockburn wrote of the Crystal Clear method: Crystal considers development a series of co-operative games, and intends that the documentation is enough to help the next win at the next game. The work products for Crystal include use cases, risk list, iteration plan, core domain models, and design notes to inform on choices...however there are no templates for these documents and descriptions are necessarily vague, but the objective is clear, just enough documentation for the next game. I always tend to characterize this to my team as: what would you want to know if you joined the team tomorrow. \u2014\u200aAlistair Cockburn [ 50 ] Methods [ edit ] Software development life cycle support [ 51 ] Agile unified process (AUP) is based on unified process (an iterative and incremental software development process framework). Agile software development methods support a broad range of the software development life cycle . [ 51 ] Some methods focus on the practices (e.g., XP , pragmatic programming , agile modeling), while some focus on managing the flow of work (e.g., Scrum, Kanban). Some support activities for requirements specification and development (e.g., FDD ), while some seek to cover the full development life cycle (e.g., DSDM , RUP ). Notable agile software development frameworks include: Framework Main contributor(s) Adaptive software development (ASD) Jim Highsmith , Sam Bayer Agile modeling Scott Ambler , Robert Cecil Martin Agile unified process (AUP) Scott Ambler Disciplined agile delivery Scott Ambler Dynamic systems development method (DSDM) Jennifer Stapleton Extreme programming (XP) Kent Beck , Robert Cecil Martin Feature-driven development (FDD) Jeff De Luca Lean software development Mary Poppendieck, Tom Poppendieck Lean startup Eric Ries Kanban Taiichi Ohno Rapid application development (RAD) James Martin Scrum Ken Schwaber , Jeff Sutherland Scrumban Agile software development practices [ edit ] Agile software development is supported by a number of concrete practices, covering areas like requirements, design, modeling, coding, testing, planning, risk management, process, quality, etc. Some notable agile software development practices include: [ 52 ] Practice Main contributor(s) Acceptance test-driven development (ATDD) Ken Pugh Agile modeling Scott Ambler Agile testing Lisa Crispin, Janet Gregory Backlogs (Product and Sprint) Ken Schwaber , Jeff Sutherland Behavior-driven development (BDD) Dan North, Liz Keogh Continuous integration (CI) Grady Booch Cross-functional team Daily stand-up / Daily Scrum James O Coplien Domain-driven design (DDD) Eric Evans Iterative and incremental development (IID) Pair programming Kent Beck Planning poker James Grenning, Mike Cohn Refactoring Martin Fowler Retrospective Esther Derby, Diana Larsen, Ben Linders, Luis Gon\u00e7alves Scrum events (sprint planning, sprint review and retrospective) Ken Schwaber , Jeff Sutherland Specification by example Story-driven modeling Albert Z\u00fcndorf Test-driven development (TDD) Kent Beck Timeboxing User story Alistair Cockburn Velocity tracking Acceptance test-driven development [ edit ] This paragraph is an excerpt from Acceptance test-driven development . [ edit ] Acceptance test\u2013driven development (ATDD) is a development methodology based on communication between the business customers, the developers, and the testers. [ 53 ] ATDD encompasses many of the same practices as specification by example (SBE), [ 54 ] [ 55 ] behavior-driven development (BDD), [ 56 ] example-driven development (EDD), [ 57 ] and support-driven development also called story test\u2013driven development (SDD). [ 58 ] All these processes aid developers and testers in understanding the customer's needs prior to implementation and allow customers to be able to converse in their own domain language. Agile modeling [ edit ] This paragraph is an excerpt from Agile modeling . [ edit ] Agile modeling (AM) is a methodology for modeling and documenting software systems based on best practices. It is a collection of values and principles that can be applied on an (agile) software development project. This methodology is more flexible than traditional modeling methods, making it a better fit in a fast-changing environment. [ 59 ] It is part of the agile software development tool kit. Agile testing [ edit ] This paragraph is an excerpt from Agile testing . [ edit ] Agile testing is a software testing practice that follows the principles of agile software development. Agile testing involves all members of a cross-functional agile team, with special expertise contributed by testers, to ensure delivering the business value desired by the customer at frequent intervals, working at a sustainable pace. Specification by example is used to capture examples of desired and undesired behavior and guide coding. Backlogs [ edit ] This paragraph is an excerpt from Product backlog . [ edit ] Within agile project management , product backlog refers to a prioritized list of functionality which a product should contain. It is sometimes referred to as a to-do list , [ 60 ] and is considered an 'artifact' (a form of documentation) within the scrum software development framework. [ 61 ] The product backlog is referred to with different names in different project management frameworks, such as product backlog in scrum, [ 61 ] [ 62 ] work item list in disciplined agile , [ 62 ] [ 63 ] and option pool in lean . [ 62 ] In the scrum framework, creation and continuous maintenance of the product backlog is part of the responsibility of the product owner . [ 64 ] Behavior-driven development [ edit ] This paragraph is an excerpt from Behavior-driven development . [ edit ] Behavior-driven development (BDD) involves naming software tests using domain language to describe the behavior of the code . Continuous integration [ edit ] This paragraph is an excerpt from Continuous integration . [ edit ] Continuous integration (CI) is the practice of integrating source code changes frequently and ensuring that the integrated codebase is in a workable state. Typically, developers merge changes to an integration branch , and an automated system builds and tests the software system . [ 65 ] Often, the automated process runs on each commit or runs on a schedule such as once a day. Grady Booch first proposed the term CI in 1991 , [ 66 ] although he did not advocate integrating multiple times a day, but later, CI came to include that aspect. [ 67 ] Cross-functional team [ edit ] This paragraph is an excerpt from Cross-functional team . [ edit ] A cross-functional team (XFN), also known as a multidisciplinary team or interdisciplinary team, [ 68 ] [ 69 ] [ 70 ] is a group of people with different functional expertise working toward a common goal. [ 71 ] It may include people from finance , marketing , operations , and human resources departments. Typically, it includes employees from all levels of an organization. Members may also come from outside an organization (in particular, from suppliers, key customers, or consultants). Daily stand-up [ edit ] This paragraph is an excerpt from Stand-up meeting . [ edit ] A stand-up meeting (stum [ citation needed ] ) is a meeting in which attendees typically participate while standing , usually at around 10am. The discomfort of standing for long periods is intended to keep the meetings short. Method tailoring [ edit ] In the literature, different terms refer to the notion of method adaptation, including 'method tailoring', 'method fragment adaptation' and 'situational method engineering'. Method tailoring is defined as: A process or capability in which human agents determine a system development approach for a specific project situation through responsive changes in, and dynamic interplays between contexts, intentions, and method fragments. \u2014\u200aMehmet Nafiz Aydin et al., An Agile Information Systems Development Method in use [ 72 ] Situation-appropriateness should be considered as a distinguishing characteristic between agile methods and more plan-driven software development methods, with agile methods allowing product development teams to adapt working practices according to the needs of individual products. [ 73 ] [ 72 ] Potentially, most agile methods could be suitable for method tailoring, [ 51 ] such as DSDM tailored in a CMM context. [ 74 ] and XP tailored with the Rule Description Practices (RDP) technique. [ 75 ] Not all agile proponents agree, however, with Schwaber noting \"that is how we got into trouble in the first place, thinking that the problem was not having a perfect methodology. Efforts [should] center on the changes [needed] in the enterprise\". [ 76 ] Bas Vodde reinforced this viewpoint, suggesting that unlike traditional, large methodologies that require you to pick and choose elements, Scrum provides the basics on top of which you add additional elements to localize and contextualize its use. [ 77 ] Practitioners seldom use system development methods , or agile methods specifically, by the book, often choosing to omit or tailor some of the practices of a method in order to create an in-house method. [ 78 ] In practice, methods can be tailored using various tools. Generic process modeling languages such as Unified Modeling Language can be used to tailor software development methods. However, dedicated tools for method engineering such as the Essence Theory of Software Engineering of SEMAT also exist. [ 79 ] Large-scale, offshore and distributed [ edit ] Agile software development has been widely seen as highly suited to certain types of environments, including small teams of experts working on greenfield projects , [ 46 ] [ 80 ] and the challenges and limitations encountered in the adoption of agile software development methods in a large organization with legacy infrastructure are well-documented and understood. [ 81 ] In response, a range of strategies and patterns has evolved for overcoming challenges with large-scale development efforts (>20 developers) [ 82 ] [ 83 ] or distributed (non-colocated) development teams, [ 84 ] [ 85 ] amongst other challenges; and there are now several recognized frameworks that seek to mitigate or avoid these challenges. There are many conflicting viewpoints on whether all of these are effective or indeed fit the definition of agile development, and this remains an active and ongoing area of research. [ 82 ] [ 86 ] When agile software development is applied in a distributed setting (with teams dispersed across multiple business locations), it is commonly referred to as distributed agile software development . The goal is to leverage the unique benefits offered by each approach. Distributed development allows organizations to build software by strategically setting up teams in different parts of the globe, virtually building software round-the-clock (more commonly referred to as follow-the-sun model). On the other hand, agile development provides increased transparency, continuous feedback, and more flexibility when responding to changes. Regulated domains [ edit ] Agile software development methods were initially seen as best suitable for non-critical product developments, thereby excluded from use in regulated domains such as medical devices , pharmaceutical, financial, nuclear systems, automotive, and avionics sectors, etc. However, in the last several years, there have been several initiatives for the adaptation of agile methods for these domains. [ 87 ] [ 88 ] [ 89 ] [ 90 ] [ 91 ] There are numerous standards that may apply in regulated domains, including ISO 26262 , ISO 9000 , ISO 9001 , and ISO/IEC 15504 .\nA number of key concerns are of particular importance in regulated domains: [ 92 ] Quality assurance (QA): Systematic and inherent quality management underpinning a controlled professional process and reliability and correctness of product. Safety and security: Formal planning and risk management to mitigate safety risks for users and securely protecting users from unintentional and malicious misuse. Traceability : Documentation providing auditable evidence of regulatory compliance and facilitating traceability and investigation of problems. Verification and validation (V&V): Embedded throughout the software development process (e.g. user requirements specification, functional specification, design specification, code review, unit tests, integration tests, system tests). Experience and adoption [ edit ] Although agile software development methods can be used with any programming paradigm or language in practice, they were originally closely associated with object-oriented environments such as Smalltalk, Lisp and later Java, C#. The initial adopters of agile methods were usually small to medium-sized teams working on unprecedented systems with requirements that were difficult to finalize and likely to change as the system was being developed. This section describes common problems that organizations encounter when they try to adopt agile software development methods as well as various techniques to measure the quality and performance of agile teams. [ 93 ] Measuring agility [ edit ] Internal assessments [ edit ] The Agility measurement index , amongst others, rates developments against five dimensions of product development (duration, risk, novelty, effort, and interaction). [ 94 ] Other techniques are based on measurable goals [ 95 ] and one study suggests that velocity can be used as a metric of agility. There are also agile self-assessments to determine whether a team is using agile software development practices (Nokia test, [ 96 ] Karlskrona test, [ 97 ] 42 points test). [ 98 ] Public surveys [ edit ] One of the early studies reporting gains in quality, productivity, and business satisfaction by using agile software developments methods was a survey conducted by Shine Technologies from November 2002 to January 2003. [ 99 ] A similar survey, the State of Agile , is conducted every year starting in 2006 with thousands of participants from around the software development community. This tracks trends on the perceived benefits of agility, lessons learned, and good practices. Each survey has reported increasing numbers saying that agile software development helps them deliver software faster, improves their ability to manage changing customer priorities, and increases their productivity. [ 100 ] Surveys have also consistently shown better results with agile product development methods compared to classical project management. [ 101 ] [ 102 ] In balance, there are reports that some feel that agile development methods are still too young to enable extensive academic research of their success. [ 103 ] Common agile software development pitfalls [ edit ] Organizations and teams implementing agile software development often face difficulties transitioning from more traditional methods such as waterfall development , such as teams having an agile process forced on them. [ 104 ] These are often termed agile anti-patterns or more commonly agile smells . Below are some common examples: Lack of overall product design [ edit ] A goal of agile software development is to focus more on producing working software and less on documentation. This is in contrast to waterfall models where the process is often highly controlled and minor changes to the system require significant revision of supporting documentation. However, this does not justify completely doing without any analysis or design at all. Failure to pay attention to design can cause a team to proceed rapidly at first, but then to require significant rework as they attempt to scale up the system. One of the key features of agile software development is that it is iterative. When done correctly, agile software development allows the design to emerge as the system is developed and helps the team discover commonalities  and opportunities for re-use. [ 105 ] Adding stories to an iteration in progress [ edit ] In agile software development, stories (similar to use case descriptions) are typically used to define requirements and an iteration is a short period of time during which the team commits to specific goals. [ 106 ] Adding stories to an iteration in progress is detrimental to a good flow of work. These should be added to the product backlog and prioritized for a subsequent iteration or in rare cases the iteration could be cancelled. [ 107 ] This does not mean that a story cannot expand. Teams must deal with new information, which may produce additional tasks for a story. If the new information prevents the story from being completed during the iteration, then it should be carried over to a subsequent iteration. However, it should be prioritized against all remaining stories, as the new information may have changed the story's original priority. Lack of sponsor support [ edit ] Agile software development is often implemented as a grassroots effort in organizations by software development teams trying to optimize their development processes and ensure consistency in the software development life cycle. By not having sponsor support, teams may face difficulties and resistance from business partners, other development teams and management. Additionally, they may suffer without appropriate funding and resources. [ 108 ] This increases the likelihood of failure. [ 109 ] Insufficient training [ edit ] A survey performed by VersionOne found respondents cited insufficient training as the most significant cause for failed agile implementations [ 110 ] Teams have fallen into the trap of assuming the reduced processes of agile software development compared to other approaches such as waterfall means that there are no actual rules for agile software development. [ citation needed ] Product owner role is not properly filled [ edit ] The product owner is responsible for representing the business in the development activity and is often the most demanding role. [ 111 ] A common mistake is to fill the product owner role with someone from the development team. This requires the team to make its own decisions on prioritization without real feedback from the business. They try to solve business issues internally or delay work as they reach outside the team for direction. This often leads to distraction and a breakdown in collaboration. [ 112 ] Teams are not focused [ edit ] Agile software development requires teams to meet product commitments, which means they should focus on work for only that product. However, team members who appear to have spare capacity are often expected to take on other work, which makes it difficult for them to help complete the work to which their team had committed. [ 113 ] Excessive preparation/planning [ edit ] Teams may fall into the trap of spending too much time preparing or planning. This is a common trap for teams less familiar with agile software development where the teams feel obliged to have a complete understanding and specification of all stories. Teams should be prepared to move forward with only those stories in which they have confidence, then during the iteration continue to discover and prepare work for subsequent iterations (often referred to as backlog refinement or grooming). Problem-solving in the daily standup [ edit ] A daily standup should be a focused, timely meeting where all team members disseminate information. If problem-solving occurs, it often can involve only certain team members and potentially is not the best use of the entire team's time. If during the daily standup the team starts diving into problem-solving, it should be set aside until a sub-team can discuss, usually immediately after the standup completes. [ 114 ] Assigning tasks [ edit ] One of the intended benefits of agile software development is to empower the team to make choices, as they are closest to the problem. Additionally, they should make choices as close to implementation as possible, to use more timely information in the decision. If team members are assigned tasks by others or too early in the process, the benefits of localized and timely decision making can be lost. [ 115 ] Being assigned work also constrains team members into certain roles (for example, team member A must always do the database work), which limits opportunities for cross-training. [ 115 ] Team members themselves can choose to take on tasks that stretch their abilities and provide cross-training opportunities. Scrum master as a contributor [ edit ] In the Scrum framework, which claims to be consistent with agile values and principles, the scrum master role is accountable for ensuring the scrum process is followed and for coaching the scrum team through that process. A common pitfall is for a scrum master to act as a contributor. While not prohibited by the Scrum framework, the scrum master needs to ensure they have the capacity to act in the role of scrum master first and not work on development tasks. A scrum master's role is to facilitate the process rather than create the product. [ 116 ] Having the scrum master also multitasking may result in too many context switches to be productive. Additionally, as a scrum master is responsible for ensuring roadblocks are removed so that the team can make forward progress, the benefit gained by individual tasks moving forward may not outweigh roadblocks that are deferred due to lack of capacity. [ 117 ] Lack of test automation [ edit ] Further information: Test automation Due to the iterative nature of agile development, multiple rounds of testing are often needed. Automated testing helps reduce the impact of repeated unit, integration, and regression tests and frees developers and testers to focus on higher value work. [ 118 ] Test automation also supports continued refactoring required by iterative software development. Allowing a developer to quickly run tests to confirm refactoring has not modified the functionality of the application may reduce the workload and increase confidence that cleanup efforts have not introduced new defects. Allowing technical debt to build up [ edit ] Further information: Technical debt Focusing on delivering new functionality may result in increased technical debt . The team must allow themselves time for defect remediation and refactoring. Technical debt hinders planning abilities by increasing the amount of unscheduled work as production defects distract the team from further progress. [ 119 ] As the system evolves it is important to refactor . [ 120 ] Over time the lack of constant maintenance causes increasing defects and development costs. [ 119 ] Attempting to take on too much in an iteration [ edit ] A common misconception is that agile software development allows continuous change, however an iteration backlog is an agreement of what work can be completed during an iteration. [ 121 ] Having too much work-in-progress (WIP) results in inefficiencies such as context-switching and queueing. [ 122 ] The team must avoid feeling pressured into taking on additional work. [ 123 ] Fixed time, resources, scope, and quality [ edit ] Agile software development fixes time (iteration duration), quality, and ideally resources in advance (though maintaining fixed resources may be difficult if developers are often pulled away from tasks to handle production incidents), while the scope remains variable. The customer or product owner often pushes for a fixed scope for an iteration. However, teams should be reluctant to commit to the locked time, resources and scope (commonly known as the project management triangle ). Efforts to add scope to the fixed time and resources of agile software development may result in decreased quality. [ 124 ] Developer burnout [ edit ] Due to the focused pace and continuous nature of agile practices, there is a heightened risk of burnout among members of the delivery team. [ 125 ] Agile management [ edit ] Main article: Agile management Agile project management is an iterative development process, where feedback is continuously gathered from users and stakeholders to create the right user experience.  Different methods can be used to perform an agile process, these include scrum , extreme programming , lean and kanban . [ 126 ] The term agile management is applied to an iterative, incremental method of managing the design and build activities of engineering, information technology and other business areas that aim to provide new product or service development in a highly flexible and interactive manner, based on the principles expressed in the Manifesto for Agile Software Development . [ 127 ] Agile project management metrics help reduce confusion, identify weak points, and measure team's performance throughout the development cycle. Supply chain agility is the ability of a supply chain to cope with uncertainty and variability on offer and demand. An agile supply chain can increase and reduce its capacity rapidly, so it can adapt to a fast-changing customer demand. Finally, strategic agility is the ability of an organisation to change its course of action as its environment is evolving. The key for strategic agility is to recognize external changes early enough and to allocate resources to adapt to these changing environments. [ 126 ] Agile X techniques may also be called extreme project management . It is a variant of iterative life cycle [ 128 ] where deliverables are submitted in stages. The main difference between agile and iterative development is that agile methods complete small portions of the deliverables in each delivery cycle (iteration), [ 129 ] while iterative methods evolve the entire set of deliverables over time, completing them near the end of the project. Both iterative and agile methods were developed as a reaction to various obstacles that developed in more sequential forms of project organization. For example, as technology projects grow in complexity, end users tend to have difficulty defining the long-term requirements without being able to view progressive prototypes. Projects that develop in iterations can constantly gather feedback to help refine those requirements. Agile management also offers a simple framework promoting communication and reflection on past work amongst team members. [ 130 ] Teams who were using traditional waterfall planning and adopted the agile way of development typically go through a transformation phase and often take help from agile coaches who help guide the teams through a smoother transformation. There are typically two styles of agile coaching: push-based and pull-based agile coaching. Here a \"push-system\" can refer to an upfront estimation of what tasks can be fitted into a sprint (pushing work) e.g. typical with scrum; whereas a \"pull system\" can refer to an environment where tasks are only performed when capacity is available. [ 131 ] Agile management approaches have also been employed and adapted to the business and government sectors. For example, within the federal government of the United States , the United States Agency for International Development (USAID) is employing a collaborative project management approach that focuses on incorporating collaborating, learning and adapting (CLA) strategies to iterate and adapt programming. [ 132 ] Agile methods are mentioned in the Guide to the Project Management Body of Knowledge ( PMBOK Guide 6th Edition ) under the Product Development Lifecycle definition: Within a project life cycle, there are generally one or more phases that are associated with the development of the product, service, or result. These are called a development life cycle (...) Adaptive life cycles are agile, iterative, or incremental. The detailed scope is defined and approved before the start of an iteration. Adaptive life cycles are also referred to as agile or change-driven life cycles. [ 133 ] Applications outside software development [ edit ] Agile Brazil 2014 conference According to Jean-Loup Richet (research fellow at ESSEC Institute for Strategic Innovation & Services) \"this approach can be leveraged effectively for non-software products and for project management in general, especially in areas of innovation and uncertainty.\" The result is a product or project that best meets current customer needs and is delivered with minimal costs, waste, and time, enabling companies to achieve bottom line gains earlier than via traditional approaches. [ 134 ] Agile software development methods have been extensively used for development of software products and some of them use certain characteristics of software, such as object technologies . [ 135 ] However, these techniques can be applied to the development of non-software products, such as computers, medical devices, food, clothing, and music. [ 136 ] Agile software development methods have been used in non-development IT infrastructure deployments and migrations . Some of the wider principles of agile software development have also found application in general management [ 137 ] (e.g., strategy, governance, risk, finance) under the terms business agility or agile business management. Agile software methodologies have also been adopted for use with the learning engineering process, an iterative data-informed process that applies human-centered design , and data informed decision-making to support learners and their development. [ 138 ] Agile software development paradigms can be used in other areas of life such as raising children. Its success in child development might be founded on some basic management principles: communication, adaptation, and awareness. In a TED Talk , Bruce Feiler shared how he applied basic agile paradigms to household management and raising children. [ 139 ] Criticism [ edit ] Agile practices have been cited as potentially inefficient in large organizations and certain types of development. [ 140 ] Many organizations believe that agile software development methodologies are too extreme and adopt a hybrid approach [ 141 ] that mixes elements of agile software development and plan-driven approaches. [ 142 ] Some methods, such as dynamic systems development method (DSDM), attempt this in a disciplined way, without sacrificing fundamental principles. The increasing adoption of agile practices has also been criticized as being a management fad that simply describes existing good practices under new jargon, promotes a one-size-fits-all mindset towards development strategies, and wrongly emphasizes method over results. [ 143 ] Alistair Cockburn organized a celebration of the 10th anniversary of the Manifesto for Agile Software Development in Snowbird, Utah on 12 February 2011, gathering some 30+ people who had been involved at the original meeting and since. A list of about 20 elephants in the room (\"undiscussable\" agile topics/issues) were collected, including aspects: the alliances, failures and limitations of agile software development practices and context (possible causes: commercial interests, decontextualization, no obvious way to make progress based on failure, limited objective evidence, cognitive biases and reasoning fallacies), politics and culture. [ 144 ] As Philippe Kruchten wrote: The agile movement is in some ways a bit like a teenager: very self-conscious, checking constantly its appearance in a mirror, accepting few criticisms, only interested in being with its peers, rejecting en bloc all wisdom from the past, just because it is from the past, adopting fads and new jargon, at times cocky and arrogant. But I have no doubts that it will mature further, become more open to the outside world, more reflective, and therefore, more effective. \u2014\u200aPhilippe Kruchten [ 144 ] The \"Manifesto\" may have had a negative impact on higher education management and leadership, where it suggested to administrators that slower traditional and deliberative processes should be replaced with more \"nimble\" ones. The concept rarely found acceptance among university faculty. [ 145 ] Another criticism is that in many ways, agile management and traditional management practices end up being in opposition to one another. A common criticism of this practice is that the time spent attempting to learn and implement the practice is too costly, despite potential benefits. A transition from traditional management to agile management requires total submission to agile and a firm commitment from all members of the organization to seeing the process through. Issues like unequal results across the organization, too much change for employees to handle, or a lack of guarantees at the end of the transformation are just a few examples. [ 146 ] See also [ edit ] Fail fast (business) , a related subject in business management Kanban Agile leadership Agile contracts References [ edit ] ^ \"What is Agile?\" . Agile Alliance . 29 June 2015 . Retrieved 16 July 2024 . ^ a b c Kent Beck ; James Grenning; Robert C. Martin ; Mike Beedle; Jim Highsmith ; Steve Mellor ; Arie van Bennekum; Andrew Hunt ; Ken Schwaber ; Alistair Cockburn ; Ron Jeffries ; Jeff Sutherland ; Ward Cunningham ; Jon Kern; Dave Thomas ; Martin Fowler ; Brian Marick (2001). \"Manifesto for Agile Software Development\" . Agile Alliance . Retrieved 14 June 2010 . ^ a b Larman, Craig (2004). Agile and Iterative Development: A Manager's Guide . Addison-Wesley. p.\u00a027. ISBN 978-0-13-111155-4 . ^ Rally (2010). \"Agile With a Capital \"A\" Vs. agile With a Lowercase \"a\" \" . Archived from the original on 5 January 2016 . Retrieved 9 September 2015 . ^ Collier 2011 . ^ \"What is Agile Software Development?\" . Agile Alliance. 8 June 2013 . Retrieved 4 April 2015 . ^ Dyb\u00e5, Tore; Dings\u00f8yr, Torgeir (1 August 2008). \"Empirical studies of agile software development: A systematic review\". Information and Software Technology . 50 ( 9\u2013 10): 833\u2013 859. doi : 10.1016/j.infsof.2008.01.006 . ISSN 0950-5849 . S2CID 2244031 . ^ Lee, Gwanhoo; Xia, Weidong (2010). \"Toward Agile: An Integrated Analysis of Quantitative and Qualitative Field Data on Software Development Agility\". MIS Quarterly . 34 (1): 87\u2013 114. doi : 10.2307/20721416 . JSTOR 20721416 . S2CID 26477249 . ^ Kroll, J.; Richardson, I.; Prikladnicki, R.; Audy, J. L. (2018). \"Empirical evidence in follow the Sun software development: A systematic mapping study\" . Information and Software Technology . 93 : 30\u2013 44. doi : 10.1016/j.infsof.2017.08.011 . hdl : 10344/6233 . ^ Gerald M. Weinberg , as quoted in Larman & Basili 2003 , pp.\u00a047\u201356: \"We were doing incremental development as early as 1957 in Los Angeles, under the direction of Bernie Dimsdale at IBM's Service Bureau Corporation . He was a colleague of John von Neumann , so perhaps he learned it there, or assumed it as totally natural. I do remember Herb Jacobs (primarily, though we all participated) developing a large simulation for Motorola, where the technique used was, as far as I can tell\u00a0... All of us, as far as I can remember, thought waterfalling of a huge project was rather stupid, or at least ignorant of the realities. I think what the waterfall description did for us was make us realize that we were doing something else, something unnamed except for 'software development. ' \" ^ \"Evolutionary Project Management (Original page, external archive)\" . Gilb. Archived from the original on 27 March 2016 . Retrieved 30 April 2017 . ^ \"Evolutionary Project Management (New page)\" . graphMetrix . Gilb . Retrieved 30 April 2017 . ^ Edmonds, E. A. (1974). \"A Process for the Development of Software for Nontechnical Users as an Adaptive System\". General Systems . 19 : 215\u2013 18. ^ Gilb, Tom (1 April 1981). \"Evolutionary development\". ACM SIGSOFT Software Engineering Notes . 6 (2): 17. doi : 10.1145/1010865.1010868 . S2CID 33902347 . ^ Swamidass, P. M., ed. (2000), \"Heavyweight project organizationHEAVYWEIGHT PROJECT ORGANIZATION\" , Encyclopedia of Production and Manufacturing Management , Boston, MA: Springer US, pp. 261\u2013 262, doi : 10.1007/1-4020-0612-8_400 , ISBN 978-1-4020-0612-8 , retrieved 22 June 2022 ^ Martin, James (1991). Rapid Application Development . Macmillan. ISBN 978-0-02-376775-3 . ^ Kerr, James M.; Hunter, Richard (1993). Inside RAD: How to Build a Fully Functional System in 90 Days or Less . McGraw-Hill. p.\u00a03. ISBN 978-0-07-034223-1 . ^ Iacocca Institute (1991). \"21st Century Manufacturing Enterprise Strategy: An Industry Led View\". Iacocca Institute, Lehigh University, Bethlehem, PA. ^ Presley, A., J. Mills and D. Liles (1995). \"Agile Aerospace Manufacturing\". Nepcon East 1995, Boston. ^ Sanchez, Luis (November 2010). \"A Review of Agile Manufacturing Systems\" . International Journal of Production Research (39(16):3561-3600). ^ Anderson, David (2005). \"Declaration of Interdependence\" . Archived from the original on 27 January 2018 . Retrieved 4 October 2018 . ^ McDonald, Kent (1 November 2016). \"How You Can Help Agile Alliance Help You\" . Agile Alliance Blog . Retrieved 4 July 2017 . ^ \"Examining the Agile Manifesto\" . Ambysoft Inc . Retrieved 6 April 2011 . ^ Jim Highsmith (2001). \"History: The Agile Manifesto\" . agilemanifesto.org. ^ a b Kent Beck ; James Grenning; Robert C. Martin ; Mike Beedle; Jim Highsmith ; Steve Mellor ; Arie van Bennekum; Andrew Hunt ; Ken Schwaber ; Alistair Cockburn ; Ron Jeffries ; Jeff Sutherland ; Ward Cunningham ; Jon Kern; Dave Thomas ; Martin Fowler ; Brian Marick (2001). \"Principles behind the Agile Manifesto\" . Agile Alliance. Archived from the original on 14 June 2010 . Retrieved 6 June 2010 . ^ Project Management Institute 2021 , 2.3.3 Development Approaches. ^ Rubin 2013 . ^ Project Management Institute 2021 , \u00a73.12 Enable Change to Achieve the Envisioned Future State. ^ Moran, A. (2014). Agile Risk Management . Springer Verlag. ISBN 978-3319050072 . ^ Beck, Kent (1999). \"Embracing Change with Extreme Programming\". Computer . 32 (10): 70\u2013 77. Bibcode : 1999Compr..32j..70B . doi : 10.1109/2.796139 . ^ Mergel, Ines (July 2016). \"Agile innovation management in government: A research agenda\" . Government Information Quarterly . 33 (3): 516\u2013 523. doi : 10.1016/j.giq.2016.07.004 . ^ Preuss, Deborah Hartmann (13 October 2006). \"Study: Co-Located Teams vs. the Cubicle Farm\" . InfoQ . Retrieved 23 October 2018 . ^ Cockburn, Alistair (2007). \"Agile Software Development: The Cooperative Game\" . www.pearson.com (2nd\u00a0ed.). Addison-Wesley Professional . Retrieved 23 October 2018 . ^ \"Management Transformed | Research\" . ^ Jain, Parita; Sharma, Arun; Ahuja, Laxmi (August 2018). \"The Impact of Agile Software Development Process on the Quality of Software Product\". 2018 7th International Conference on Reliability, Infocom Technologies and Optimization (Trends and Future Directions) (ICRITO) . Noida, India: IEEE. pp. 812\u2013 815. doi : 10.1109/ICRITO.2018.8748529 . ISBN 978-1-5386-4692-2 . S2CID 195775457 . ^ Project Management Institute 2021 , \u00a72.7.3.2 Information Radiators. ^ Ambler, Scott (12 April 2002). Agile Modeling: Effective Practices for EXtreme Programming and the Unified Process . John Wiley & Sons. pp.\u00a012, 164, 363. ISBN 978-0-471-20282-0 . ^ Vasiliauskas, Vidas (2014). \"Developing agile project task and team management practices\" . Eylean. Archived from the original on 15 September 2014 . Retrieved 15 September 2014 . ^ Jeffries, Ron; Anderson, Ann; Hendrickson, Chet (2001). Extreme Programming installed . Addison-Weslsy. pp. 72\u2013147 . ISBN 978-0201-70842-4 . ^ Lisa Crispin; Janet Gregory (2009). Agile Testing: A Practical Guide for Testers and Agile Teams . Addison-Wesley. ^ Mitchell, Ian (2016). Agile Development in Practice . Tamare House. p.\u00a011. ISBN 978-1-908552-49-5 . ^ Larman, Craig (2004). Agile and Iterative Development: A Manager's Guide . Addison-Wesley. p.\u00a027. ISBN 978-0-13-111155-4 . ^ Boehm, B. ; R. Turner (2004). Balancing Agility and Discipline: A Guide for the Perplexed . Boston, MA: Addison-Wesley. ISBN 978-0-321-18612-6 . Appendix A, pages\u00a0165\u2013194 ^ Larman, Craig (2004). \"Chapter 11: Practice Tips\" . Agile and Iterative Development: A Manager's Guide . Addison-Wesley Professional. p.\u00a0253. ISBN 9780131111554 . Retrieved 14 October 2013 . ^ Sliger, Michele; Broderick, Stacia (2008). The Software Project Manager's Bridge to Agility . Addison-Wesley. p.\u00a046. ISBN 978-0-321-50275-9 . ^ a b Boehm, B. ; R. Turner (2004). Balancing Agility and Discipline: A Guide for the Perplexed . Boston, MA: Addison-Wesley. pp. 55\u2013 57. ISBN 978-0-321-18612-6 . ^ Rakitin, Steven R. (2001). \"Manifesto Elicits Cynicism: Reader's letter to the editor by Steven R. Rakitin\". IEEE Computer . 34 (12): 4. doi : 10.1109/MC.2001.10095 . S2CID 221106984 . The article titled 'Agile Software Development: The Business of Innovation' ... is yet another attempt to undermine the discipline of software engineering ... We want to spend all our time coding. Remember, real programmers don't write documentation. ^ a b Scott Ambler (16 April 2023). \"Agile/Lean Documentation: Strategies for Agile Software Development\" . ^ Scott Ambler. \"Just Barely Good Enough Models and Documents: An Agile Best Practice\" . Archived from the original on 8 October 2014 . Retrieved 24 January 2014 . ^ Geoffrey Wiseman (18 July 2007). \"Do Agile Methods Require Documentation?\" . InfoQ. quoting Cooper, Ian (6 July 2007). \"Staccato Signals:Agile and Documentation\" . WordPress.com . ^ a b c Abrahamson P, Salo O, Ronkainen J, Warsta J (2002). Agile software development methods: Review and analysis (PDF) (Technical report). VTT . 478. ^ \"Guide to Agile Practices\" . the Agile Alliance. Archived from the original on 9 February 2014. ^ Pugh, Ken (2011). Lean-Agile Acceptance Test-Driven Development: Better Software Through Collaboration . Addison-Wesley. ISBN 978-0321714084 . ^ Adzic, Gojko. (2009) Bridging the Communication Gap: Specification by Example and Agile Acceptance Testing , Neuri Limited, ^ Adzic, Gojko (2011). Specification by example: How successful teams deliver the right software . Manning. ISBN 978-0-321-27865-4 . ^ Chelimsky, David, Dave Astels, Zach Dennis, Aslak Helles\u00f8y, Bryan Helmkamp, and Dan North. The RSpec Book: Behaviour Driven Development with RSpec, Cucumber, and Friends. The Pragmatic Bookshelf. ^ \"Example Driven Design\" . Retrieved 15 April 2013 . ^ \"Story Test-Driven Development\" (PDF) . Retrieved 15 April 2013 . ^ Agile modeling (AM) home page, effective practices for modeling and documentation ^ Atlassian. \"The product backlog: your ultimate to-do list\" . Atlassian . Retrieved 19 December 2021 . ^ a b \"What is a Product Backlog?\" . Scrum.org . Retrieved 19 December 2021 . ^ a b c \"Agile Core Practice: Prioritized Requirements\" . agilemodeling.com . Retrieved 19 December 2021 . ^ \"Artifact: Work Items List\" . www.utm.mx . Retrieved 19 December 2021 . ^ \"Produkteier | Digitaliseringsdirektoratet\" . Archived from the original on 10 August 2020 . Retrieved 15 November 2021 . ^ Fowler, Martin (1 May 2006). \"Continuous Integration\" . Retrieved 9 January 2014 . ^ Booch, Grady (1991). Object Oriented Design: With Applications . Benjamin Cummings . p.\u00a0209. ISBN 9780805300918 . Retrieved 18 August 2014 . ^ Beck, K. (1999). \"Embracing change with extreme programming\". Computer . 32 (10): 70\u2013 77. doi : 10.1109/2.796139 . ISSN 0018-9162 . ^ What is a Cross-functional Team? Definition and meaning ^ Use of XFN as abbreviation ^ A leadership blog named XFN. ^ Krajewski, L. J. and L. P. Ritzman. 2005. Operations Management: Processes and Value Chains. Pearson Education, Upper Saddle River. ^ a b Aydin, M.N.; Harmsen, F.; Slooten; Stagwee, R. A. (2004). \"An Agile Information Systems Development Method in use\". Turk J Elec Engin . 12 (2): 127\u2013 138. ^ Morris, David (2015). The Paradox of Agile Transformation: Why trying too hard to be Agile stops organisations from becoming truly agile . NZ: University of Auckland. doi : 10.13140/RG.2.2.32698.08640 . ^ Abrahamsson, P., Warsta, J., Siponen, M.T., & Ronkainen, J. (2003). New Directions on Agile Methods: A Comparative Analysis. Proceedings of ICSE'03 , 244-254 ^ Mirakhorli, M.; Rad, A.K.; Shams, F.; Pazoki, M.; Mirakhorli, A. (2008). \"RDP technique: a practice to customize xp\". Proceedings of the 2008 international workshop on Scrutinizing agile practices or shoot-out at the agile corral (APOS '08) . ACM. pp. 23\u2013 32. doi : 10.1145/1370143.1370149 . ISBN 978-1-60558-021-0 . S2CID 9528636 . ^ Schwaber, K (2006) Scrum is hard and disruptive. ^ Vodde, B (2016) The Story of LeSS. Closing Keynote. Scrum Australia, Melbourne. April, 2016. ^ Lagstedt, A., and Dahlberg, T. (2018). Understanding the Rarity of ISD Method Selection \u2013 Bounded Rationality and Functional Stupidity. PACIS 2018 Proceedings. 154. https://aisel.aisnet.org/pacis2018/154 . ^ Park, J. S., McMahon, P. E., and Myburgh, B. (2016). Scrum Powered by Essence. ACM SIGSOFT Software Engineering Notes, 41(1), pp. 1\u20138. ^ Beck, K. (1999). Extreme Programming Explained: Embrace Change . Boston, MA: Addison-Wesley. ISBN 978-0-321-27865-4 . ^ Evans, Ian. \"Agile Delivery at British Telecom\" . Retrieved 21 February 2011 . ^ a b W. Scott Ambler (2006) Supersize Me in Dr. Dobb's Journal, 15 February 2006. ^ Schaaf, R.J. (2007). Agility XL Systems and Software Technology Conference 2007 Archived 13 March 2016 at the Wayback Machine , Tampa, FL ^ \"Bridging the Distance\" . Sdmagazine.com . Retrieved 1 February 2011 . ^ Fowler, Martin. \"Using an Agile Software Process with Offshore Development\" . Martinfowler.com . Retrieved 6 June 2010 . ^ Agile Processes Workshop II Managing Multiple Concurrent Agile Projects. Washington: OOPSLA 2002 ^ Cawley, Ois\u00edn; Wang, Xiaofeng; Richardson, Ita (2010). \"Lean/Agile Software Development Methodologies in Regulated Environments \u2013 State of the Art\". In Abrahamsson, Pekka; Oza, Nilay (eds.). Lean Enterprise Software and Systems . Lecture Notes in Business Information Processing. Vol.\u00a065. pp. 31\u2013 36. doi : 10.1007/978-3-642-16416-3_4 . hdl : 10344/683 . ISBN 978-3-642-16415-6 . ^ McHugh, Martin; McCaffery, Fergal; Coady, Garret (4 November 2014). \"An Agile Implementation within a Medical Device Software Organisation\". In Mitasiunas, Antanas; Rout, Terry; O'Connor, Rory V.; et\u00a0al. (eds.). Software Process Improvement and Capability Determination . Communications in Computer and Information Science. Vol.\u00a0477. pp. 190\u2013 201. doi : 10.1007/978-3-319-13036-1_17 . ISBN 978-3-319-13035-4 . ^ Wang, Yang; Ramadani, Jasmin; Wagner, Stefan (29 November 2017). \"An Exploratory Study on Applying a Scrum Development Process for Safety-Critical Systems\". Product-Focused Software Process Improvement . Lecture Notes in Computer Science. Vol.\u00a010611. pp. 324\u2013 340. arXiv : 1703.05375 . Bibcode : 2017arXiv170305375W . doi : 10.1007/978-3-319-69926-4_23 . ISBN 9783319699257 . S2CID 4585465 . ^ \"SafeScrum - SINTEF\" . Sintef.no . Retrieved 26 March 2019 . ^ Thor Myklebust, Tor St\u00e5lhane, Geir Kjetil Hanssen, Tormod Wien and B\u00f8rge Haugset: Scrum, documentation and the IEC 61508-3:2010 software standard, http://www.sintef.no/globalassets/ec-61508-documentation-and-safescrum-psam12.pdf Archived 27 June 2022 at the Wayback Machine ^ Fitzgerald, B.; Stol, K.-J.; O'Sullivan, R.; O'Brien, D. (May 2013). \"Scaling agile methods to regulated environments: An industry case study\". 2013 35th International Conference on Software Engineering (ICSE) . pp. 863\u2013 872. doi : 10.1109/ICSE.2013.6606635 . hdl : 10344/3055 . ISBN 978-1-4673-3076-3 . S2CID 192403 . ^ Beck, Kent (2000). Extreme Programming Explained . Addison-Wesley. pp. 1\u201324 . ISBN 978-0201616415 . ^ Datta, Subhajit (2006). \"Agility measurement index: a metric for the crossroads of software development methodologies\". ACM-SE 44 Proceedings of the 44th annual Southeast regional conference . p.\u00a0271. doi : 10.1145/1185448.1185509 . ISBN 1595933158 . ^ Peter Lappo; Henry C.T. Andrew. \"Assessing Agility\" (PDF) . Archived from the original (PDF) on 15 September 2009 . Retrieved 6 June 2010 . ^ Joe Little (2 December 2007). \"Nokia test, A scrum-specific test\" . Agileconsortium.blogspot.com . Retrieved 6 June 2010 . ^ Mark Seuffert; Mayberg, Sweden. \"Karlskrona test, A generic agile adoption test\" . Mayberg.se . Retrieved 5 April 2014 . ^ \"How Agile Are You? (Take This 42 Point Test)\" . allaboutagile.com/. Archived from the original on 5 May 2014 . Retrieved 3 April 2014 . ^ \"Agile Methodologies Survey Results\" (PDF) . Shine Technologies. January 2003. Archived from the original (PDF) on 21 August 2010 . Retrieved 3 June 2010 . 95% stated that there was either no effect or a cost reduction\u00a0... 93% stated that productivity was better or significantly better\u00a0... 88% stated that quality was better or significantly better\u00a0... 83% stated that business satisfaction was better or significantly better ^ \"2013 State of Agile report: Why Agile?\" . stateofagile.com. 27 January 2014. Archived from the original on 28 August 2014 . Retrieved 13 August 2014 . ^ Status Quo Agile Archived 18 March 2018 at the Wayback Machine , Second study on success and forms of usage of agile methods. Retrieved 1 July 2015 ^ Ambler, Scott (3 August 2006). \"Survey Says: Agile Works in Practice\" . Dr. Dobb's . Retrieved 3 June 2010 . Only 6% indicated that their productivity was lowered\u00a0... No change in productivity was reported by 34% of respondents and 60% reported increased productivity\u00a0... 66% [responded] that the quality is higher\u00a0... 58% of organizations report improved satisfaction, whereas only 3% report reduced satisfaction. ^ \"Answering the \"Where is the Proof That Agile Methods Work\" Question\" . Agilemodeling.com. 19 January 2007 . Retrieved 2 April 2010 . ^ Shore & Warden 2008 , p.\u00a047 ^ Beck, Kent (2000). Extreme Programming Explained . Addison-Wesley. pp. 48\u201349 . ISBN 978-0201616415 . ^ Rouse, Margaret. \"Sprint (software development) definition\" . searchsoftwarequality.techtarget.com . Retrieved 2 October 2015 . ^ Goldstein, Ilan (11 October 2011). \"Sprint issues \u2013 when sprints turn into crawls\" . www.axisagile.com.au . Retrieved 8 June 2014 . ^ \"Project Roles and Responsibility Distribution\" . agile-only.com . Retrieved 15 June 2014 . ^ Bourne, Lynda. \"What Does a Project Sponsor Really Do?\" . blogs.pmi.org . Archived from the original on 7 June 2014 . Retrieved 8 June 2014 . ^ \"9th State of Agile Report\" . Stage of Agile Survey . VersionOne. Archived from the original on 12 January 2015 . Retrieved 8 June 2014 . ^ Sims, Chris; Johnson, Hillary Louise (15 February 2011). The Elements of Scrum (Kindle\u00a0ed.). Dymaxicon. p.\u00a073. ^ Rothman, Johanna Rothman (25 August 2011). \"When You Have No Product Owner at All\" . www.jrothman.com . Retrieved 8 June 2014 . ^ Fox, Alyssa (8 April 2014). \"Working on Multiple Agile Teams\" . techwhirl.com/ . Retrieved 14 June 2014 . ^ \"Daily Scrum Meeting\" . www.mountaingoatsoftware.com . Retrieved 14 June 2014 . ^ a b May, Robert. \"Effective Sprint Planning\" . www.agileexecutives.org . Archived from the original on 28 June 2014 . Retrieved 14 June 2014 . ^ Berczuk, Steve. \"Mission Possible: ScrumMaster and Technical Contributor\" . www.agileconnection.com . Retrieved 14 June 2014 . ^ \"How to Implement Agile Scrum\" . Retrieved 4 January 2022 . ^ Namta, Rajneesh. \"Thoughts on Test Automation in Agile\" . www.infoq.com . Archived from the original on 18 August 2014 . Retrieved 14 June 2014 . ^ a b Band, Zvi (22 March 2014). \"Technical Debt + Red October\" . Zvi Band . Archived from the original on 14 July 2014 . Retrieved 8 June 2014 . ^ Shore, James. \"The Art of Agile Development: Refactoring\" . www.jamesshore.com . Retrieved 14 June 2014 . ^ \"Step 4: Sprint Planning (Tasks)\" . www.allaboutagile.com . Archived from the original on 29 June 2014 . Retrieved 14 June 2014 . ^ George, Claire (3 March 2014). \"Why Limiting Your Work-in-Progress Matters\" . leankit.com . Retrieved 14 June 2014 . ^ \"Sprint Planning Meeting\" . www.mountaingoatsoftware.com . Retrieved 14 June 2014 . ^ McMillan, Keith (13 May 2010). \"Time, Resources, Scope... and Quality\" . www.adeptechllc.com . Retrieved 15 June 2014 . ^ \"Current study on limitations of Agile\" . Procedia Computer Science . 78 : 291\u2013 297. January 2016. doi : 10.1016/j.procs.2016.02.056 . ^ a b \"The Procurement Call for Agile, What does it mean?\" . 1 November 2019. ^ Moran, Alan (2015). Managing Agile: Strategy, Implementation, Organisation and People . Springer. ISBN 978-3-319-16262-1 . ^ \"Which Life Cycle Is Best for Your Project?\" . PMHut . 22 October 2008 . Retrieved 23 October 2009 . ^ \"Agile Project Management\" . VersionOne . Archived from the original on 9 June 2015 . Retrieved 1 June 2015 . ^ \"What is Agile Management?\" . Project Laneways. Archived from the original on 2 June 2015 . Retrieved 1 June 2015 . ^ Benson, Jim; De Maria Barry, Tonianne (2011). Personal Kanban: mapping work, navigating life (1st\u00a0ed.). Seattle, WA: Modus Cooperandi Press. p.\u00a038. ISBN 978-1-4538-0226-7 . ^ USAID. \"ADS Chapter 201 Program Cycle Operational Policy\" Archived 23 October 2019 at the Wayback Machine . Retrieved 19 April 2017 ^ Project Management Institute , A Guide to the Project Management Body of Knowledge (PMBOK Guide), Sixth Edition ^ Richet, Jean-Loup (2013). Agile Innovation . Cases and Applied Research, n\u00b031. ESSEC-ISIS. ISBN 978-2-36456-091-8 ^ Smith, Preston G (2007). Flexible Product Development . Jossey-Bass. p.\u00a025. ISBN 978-0-7879-9584-3 . ^ Newton Lee (2014). \"Getting on the Billboard Charts: Music Production as Agile Software Development,\" Digital Da Vinci: Computers in Music . Springer Science+Business Media. ISBN 978-1-4939-0535-5 . ^ Moran, Alan (2015). Managing Agile: Strategy, Implementation, Organisation and People . Springer Verlag. ISBN 978-3-319-16262-1 . ^ Barrett, M.; Goodell, J. (2022), \"Lean-Agile Development Tools\", Learning Engineering Toolkit , Routledge, pp. 269\u2013 278, doi : 10.4324/9781003276579-16 , ISBN 978-1-003-27657-9 ^ \"Agile programming \u2013 for your family\" . ^ Larman, Craig; Bas Vodde (13 August 2009). Top Ten Organizational Impediments to Large-Scale Agile Adoption . InformIT. ^ \"Introduction to Hybrid project management\" . Collaboration Corner . 20 July 2016. Archived from the original on 7 January 2020 . Retrieved 16 January 2018 . ^ Barlow, Jordan B.; Justin Scott Giboney; Mark Jeffery Keith; David W. Wilson; Ryan M. Schuetzler; Paul Benjamin Lowry; Anthony Vance (2011). \"Overview and Guidance on Agile Development in Large Organizations\" . Communications of the Association for Information Systems . 29 (1): 25\u2013 44. doi : 10.17705/1CAIS.02902 . ^ Kupersmith, Kupe (4 July 2011). \"Agile is a Fad\" . ^ a b Kruchten, Philippe (20 June 2011). \"Agile's Teenage Crisis?\" . InfoQ. ^ Richard Utz, \"Against Adminspeak,\" Chronicle of Higher Education , 24 June 2020. ^ Cohn, Mike (2015). Succeeding With Agile . Pearson. pp. 5\u2013 10. ISBN 978-0-321-57936-2 . Further reading [ edit ] Abrahamsson, P.; Salo, O.; Ronkainen, J.; Warsta, J. (2002). \"Agile Software Development Methods: Review and Analysis\" . VTT Publications. 478. Archived from the original on 7 September 2011 . Retrieved 20 February 2012 . Ashmore, Sondra; Runyan, Kristin (2014). Introduction to Agile Methods . Addison-Wesley. ISBN 978-0321929563 . Barlow, Jordan B.; Justin Scott Giboney; Mark Jeffery Keith; David W. Wilson; Ryan M. Schuetzler; Paul Benjamin Lowry; Anthony Vance (2011). \"Overview and Guidance on Agile Development in Large Organizations\" . Communications of the Association for Information Systems . 29 (1): 25\u2013 44. doi : 10.17705/1CAIS.02902 . Cohen, D.; Lindvall, M.; Costa, P. (2004). \"An introduction to agile methods\" . In Zelkowitz, Marvin (ed.). Advances in Software Engineering . Advances in Computers. Vol.\u00a062. Academic Press. pp. 1\u2013 66. ISBN 978-0-08-047190-7 . Collier, Ken W. (2011). Agile Analytics: A Value-Driven Approach to Business Intelligence and Data Warehousing . Pearson Education. ISBN 9780321669544 . What is a self-organizing team? Dings\u00f8yr, Torgeir; Dyb\u00e5, Tore; Moe, Nils Brede (2010). Agile Software Development: Current Research and Future Directions . Springer. ISBN 978-3-642-12575-1 . Fowler, Martin (2001). \"Is Design Dead?\" . In Succi, Giancarlo; Marchesi, Michele (eds.). Extreme Programming Examined . Addison-Wesley. pp. 3\u201318 . ISBN 978-0-201-71040-3 . Larman, Craig; Basili, Victor R. (June 2003). \"Iterative and Incremental Development: A Brief History\". IEEE Computer . 36 (3): 47\u2013 56. Bibcode : 2003Compr..36f..47L . doi : 10.1109/MC.2003.1204375 . S2CID 9240477 . Casagni, Michelle; Benito, Robert; Mayfield, Kathleen M.; Northern, Carlton (8 September 2013). \"Handbook for Implementing Agile in Department of Defense Information Technology Acquisition\" . The Mitre Corporation . MITRE. Moran, Alan (2015). Managing Agile: Strategy, Implementation, Organisation and People . Springer. ISBN 978-3-319-16262-1 . Riehle, Dirk. \"A Comparison of the Value Systems of Adaptive Software Development and Extreme Programming: How Methodologies May Learn From Each Other\" . In Succi & Marchesi 2001 Rubin, Kenneth (2013). Essential Scrum. A Practical Guide to the Most Popular Agile Process . Addison-Wesley. ISBN 978-0-13-704329-3 . Shore, James; Warden, Shane (2008). The Art of Agile Development . O'Reilly Media. ISBN 978-0-596-52767-9 . Project Management Institute (2021). A guide to the project management body of knowledge (PMBOK guide) . Project Management Institute (7th\u00a0ed.). Newtown Square, PA. ISBN 978-1-62825-664-2 . {{ cite book }} :  CS1 maint: location missing publisher ( link ) Stephens, M.; Rosenberg, D. (2003). Extreme Programming Refactored: The Case Against XP . Apress. ISBN 978-1-59059-096-6 . Swamidass, P. M., ed. (2000), \"Heavyweight project organizationHEAVYWEIGHT PROJECT ORGANIZATION\" , Encyclopedia of Production and Manufacturing Management , Boston, MA: Springer US, pp. 261\u2013 262, doi : 10.1007/1-4020-0612-8_400 , ISBN 978-1-4020-0612-8 , retrieved 22 June 2022 Takeuchi, Hirotaka; Nonaka, Ikujiro (1 January 1986). \"The New New Product Development Game\" . Harvard Business Review . ISSN 0017-8012 . Retrieved 25 July 2021 . \"Introduction to Hybrid project management\" . Collaboration Corner . 20 July 2016. Archived from the original on 7 January 2020 . Retrieved 16 January 2018 . External links [ edit ] Agile Manifesto Agile Glossary of the Agile Alliance The New Methodology - Martin Fowler 's description of the background to agile methods v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Authority control databases International GND National United States France BnF data Japan Spain Israel Other IdRef Yale LUX Retrieved from \" https://en.wikipedia.org/w/index.php?title=Agile_software_development&oldid=1326397522 \" Categories : Agile software development Software project management Software development Software engineering Software development philosophies Hidden categories: CS1: unfit URL Webarchive template wayback links Articles with short description Short description is different from Wikidata Use dmy dates from August 2020 Wikipedia articles needing clarification from December 2015 Articles with excerpts All articles with unsourced statements Articles with unsourced statements from May 2018 CS1 maint: location missing publisher This page was last edited on 8 December 2025, at 19:39 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Agile software development 48 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_prototyping",
    "title": "Software prototyping - Wikipedia",
    "content": "Software prototyping - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Overview 2 Outline 3 Dimensions Toggle Dimensions subsection 3.1 Horizontal prototype 3.2 Vertical prototype 4 Types Toggle Types subsection 4.1 Throwaway prototyping 4.2 Evolutionary prototyping 4.3 Incremental prototyping 4.4 Extreme prototyping 5 Advantages 6 Disadvantages 7 Applicability Toggle Applicability subsection 7.1 Dynamic systems development method 7.2 Operational prototyping 7.3 Evolutionary systems development 7.4 Evolutionary rapid development 8 Tools Toggle Tools subsection 8.1 Screen generators, design tools, and software factories 8.2 Application definition or simulation software 8.3 Requirements Engineering Environment 8.4 Non-relational environments 8.5 PSDL 9 References Toggle the table of contents Software prototyping 15 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 \u010ce\u0161tina Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \u0939\u093f\u0928\u094d\u0926\u0940 Bahasa Indonesia Italiano Magyar \u65e5\u672c\u8a9e Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u7cb5\u8a9e Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Activity of creating prototypes of software applications For other uses, see Prototype-based programming . Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Software prototyping is the activity of creating prototypes of software applications, i.e., incomplete versions of the software program being developed. It is an activity that can occur in software development and is comparable to prototyping as known from other fields, such as mechanical engineering or manufacturing . A prototype typically simulates only a few aspects of, and may be completely different from, the final product. Prototyping has several benefits: the software designer and implementer can get valuable feedback from the users early in the project. The client and the contractor can compare if the software made matches the software specification , according to which the software program is built. It also allows the software engineer some insight into the accuracy of initial project estimates and whether the deadlines and milestones proposed can be successfully met. The degree of completeness and the techniques used in prototyping have been in development and debate since its proposal in the early 1970s. [ 1 ] Overview [ edit ] The purpose of a prototype is to allow users of the software to evaluate developers' proposals for the design of the eventual product by actually trying them out, rather than having to interpret and evaluate the design based on descriptions. Software prototyping provides an understanding of the software's functions and potential threats or issues. [ 2 ] Prototyping can also be used by end users to describe and prove requirements that have not been considered, and that can be a key factor in the commercial relationship between developers and their clients. [ 3 ] Interaction design in particular makes heavy use of prototyping with that goal. This process is in contrast with the 1960s and 1970s monolithic development cycle of building the entire program first and then working out any inconsistencies between design and implementation, which led to higher software costs and poor estimates of time and cost. [ citation needed ] The monolithic approach has been dubbed the \"Slaying the (software) Dragon\" technique, since it assumes that the software designer and developer is a single hero who has to slay the entire dragon alone. Prototyping can also avoid the great expense and difficulty of having to change a finished software product. The practice of prototyping is one of the points Frederick P. Brooks makes in his 1975 book The Mythical Man-Month and his 10-year anniversary article \" No Silver Bullet \". An early example of large-scale software prototyping was the implementation of NYU's Ada/ED translator for the Ada programming language . [ 4 ] It was implemented in SETL with the intent of producing an executable semantic model for the Ada language, emphasizing clarity of design and user interface over speed and efficiency. The NYU Ada/ED system was the first validated Ada implementation, certified on April 11, 1983. [ 5 ] Outline [ edit ] The process of prototyping involves the following steps: [ citation needed ] Identify basic requirements Determine basic requirements including the input and output information desired. Details, such as security, can typically be ignored. Develop initial prototype The initial prototype is developed that includes only user interfaces. (See Horizontal Prototype , below) Review The customers, including end-users, examine the prototype and provide feedback on potential additions or changes. Revise and enhance the prototype Using the feedback both the specifications and the prototype can be improved.  Negotiation about what is within the scope of the contract/product may be necessary.  If changes are introduced then a repeat of steps #3 and #4 may be needed. Dimensions [ edit ] Nielsen summarizes the various dimensions of prototypes in his book Usability Engineering : Horizontal prototype [ edit ] A common term for a user interface prototype is the horizontal prototype .  It provides a broad view of an entire system or subsystem, focusing on user interaction more than low-level system functionality, such as database access.  Horizontal prototypes are useful for: Confirmation of user interface requirements and system scope, Demonstration version of the system to obtain buy-in from the business, Develop preliminary estimates of development time, cost and effort. Vertical prototype [ edit ] A vertical prototype is an enhanced complete elaboration of a single subsystem or function.  It is useful for obtaining detailed requirements for a given function, with the following benefits: Refinement database design, Obtain information on data volumes and system interface needs, for network sizing and performance engineering, Clarify complex requirements by drilling down to actual system functionality. Types [ edit ] Software prototyping has many variants. However, all of the methods are in some way based on two major forms of prototyping: throwaway prototyping and evolutionary prototyping. Throwaway prototyping [ edit ] Also called close-ended prototyping. Throwaway or rapid prototyping refers to the creation of a model that will eventually be discarded rather than becoming part of the final delivered software. After preliminary requirements gathering is accomplished, a simple working model of the system is constructed to visually show the users what their requirements may look like when they are implemented into a finished system.\nIt is also a form of rapid prototyping. Rapid prototyping involves creating a working model of various parts of the system at a very early stage, after a relatively short investigation. The method used in building it is usually quite informal, the most important factor being the speed with which the model is provided. The model then becomes the starting point from which users can re-examine their expectations and clarify their requirements. When this goal has been achieved, the prototype model is 'thrown away', and the system is formally developed based on the identified requirements. [ 6 ] The most obvious reason for using throwaway prototyping is that it can be done quickly. If the users can get quick feedback on their requirements, they may be able to refine them early in the development of the software.  Making changes early in the development lifecycle is extremely cost effective since there is nothing at that point to redo. If a project is changed after a considerable amount of work has been done then small changes could require large efforts to implement since software systems have many dependencies. Speed is crucial in implementing a throwaway prototype, since with a limited budget of time and money little can be expended on a prototype that will be discarded. Another strength of throwaway prototyping is its ability to construct interfaces that the users can test. The user interface is what the user sees as the system, and by seeing it in front of them, it is much easier to grasp how the system will function. \u2026it is asserted that revolutionary rapid prototyping is a more effective manner in which to deal with user requirements-related issues, and therefore a greater enhancement to software productivity overall. Requirements can be identified, simulated, and tested far more quickly and cheaply when issues of evolvability, maintainability, and software structure are ignored. This, in turn, leads to the accurate specification of requirements, and the subsequent construction of a valid and usable system from the user's perspective, via conventional software development models. [ 7 ] Prototypes can be classified according to the fidelity with which they resemble the actual product in terms of appearance, interaction and timing. One method of creating a low fidelity throwaway prototype is paper prototyping . The prototype is implemented using paper and pencil, and thus mimics the function of the actual product, but does not look at all like it. Another method to easily build high fidelity throwaway prototypes is to use a GUI Builder and create a click dummy , a prototype that looks like the goal system, but does not provide any functionality. The usage of storyboards , animatics or drawings is not exactly the same as throwaway prototyping, but certainly falls within the same family.  These are non-functional implementations but show how the system will look. Summary: In this approach the prototype is constructed with the idea that it will be discarded and the final system will be built from scratch. The steps in this approach are: Write preliminary requirements Design the prototype User experiences/uses the prototype, specifies new requirements Repeat if necessary Write the final requirements Evolutionary prototyping [ edit ] Evolutionary prototyping (also known as breadboard prototyping) is quite different from throwaway prototyping . The main goal when using evolutionary prototyping is to build a very robust prototype in a structured manner and constantly refine it. The reason for this approach is that the evolutionary prototype, when built, forms the heart of the new system, and the improvements and further requirements will then be built. When developing a system using evolutionary prototyping, the system is continually refined and rebuilt. \"\u2026evolutionary prototyping acknowledges that we do not understand all the requirements and builds only those that are well understood.\" [ 8 ] This technique allows the development team to add features, or make changes that couldn't be conceived during the requirements and design phase. For a system to be useful, it must evolve through use in its intended operational environment. A product is never \"done;\" it is always maturing as the usage environment changes\u2026we often try to define a system using our most familiar frame of reference\u2014where we are now. We make assumptions about the way business will be conducted and the technology base on which the business will be implemented. A plan is enacted to develop the capability, and, sooner or later, something resembling the envisioned system is delivered. [ 9 ] Evolutionary prototypes have an advantage over throwaway prototypes in that they are functional systems. Although they may not have all the features the users have planned, they may be used on an interim basis until the final system is delivered. \"It is not unusual within a prototyping environment for the user to put an initial prototype to practical use while waiting for a more developed version\u2026The user may decide that a 'flawed' system is better than no system at all.\" [ 6 ] In evolutionary prototyping, developers can focus themselves to develop parts of the system that they understand instead of working on developing a whole system. To minimize risk, the developer does not implement poorly understood features. The partial system is sent to customer sites. As users work with the system, they detect opportunities for new features and give requests for these features to developers. Developers then take these enhancement requests along with their own and use sound configuration-management practices to change the software-requirements specification, update the design, recode and retest. [ 10 ] Incremental prototyping [ edit ] The final product is built as separate prototypes. At the end, the separate prototypes are merged in an overall design. By the help of incremental prototyping the time gap between user and software developer is reduced. Extreme prototyping [ edit ] Extreme prototyping as a development process is used especially for developing web applications. Basically, it breaks down web development into three phases, each one based on the preceding one. The first phase is a static prototype that consists mainly of HTML pages. In the second phase, the screens are programmed and fully functional using a simulated services layer. In the third phase, the services are implemented. \"The process is called Extreme Prototyping to draw attention to the second phase of the process, where a fully functional UI is developed with very little regard to the services other than their contract.\" [ 11 ] Advantages [ edit ] There are many advantages to using prototyping in software development \u2013 some tangible, some abstract. [ 12 ] Reduced time and costs :  Prototyping can improve the quality of requirements and specifications provided to developers.  Because changes cost exponentially more to implement as they are detected later in development, the early determination of what the user really wants can result in faster and less expensive software. [ 7 ] Improved and increased user involvement :  Prototyping requires user involvement and allows them to see and interact with a prototype allowing them to provide better and more complete feedback and specifications. [ 6 ] The presence of the prototype being examined by the user prevents many misunderstandings and miscommunications that occur when each side believe the other understands what they said.  Since users know the problem domain better than anyone on the development team does, increased interaction can result in a final product that has greater tangible and intangible quality.  The final product is more likely to satisfy the user's desire for look, feel and performance. Disadvantages [ edit ] Using, or perhaps misusing, prototyping can also have disadvantages. Insufficient analysis :  The focus on a limited prototype can distract developers from properly analyzing the complete project.  This can lead to overlooking better solutions, preparation of incomplete specifications or the conversion of limited prototypes into poorly engineered final projects that are hard to maintain .  Further, since a prototype is limited in functionality it may not scale well if the prototype is used as the basis of a final deliverable, which may not be noticed if developers are too focused on building a prototype as a model. User confusion of prototype and finished system : Users can begin to think that a prototype, intended to be thrown away, is actually a final system that merely needs to be finished or polished. (They are, for example, often unaware of the effort needed to add error-checking and security features which a prototype may not have.) This can lead them to expect the prototype to accurately model the performance of the final system when this is not the intent of the developers. Users can also become attached to features that were included in a prototype for consideration and then removed from the specification for a final system. If users are able to require all proposed features be included in the final system this can lead to conflict. Developer misunderstanding of user objectives : Developers may assume that users share their objectives (e.g. to deliver core functionality on time and within budget), without understanding wider commercial issues. For example, user representatives attending Enterprise software (e.g. PeopleSoft ) events may have seen demonstrations of \"transaction auditing\" (where changes are logged and displayed in a difference grid view) without being told that this feature demands additional coding and often requires more hardware to handle extra database accesses. Users might believe they can demand auditing on every field, whereas developers might think this is feature creep because they have made assumptions about the extent of user requirements. If the developer has committed delivery before the user requirements were reviewed, developers are between a rock and a hard place, particularly if user management derives some advantage from their failure to implement requirements. Developer attachment to prototype: Developers can also become attached to prototypes they have spent a great deal of effort producing; this can lead to problems, such as attempting to convert a limited prototype into a final system when it does not have an appropriate underlying architecture. (This may suggest that throwaway prototyping, rather than evolutionary prototyping, should be used.) Excessive development time of the prototype : A key property to prototyping is the fact that it is supposed to be done quickly. If the developers lose sight of this fact, they very well may try to develop a prototype that is too complex. When the prototype is thrown away the precisely developed requirements that it provides may not yield a sufficient increase in productivity to make up for the time spent developing the prototype. Users can become stuck in debates over details of the prototype, holding up the development team and delaying the final product. Expense of implementing prototyping : the start up costs for building a development team focused on prototyping may be high. Many companies have development methodologies in place, and changing them can mean retraining, retooling, or both.  Many companies tend to just begin prototyping without bothering to retrain their workers as much as they should. A common problem with adopting prototyping technology is high expectations for productivity with insufficient effort behind the learning curve. In addition to training for the use of a prototyping technique, there is an often overlooked need for developing corporate and project specific underlying structure to support the technology. When this underlying structure is omitted, lower productivity can often result. [ 13 ] Applicability [ edit ] It has been argued that prototyping, in some form or another, should be used all the time. However, prototyping is most beneficial in systems that will have many interactions with the users. It has been found that prototyping is very effective in the analysis and design of on-line systems , especially for transaction processing , where the use of screen dialogs is much more in evidence. The greater the interaction between the computer and the user, the greater the benefit is that can be obtained from building a quick system and letting the user play with it. [ 6 ] Systems with little user interaction, such as batch processing or systems that mostly do calculations, benefit little from prototyping. Sometimes, the coding needed to perform the system functions may be too intensive and the potential gains that prototyping could provide are too small. [ 6 ] Prototyping is especially good for designing good human\u2013computer interfaces . \"One of the most productive uses of rapid prototyping to date has been as a tool for iterative user requirements engineering and human\u2013computer interface design.\" [ 7 ] Dynamic systems development method [ edit ] Dynamic Systems Development Method (DSDM) [ 14 ] is a framework for delivering business solutions that relies heavily upon prototyping as a core technique, and is itself ISO 9001 approved.  It expands upon most understood definitions of a prototype.  According to DSDM the prototype may be a diagram, a business process, or even a system placed into production. DSDM prototypes are intended to be incremental, evolving from simple forms into more comprehensive ones. DSDM prototypes can sometimes be throwaway or evolutionary .  Evolutionary prototypes may be evolved horizontally (breadth then depth) or vertically (each section is built in detail with additional iterations detailing subsequent sections).  Evolutionary prototypes can eventually evolve into final systems. The four categories of prototypes as recommended by DSDM are: Business prototypes \u2013 used to design and demonstrates the business processes being automated. Usability prototypes \u2013 used to define, refine, and demonstrate user interface design usability, accessibility, look and feel. Performance and capacity prototypes \u2013  used to define, demonstrate, and predict how systems will perform under peak loads as well as to demonstrate and evaluate other non-functional aspects of  the system (transaction rates, data storage volume, response time, etc.) Capability/technique prototypes \u2013 used to develop, demonstrate, and evaluate a design approach or concept. The DSDM lifecycle of a prototype is to: Identify prototype Agree to a plan Create the prototype Review the prototype Operational prototyping [ edit ] Operational prototyping was proposed by Alan Davis as a way to integrate throwaway and evolutionary prototyping with conventional system development. \"It offers the best of both the quick-and-dirty and conventional-development worlds in a sensible manner. Designers develop only well-understood features in building the evolutionary baseline, while using throwaway prototyping to experiment with the poorly understood features.\" [ 8 ] Davis' belief is that to try to \"retrofit quality onto a rapid prototype\" is not the correct method when trying to combine the two approaches. His idea is to engage in an evolutionary prototyping methodology and rapidly prototype the features of the system after each evolution. The specific methodology follows these steps: [ 8 ] An evolutionary prototype is constructed and made into a baseline using conventional development strategies, specifying and implementing only the requirements that are well understood. Copies of the baseline are sent to multiple customer sites along with a trained prototyper. At each site, the prototyper watches the user at the system. Whenever the user encounters a problem or thinks of a new feature or requirement, the prototyper logs it. This frees the user from having to record the problem, and allows him to continue working. After the user session is over, the prototyper constructs a throwaway prototype on top of the baseline system. The user now uses the new system and evaluates. If the new changes aren't effective, the prototyper removes them. If the user likes the changes, the prototyper writes feature-enhancement requests and forwards them to the development team. The development team, with the change requests in hand from all the sites, then produce a new evolutionary prototype using conventional methods. Obviously, a key to this method is to have well trained prototypers available to go to the user sites. The operational prototyping methodology has many benefits in systems that are complex and have few known requirements in advance. Evolutionary systems development [ edit ] Evolutionary Systems Development is a class of methodologies that attempt to formally implement evolutionary prototyping. One particular type, called Systemscraft is described by John Crinnion in his book Evolutionary Systems Development . Systemscraft was designed as a 'prototype' methodology that should be modified and adapted to fit the specific environment in which it was implemented. Systemscraft was not designed as a rigid 'cookbook' approach to the development process. It is now generally recognised[sic] that a good methodology should be flexible enough to be adjustable to suit all kinds of environment and situation... [ 6 ] The basis of Systemscraft, not unlike evolutionary prototyping, is to create a working system from the initial requirements and build upon it in a series of revisions. Systemscraft places heavy emphasis on traditional analysis being used throughout the development of the system. Evolutionary rapid development [ edit ] Evolutionary Rapid Development (ERD) [ 15 ] was developed by the Software Productivity Consortium, a technology development and integration agent for the Information Technology Office of the Defense Advanced Research Projects Agency (DARPA). Fundamental to ERD is the concept of composing software systems based on the reuse of components, the use of software templates and on an architectural template. Continuous evolution of system capabilities in rapid response to changing user needs and technology is highlighted by the evolvable architecture, representing a class of solutions. The process focuses on the use of small artisan-based teams integrating software and systems engineering disciplines working multiple, often parallel short-duration timeboxes with frequent customer interaction. Key to the success of the ERD-based projects is parallel exploratory analysis and development of features, infrastructures, and components with and adoption of leading edge technologies enabling the quick reaction to changes in technologies, the marketplace, or customer requirements. [ 9 ] To elicit customer/user input, frequent scheduled and ad hoc/impromptu meetings with the stakeholders are held. Demonstrations of system capabilities are held to solicit feedback before design/implementation decisions are solidified. Frequent releases (e.g., betas ) are made available for use to provide insight into how the system could better support user and customer needs. This assures that the system evolves to satisfy existing user needs. The design framework for the system is based on using existing published or de facto standards. The system is organized to allow for evolving a set of capabilities that includes considerations for performance, capacities, and functionality. The architecture is defined in terms of abstract interfaces that encapsulate the services and their implementation (e.g., COTS applications). The architecture serves as a template to be used for guiding development of more than a single instance of the system. It allows for multiple application components to be used to implement the services. A core set of functionality not likely to change is also identified and established. The ERD process is structured to use demonstrated functionality rather than paper products as a way for stakeholders to communicate their needs and expectations. Central to this goal of rapid delivery is the use of the \" timebox \" method. Timeboxes are fixed periods of time in which specific tasks (e.g., developing a set of functionality) must be performed. Rather than allowing time to expand to satisfy some vague set of goals, the time is fixed (both in terms of calendar weeks and person-hours) and a set of goals is defined that realistically can be achieved within these constraints.  To keep development from degenerating into a \" random walk ,\" long-range plans are defined to guide the iterations. These plans provide a vision for the overall system and set boundaries (e.g., constraints) for the project. Each iteration within the process is conducted in the context of these long-range plans. Once an architecture is established, software is integrated and tested on a daily basis. This allows the team to assess progress objectively and identify potential problems quickly. Since small amounts of the system are integrated at one time, diagnosing and removing the defect is rapid. User demonstrations can be held at short notice since the system is generally ready to exercise at all times. Tools [ edit ] Efficiently using prototyping requires that an organization have the proper tools and a staff trained to use those tools.  Tools used in prototyping can vary from individual tools, such as 4th generation programming languages used for rapid prototyping to complex integrated CASE tools. 4th generation visual programming languages like Visual Basic and ColdFusion are frequently used since they are cheap, well known and relatively easy and fast to use.  CASE tools, supporting requirements analysis, like the Requirements Engineering Environment (see below) are often developed or selected by the military or large organizations. Object oriented tools are also being developed like LYMB from the GE Research and Development Center. Users may prototype elements of an application themselves in a spreadsheet . As web-based applications continue to grow in popularity, so too, have the tools for prototyping such applications. Frameworks such as Bootstrap , Foundation , and AngularJS provide the tools necessary to quickly structure a proof of concept . These frameworks typically consist of a set of controls, interactions, and design guidelines that enable developers to quickly prototype web applications. Screen generators, design tools, and software factories [ edit ] Screen generating programs are also commonly used and they enable prototypers to show user's systems that do not function, but show what the screens may look like. Developing Human Computer Interfaces can sometimes be the critical part of the development effort, since to the users the interface essentially is the system. Software factories can generate code by combining ready-to-use modular components. This makes them ideal for prototyping applications, since this approach can quickly deliver programs with the desired behaviour, with a minimal amount of manual coding. Application definition or simulation software [ edit ] A new class of software called Application definition or simulation software enables users to rapidly build lightweight, animated simulations of another computer program, without writing code .  Application simulation software allows both technical and non-technical users to experience, test, collaborate and validate the simulated program, and provides reports such as annotations , screenshot and schematics . As a solution specification technique, Application Simulation falls between low-risk, but limited, text or drawing-based mock-ups (or wireframes ) sometimes called paper-based prototyping , and time-consuming, high-risk code-based prototypes , allowing software professionals to validate requirements and design choices early on, before development begins. In doing so, the risks and costs associated with software implementations can be dramatically reduced. [ 16 ] To simulate applications one can also use software that simulates real-world software programs for computer-based training , demonstration, and customer support, such as screencasting software as those areas are closely related. Requirements Engineering Environment [ edit ] \"The Requirements Engineering Environment (REE), under development at Rome Laboratory since 1985, provides an integrated toolset for rapidly representing, building, and executing models of critical aspects of complex systems.\" [ 17 ] Requirements Engineering Environment is currently used by the United States Air Force to develop systems. It is: an integrated set of tools that allows systems analysts to rapidly build functional, user interface, and performance prototype models of system components. These modeling activities are performed to gain a greater understanding of complex systems and lessen the impact that inaccurate requirement specifications have on cost and scheduling during the system development process. Models can be constructed easily, and at varying levels of abstraction or granularity, depending on the specific behavioral aspects of the model being exercised. [ 17 ] REE is composed of three parts. The first, called proto is a CASE tool specifically designed to support rapid prototyping. The second part is called the Rapid Interface Prototyping System or RIP, which is a collection of tools that facilitate the creation of user interfaces. The third part of REE is a user interface to RIP and proto that is graphical and intended to be easy to use. Rome Laboratory, the developer of REE, intended that to support their internal requirements gathering methodology. Their method has three main parts: Elicitation from various sources (users, interfaces to other systems), specification, and consistency checking Analysis that the needs of diverse users taken together do not conflict and are technically and economically feasible Validation that requirements so derived are an accurate reflection of user needs. [ 17 ] In 1996, Rome Labs contracted Software Productivity Solutions (SPS) to further enhance REE to create \"a commercial quality REE that supports requirements specification, simulation, user interface prototyping, mapping of requirements to hardware architectures, and code generation...\" [ 18 ] This system is named the Advanced Requirements Engineering Workstation or AREW. Non-relational environments [ edit ] Non-relational definition of data (e.g. using Cach\u00e9 or associative models) can help make end-user prototyping more productive by delaying or avoiding the need to normalize data at every iteration of a simulation. This may yield earlier/greater clarity of business requirements, though it does not specifically confirm that requirements are technically and economically feasible in the target production system. PSDL [ edit ] PSDL is a prototype description language to describe real-time software. [ 19 ] The associated tool set is CAPS (Computer Aided Prototyping System). [ 20 ] Prototyping software systems with hard real-time requirements is challenging because timing constraints introduce implementation and hardware dependencies.\nPSDL addresses these issues by introducing control abstractions that include declarative timing constraints. CAPS uses this information to automatically generate code and associated real-time schedules, monitor timing constraints during prototype execution, and simulate execution in proportional real time relative to a set of parameterized hardware models. It also provides default assumptions that enable execution of incomplete prototype descriptions, integrates prototype construction with a software reuse repository for rapidly realizing efficient implementations, and provides support for rapid evolution of requirements and designs. [ 21 ] References [ edit ] ^ Todd Grimm: The Human Condition: A Justification for Rapid Prototyping. Time Compression Technologies, vol. 3 no. 3. Accelerated Technologies, Inc. May 1998 . Page 1. [1] ^ \"Software Prototyping - INGSOFTWARE\" . ingsoftware.com . Retrieved 2018-06-27 . ^ Smith MF Software Prototyping: Adoption, Practice and Management . McGraw-Hill, London (1991). ^ Dewar, Robert B. K.; Fisher Jr., Gerald A.; Schonberg, Edmond; Froelich, Robert; Bryant, Stephen; Goss, Clinton F.; Burke, Michael (November 1980). \"The NYU Ada translator and interpreter\". Proceeding of the ACM-SIGPLAN symposium on Ada programming language - SIGPLAN '80 . Vol.\u00a015. pp. 194\u2013 201. doi : 10.1145/948632.948659 . ISBN 0-89791-030-3 . S2CID 10586359 . ^ SofTech Inc. (1983-04-11). \"Ada Compiler Validation Summary Report: NYU Ada/ED, Version 19.7 V-001\" . Archived from the original on 2012-03-12 . Retrieved 2010-12-16 . ^ a b c d e f John Crinnion: Evolutionary Systems Development, a practical guide to the use of prototyping within a structured systems methodology. Plenum Press, New York, 1991. Page 18. ^ a b c S. P. Overmyer: Revolutionary vs. Evolutionary Rapid Prototyping: Balancing Software Productivity and HCI Design Concerns. Center of Excellence in Command, Control, Communications and Intelligence (C3I), George Mason University, 4400 University Drive, Fairfax, Virginia. ^ a b c Alan M. Davis: Operational Prototyping: A new Development Approach. IEEE Software, September 1992. Page 71. ^ a b Software Productivity Consortium: Evolutionary Rapid Development. SPC document SPC-97057-CMC, version 01.00.04, June 1997. Herndon, Va. Page 6. ^ Davis. Page 72-73. Citing: E. Bersoff and A. Davis, Impacts of Life Cycle Models of Software Configuration Management. Comm. ACM, Aug. 1991, pp.\u00a0104\u2013118 ^ Komatineni, Satya. \"Reshaping IT Project Delivery Through Extreme Prototyping\" . Archived from the original on 2016-12-06. ^ Adapted from C. Melissa Mcclendon, Larry Regot, Gerri Akers. ^ Joseph E. Urban: Software Prototyping and Requirements Engineering. Rome Laboratory, Rome, NY. ^ Dynamic Systems Development Method Consortium. https://web.archive.org/web/20060209072841/http://na.dsdm.org/ ^ Adapted from Software Productivity Consortium. PPS 10\u201313. ^ How Simulation Software Can Streamline Application Development Archived 2012-07-22 at archive.today ^ a b c Dr. Ramon Acosta, Carla Burns, William Rzepka, and James Sidoran. Applying Rapid Prototyping Techniques in the Requirements Engineering Environment. IEEE, 1994. [2] ^ Software Productivity Solutions, Incorporated. Advanced Requirements Engineering Workstation (AREW). 1996. [3] ^ Luqi; Berzins, Yeh (October 1988). \"A Prototyping Language for Real-Time Software\" (PDF) . IEEE Transactions on Software Engineering . 14 (10): 1409\u2013 1423. doi : 10.1109/32.6186 . hdl : 10945/39162 . S2CID 35348234 . ^ Luqi; Ketabchi (March 1988). \"A Computer-Aided Prototyping System\". IEEE Software . 5 (2): 66\u2013 72. doi : 10.1109/52.2013 . hdl : 10945/43616 . S2CID 15541544 . ^ Luqi (May 1989). \"Software Evolution through Rapid Prototyping\" . IEEE Computer . 22 (5): 13\u2013 25. doi : 10.1109/2.27953 . hdl : 10945/43610 . S2CID 1809234 . v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_prototyping&oldid=1293143867 \" Category : Software development Hidden categories: Webarchive template archiveis links Articles with short description Short description matches Wikidata All articles with unsourced statements Articles with unsourced statements from March 2010 Articles with unsourced statements from January 2015 This page was last edited on 31 May 2025, at 00:00 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software prototyping 15 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Waterfall_model",
    "title": "Waterfall model - Wikipedia",
    "content": "Waterfall model - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Phases Toggle Phases subsection 2.1 Preliminary analysis 2.2 Systems analysis, requirements definition 2.3 Systems design 2.4 Development 2.5 Integration and testing 2.6 Acceptance, installation, deployment 2.7 Maintenance 2.8 Evaluation 2.9 Disposal 3 Supporting arguments 4 Criticism 5 Modified waterfall models 6 See also 7 References 8 External links Toggle the table of contents Waterfall model 35 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Az\u0259rbaycanca Catal\u00e0 \u010ce\u0161tina Dansk Deutsch Eesti Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais Galego \ud55c\uad6d\uc5b4 \u0939\u093f\u0928\u094d\u0926\u0940 Bahasa Indonesia Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Magyar \u0d2e\u0d32\u0d2f\u0d3e\u0d33\u0d02 Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0dc3\u0dd2\u0d82\u0dc4\u0dbd Suomi Svenska \u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Modelling software development in sequential phases This article needs to be updated . Please help update this article to reflect recent events or newly available information. ( October 2021 ) The waterfall model is the process of performing the typical software development life cycle (SDLC) phases in sequential order. Each phase is completed before the next is started, and the result of each phase drives subsequent phases. [ 1 ] Compared to alternative SDLC methodologies such as Agile , it is among the least iterative and flexible, [ 1 ] as progress flows largely in one direction (like a waterfall ) through the phases of conception, requirements analysis , design , construction , testing , deployment, and maintenance . [ 2 ] The waterfall model is the earliest SDLC methodology. [ 3 ] When first adopted, there were no recognized alternatives for knowledge-based creative work. [ 4 ] History [ edit ] The first known presentation describing the use of such phases in software engineering was held by Herbert D. Benington at the Symposium on Advanced Programming Methods for Digital Computers on 29 June 1956. [ 5 ] This presentation was about the development of software for SAGE . In 1983, Benington republished his paper with a foreword explaining that the phases were on purpose organized according to the specialization of tasks, and pointing out that the process was not in fact performed in a strict top-down fashion, but depended on a prototype. [ 6 ] [ better\u00a0source\u00a0needed ] Although the term \"waterfall\" is not used in the paper, the first formal, detailed diagram of the process is often [ 7 ] cited as coming from a 1970 article by Winston W. Royce . [ 8 ] [ 9 ] [ 10 ] However, he commented that it had major flaws stemming from how testing only happened at the end of the process, which he described as being \"risky and [inviting] failure\". [ 8 ] The rest of his paper introduced five steps which he felt were necessary to \"eliminate most of the development risks\" associated with the unaltered waterfall approach. [ 8 ] Royce's five additional steps (which included writing complete documentation at various stages of development) never took mainstream hold, but his diagram of what he considered a flawed process became the starting point when describing a \"waterfall\" approach. [ 11 ] [ 12 ] The earliest use of the term \"waterfall\" may have been in a 1976 paper by Bell and Thayer. [ 13 ] [ better\u00a0source\u00a0needed ] In 1985, the United States Department of Defense adopted the waterfall model in the DOD-STD-2167 standard for working with software development contractors. This standard referred for iterations of a software development [ 14 ] to \"the sequential phases of a software development cycle\" and stated that \"the contractor shall implement a software development cycle that includes the following six phases: Software Requirement Analysis, Preliminary Design, Detailed Design, Coding and Unit Testing, Integration, and Testing\". [ 14 ] [ 15 ] Phases [ edit ] The model describes a linear sequence of steps. Although various different versions can be found, the following describes the essence. [ 16 ] [ 17 ] [ 18 ] [ 19 ] Preliminary analysis [ edit ] Conduct with a preliminary analysis, consider alternative solutions, estimate costs and benefits, and submit a preliminary plan with recommendations. Conduct preliminary analysis: Identify the organization's objectives and define the nature and scope of the project. Ensure that the project fits with the objectives. Consider alternative solutions: Alternatives may come from interviewing employees, clients, suppliers, and consultants, as well as competitive analysis. Cost-benefit analysis: Analyze the costs and benefits of the project. Systems analysis, requirements definition [ edit ] Decompose project goals [ clarification needed ] into defined functions and operations. This involves gathering and interpreting facts, diagnosing problems, and recommending changes. Analyze end-user information needs and resolve inconsistencies and incompleteness: [ 20 ] Collect facts: Obtain end-user requirements by document review, client interviews, observation, and questionnaires. Scrutinize existing system(s): Identify pros and cons. Analyze the proposed system: Find solutions to issues and prepare specifications, incorporating appropriate user proposals. Systems design [ edit ] At this step, desired features and operations are detailed, including screen layouts, business rules , process diagrams , pseudocode , and other deliverables. Development [ edit ] Write the code. Integration and testing [ edit ] Assemble the modules in a testing environment. Check for errors, bugs, and interoperability. Acceptance, installation, deployment [ edit ] Put the system into production. This may involve training users, deploying hardware, and loading information from the prior system. Maintenance [ edit ] Monitor the system to assess its ongoing fitness. Make modest changes and fixes as needed. To maintain the quality of the system. Continual monitoring and updates ensure the system remains effective and high-quality. [ 21 ] Evaluation [ edit ] The system and the process are reviewed. Relevant questions include whether the newly implemented system meets requirements and achieves project goals, whether the system is usable, reliable/available, properly scaled and fault-tolerant. Process checks include review of timelines and expenses, as well as user acceptance. Disposal [ edit ] At end of life, plans are developed for discontinuing the system and transitioning to its replacement. Related information and infrastructure must be repurposed, archived, discarded, or destroyed, while appropriately protecting security. [ 22 ] Supporting arguments [ edit ] Time spent early in the software production cycle can reduce costs at later stages. For example, a problem found in the early stages (such as requirements specification) is cheaper to fix than the same bug found later on in the process (by a factor of 50 to 200). [ 23 ] In common practice, waterfall methodologies result in a project schedule with 20\u201340% of the time invested for the first two phases, 30\u201340% of the time to coding, and the rest dedicated to testing and implementation. With the project organization needing to be highly structured, most medium and large projects will include a detailed set of procedures and controls, which regulate every process on the project. [ 24 ] [ failed verification ] A further argument supporting the waterfall model is that it places emphasis on documentation (such as requirements documents and design documents) as well as source code . [ citation needed ] In less thoroughly designed and documented methodologies, knowledge is lost if team members leave before the project is completed, and it may be difficult for a project to recover from the loss. If a fully working design document is present (as is the intent of big design up front and the waterfall model), new team members and new teams should be able to familiarise themselves to the project by reading the documents. [ 25 ] The waterfall model provides a structured approach; the model itself progresses linearly through discrete, easily understandable and explainable phases and thus is easy to understand. It also provides easily identifiable milestones in the development process, often being used as a beginning example of a development model in many software engineering texts and courses. [ 26 ] Similarly, simulation can play a valuable role within the waterfall model. [ 27 ] By creating computerized or mathematical simulations of the system being developed, teams can gain insights into how the system will perform before proceeding to the next phase. Simulations allow for testing and refining the design, identifying potential issues or bottlenecks, and making informed decisions about the system's functionality and performance. Criticism [ edit ] Clients may not know the exact requirements before they see working software and thus change their requirements further on, leading to redesign, redevelopment, and retesting, and increased costs. [ 28 ] Designers may not be aware of future difficulties when designing a new software product or feature, in which case revising the design initially can increase efficiency in comparison to a design not built to account for newly discovered constraints, requirements, or problems. [ 29 ] Organisations may attempt to deal with a lack of concrete requirements from clients by employing systems analysts to examine existing manual systems and analyse what they do and how they might be replaced. However, in practice, it is difficult to sustain a strict separation between systems analysis and programming, [ 30 ] as implementing any non-trivial system will often expose issues and edge cases that the systems analyst did not consider. Some organisations, such as the United States Department of Defense, now have a stated preference against waterfall-type methodologies, starting with MIL-STD-498 released in 1994, which encourages evolutionary acquisition and iterative and incremental development . [ 31 ] Modified waterfall models [ edit ] In response to perceived problems with the original, pure waterfall model, many modified versions have been devised to address the problems. These include the rapid development models that Steve McConnell calls \"modified waterfalls\": [ 23 ] Peter DeGrace's \"sashimi model\" (waterfall with overlapping phases), waterfall with subprojects, and waterfall with risk reduction.  Other software development model combinations such as \"incremental waterfall model\" also exist. [ 32 ] Royce final model Royce's final model illustrated that feedback could (should, and often would) lead from code testing to design (as testing of code uncovered flaws in the design) and from design back to requirements specification (as design problems may necessitate the removal of conflicting or otherwise unsatisfiable/undesignable requirements). [ citation needed ] In the same paper Royce also advocated large quantities of documentation, doing the job \"twice if possible\" (a sentiment similar to that of Fred Brooks , famous for writing the Mythical Man Month \u2014 an influential book in software project management \u2014 who advocated planning to \"throw one away\"), and involving the customer as much as possible (a sentiment similar to that of extreme programming ). Royce notes on the final model are: Complete program design before analysis and coding begins Documentation must be current and complete Do the job twice if possible Testing must be planned, controlled, and monitored Involve the customer See also [ edit ] List of software development philosophies Agile software development Big design up front Chaos model DevOps Iterative and incremental development Monitoring Maintenance Lifecycle Object-oriented analysis and design Rapid application development Software development process Spiral model Structured Systems Analysis and Design Method (SSADM) System development methodology Traditional engineering V-model References [ edit ] ^ a b Petersen, Kai; Wohlin, Claes; Baca, Dejan (2009). \"The Waterfall Model in Large-Scale Development\" . In Bomarius, Frank; Oivo, Markku; Jaring, P\u00e4ivi; Abrahamsson, Pekka (eds.). Product-Focused Software Process Improvement . Lecture Notes in Business Information Processing. Vol.\u00a032. Berlin, Heidelberg: Springer . pp. 386\u2013 400. Bibcode : 2009pfsp.book..386P . doi : 10.1007/978-3-642-02152-7_29 . ISBN 978-3-642-02152-7 . ^ Tom Gilb (1985). \"Evolutionary Delivery versus the \"waterfall model\" \". ACM SIGSOFT Software Engineering Notes . 10 (3): 49\u2013 61. doi : 10.1145/1012483.1012490 . ^ Linda Sherrell (2013). \"Waterfall Model\". In A. L. C. Runehov; L. Oviedo (eds.). Encyclopedia of Sciences and Religions . Dordrecht , The Netherlands: Springer . pp. 2343\u2013 2344. doi : 10.1007/978-1-4020-8265-8_200285 . ISBN 978-1-4020-8264-1 . ^ Andreas P. Schmidt; Christine Kunzmann (September 16, 2014). Designing for knowledge maturing: from knowledge-driven software to supporting the facilitation of knowledge development . i-KNOW '14: Proceedings of the 14th International Conference on Knowledge Technologies and Data-driven Business. ACM . pp. 1\u2013 7. doi : 10.1145/2637748.2638421 . ^ United States, Navy Mathematical Computing Advisory Panel (29 June 1956), Symposium on advanced programming methods for digital computers , [Washington, D.C.]: Office of Naval Research, Dept. of the Navy, OCLC 10794738 ^ Benington, Herbert D. (1 October 1983). \"Production of Large Computer Programs\" (PDF) . IEEE Annals of the History of Computing . 5 (4). IEEE Educational Activities Department: 350\u2013 361. doi : 10.1109/MAHC.1983.10102 . S2CID 8632276 . Archived from the original (PDF) on 2011-07-18 . Retrieved 2011-03-21 . ^ Larman, Craig; Basili, Victor (June 2003). \"Iterative and Incremental Development: A Brief History\" (PDF) . Computer . 36 (6): 47\u2013 56. doi : 10.1109/MC.2003.1204375 . ^ a b c Royce, Winston (1970), \"Managing the Development of Large Software Systems\" , Proceedings of IEEE WESCON , 26 (August): 1\u2013 9 ^ \"Waterfall\" . Bremen University - Mathematics and Computer Science . Archived from the original on 2022-01-19 . Retrieved 2021-04-15 . ^ Abbas, Noura; Gravell, Andrew M.; Wills, Gary B. (2008). \"Historical Roots of Agile Methods: Where Did \"Agile Thinking\" Come From?\" (PDF) . In Abrahamsson, Pekka; Baskerville, Richard; Conboy, Kieran; Fitzgerald, Brian; Morgan, Lorraine; Wang, Xiaofeng (eds.). Agile Processes in Software Engineering and Extreme Programming . Lecture Notes in Business Information Processing. Vol.\u00a09. Berlin, Heidelberg: Springer . pp. 94\u2013 103. doi : 10.1007/978-3-540-68255-4_10 . ISBN 978-3-540-68255-4 . ^ Conrad Weisert, Waterfall methodology: there's no such thing! ^ Lineberger, Rob (Apr 25, 2024). Inheriting Agile: The IT Practitioner's Guide to Managing Software Development in a Post-Agile World . Durham, NC: Sandprint Press. p.\u00a036. ISBN 9798989149605 . ^ Bell, Thomas E., and T. A. Thayer. Software requirements: Are they really a problem? Proceedings of the 2nd international conference on Software engineering. IEEE Computer Society Press, 1976. ^ a b DOD-STD-2167 - Military Standard\u00a0: Defence System Software Development\" . Department of Defence, United States of America. 1985-06-04. p.\u00a011. ^ \"Military Standard Defense System Software Development\" (PDF) . ^ US Department of Justice (2003). INFORMATION RESOURCES MANAGEMENT Chapter 1. Introduction. ^ Everatt, G.D.; McLeod, R Jr (2007). \"Chapter 2: The Software Development Life Cycle\" . Software Testing: Testing Across the Entire Software Development Life Cycle . John Wiley & Sons. pp. 29\u2013 58. ISBN 9780470146347 . ^ Kay, Russell (May 14, 2002). \"QuickStudy: System Development Life Cycle\" . ComputerWorld . ^ Taylor, G.D. (2008). Introduction to Logistics Engineering . CRC Press. pp. 12.6 \u2013 12.18 . ISBN 9781420088571 . ^ \"Chapter 5\". Information Systems Control and Audit (PDF) . Institute of Chartered Accountants of India. August 2013. p.\u00a05.28. ^ Shah, Kazim. \"The Maintenance Phase Of Software Development Life Cycle\" . primetechnologiesglobal . kazim shah . Retrieved 12 May 2024 . ^ Radack, S. (n.d.). \"The system development life cycle (SDLC)\" (PDF) . National Institute of Standards and Technology. ^ a b McConnell, Steve (1996). Rapid Development: Taming Wild Software Schedules . Microsoft Press. ISBN 1-55615-900-5 . ^ \"Waterfall Software Development Model\" . 5 February 2014 . Retrieved 11 August 2014 . ^ Arcisphere technologies (2012). \"Tutorial: The Software Development Life Cycle (SDLC)\" (PDF) . Retrieved 2012-11-13 . ^ Hughey, Douglas (2009). \"Comparing Traditional Systems Analysis and Design with Agile Methodologies\" . University of Missouri \u2013 St. Louis . Retrieved 11 August 2014 . ^ Saravanos, Antonios; Curinga, Matthew X. (December 2023). \"Simulating the Software Development Lifecycle: The Waterfall Model\" . Applied System Innovation . 6 (6): 108. arXiv : 2308.03940 . doi : 10.3390/asi6060108 . ISSN 2571-5577 . ^ Parnas, David L.; Clements, Paul C. (1986). \"A rational design process: How and why to fake it\" (PDF) . IEEE Transactions on Software Engineering (2): 251\u2013 257. doi : 10.1109/TSE.1986.6312940 . S2CID 5838439 . Retrieved 2011-03-21 . ^ McConnell, Steve (2004). Code Complete, 2nd edition . Microsoft Press. ISBN 1-55615-484-4 . ^ Ensmenger, Nathan (2010). The Computer Boys Take Over . MIT Press. p. 42 . ISBN 978-0-262-05093-7 . ^ Larman, Craig; Basili, Victir (2003). \"Iterative and Incremental Development: A Brief History\" . IEEE Computer . 36 (6) (June\u00a0ed.): 47\u2013 56. doi : 10.1109/MC.2003.1204375 . S2CID 9240477 . ^ \"Methodology:design methods\" . Archived from the original on 2016-03-03 . Retrieved 2018-05-16 . External links [ edit ] Wikimedia Commons has media related to Waterfall models . Understanding the pros and cons of the Waterfall Model of software development Project lifecycle models: how they differ and when to use them Going Over the Waterfall with the RUP by Philippe Kruchten CSC and IBM Rational join to deliver C-RUP and support rapid business change c2:WaterFall [1] v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Waterfall_model&oldid=1328008408 \" Categories : Software development philosophies Project management Design Hidden categories: Articles with short description Short description is different from Wikidata Wikipedia articles in need of updating from October 2021 All Wikipedia articles in need of updating Use British English from January 2023 All Wikipedia articles written in British English All articles lacking reliable references Articles lacking reliable references from March 2021 Wikipedia articles needing clarification from January 2023 All articles with failed verification Articles with failed verification from March 2021 All articles with unsourced statements Articles with unsourced statements from March 2021 Commons category link is on Wikidata This page was last edited on 17 December 2025, at 10:54 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Waterfall model 35 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Spiral_model",
    "title": "Spiral model - Wikipedia",
    "content": "Spiral model - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 The six invariants of spiral model Toggle The six invariants of spiral model subsection 2.1 Define artifacts concurrently 2.2 Perform four basic activities in every cycle 2.3 Risk determines level of effort 2.4 Risk determines degree of details 2.5 Use anchor point milestones 2.6 Focus on the system and its life cycle 3 References Toggle the table of contents Spiral model 23 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 Dansk Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Bahasa Indonesia Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Magyar Nederlands \u65e5\u672c\u8a9e Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Software development process model This article relies excessively on references to primary sources . Please improve this article by adding secondary or tertiary sources . Find sources: \"Spiral model\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( February 2017 ) ( Learn how and when to remove this message ) Spiral model (Boehm, 1988). A number of misconceptions stem from oversimplifications in this widely circulated diagram (there are some errors in this diagram). [ 1 ] Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e The spiral model is a risk-driven software development process model. Based on the unique risk patterns of a given project, the spiral model guides a team to adopt elements of one or more process models, such as incremental , waterfall , or evolutionary prototyping . History [ edit ] This model was first described by Barry Boehm in his 1986 paper, \"A Spiral Model of Software Development and Enhancement.\" [ 2 ] In 1988 Boehm published a similar paper [ 3 ] to a wider audience. These papers introduce a diagram that has been reproduced in many subsequent publications discussing the spiral model. These early papers use the term \"process model\" to refer to the spiral model as well as to incremental, waterfall, prototyping, and other approaches. However, the spiral model's characteristic risk-driven blending of other process models' features is already present: [R]isk-driven subsetting of the spiral model steps allows the model to accommodate any appropriate mixture of a specification-oriented, prototype-oriented, simulation-oriented, automatic transformation-oriented, or other approach to software development. [ 3 ] In later publications, [ 1 ] Boehm describes the spiral model as a \"process model generator,\" where choices based on a project's risks generate an appropriate process model for the project. Thus, the incremental, waterfall, prototyping, and other process models are special cases of the spiral model that fit the risk patterns of certain projects. Boehm also identifies a number of misconceptions arising from oversimplifications in the original spiral model diagram. He says the most dangerous of these misconceptions are: that the spiral is simply a sequence of waterfall increments; that all project activities follow a single spiral sequence; that every activity in the diagram must be performed, and in the order shown. While these misconceptions may fit the risk patterns of a few projects, they are not true for most projects. In a National Research Council report [ 4 ] this model was extended to include risks related to human users. To better distinguish them from \"hazardous spiral look-alikes,\" Boehm lists six characteristics common to all authentic applications of the spiral model. [ citation needed ] The six invariants of spiral model [ edit ] Authentic applications of the spiral model are driven by cycles that always display six characteristics. Boehm illustrates each with an example of a \"dangerous spiral look-alike\" that violates the invariant. [ 1 ] Define artifacts concurrently [ edit ] Sequentially defining the key artifacts for a project often increases the possibility of developing a system that meets stakeholder \"win conditions\" (objectives and constraints). This invariant excludes \u201chazardous spiral look-alike\u201d processes that use a sequence of incremental waterfall passes in settings where the underlying assumptions of the waterfall model do not apply. Boehm lists these assumptions as follows: The requirements are known in advance of implementation. The requirements have no unresolved, high-risk implications, such as risks due to cost, schedule, performance, safety, user interfaces, organizational impacts, etc. The nature of the requirements will not change very much during development or evolution. The requirements are compatible with all the key system stakeholders\u2019 expectations, including users, customer, developers, maintainers, and investors. The right architecture for implementing the requirements is well understood. There is enough calendar time to proceed sequentially. In situations where these assumptions do apply, it is a project risk not to specify the requirements and proceed sequentially. The waterfall model thus becomes a risk-driven special case of the spiral model. Perform four basic activities in every cycle [ edit ] This invariant identifies the four activities that must occur in each cycle of the spiral model: Consider the win conditions of all success-critical stakeholders. Identify and evaluate alternative approaches for satisfying the win conditions. Identify and resolve risks that stem from the selected approach(es). Obtain approval from all success-critical stakeholders, plus commitment to pursue the next cycle. Project cycles that omit or shortchange any of these activities risk wasting effort by pursuing options that are unacceptable to key stakeholders, or are too risky. Some \"hazardous spiral look-alike\" processes violate this invariant by excluding key stakeholders from certain sequential phases or cycles. For example, system maintainers and administrators might not be invited to participate in definition and development of the system. As a result, the system is at risk of failing to satisfy their win conditions. Risk determines level of effort [ edit ] For any project activity (e.g., requirements analysis, design, prototyping, testing), the project team must decide how much effort is enough. In authentic spiral process cycles, these decisions are made by minimizing overall risk. For example, investing additional time testing a software product often reduces the risk due to the marketplace rejecting a shoddy product. However, additional testing time might increase the risk due to a competitor's early market entry. From a spiral model perspective, testing should be performed until the total risk is minimized, and no further. [ citation needed ] \"Hazardous spiral look-alikes\" that violate this invariant include evolutionary processes that ignore risk due to scalability issues, and incremental processes that invest heavily in a technical architecture that must be redesigned or replaced to accommodate future increments of the product. Risk determines degree of details [ edit ] For any project artifact (e.g., requirements specification, design document, test plan), the project team must decide how much detail is enough. In authentic spiral process cycles, these decisions are made by minimizing overall risk. Considering requirements specification as an example, the project should precisely specify those features where risk is reduced through precise specification (e.g., interfaces between hardware and software, interfaces between prime and sub-contractors). Conversely, the project should not precisely specify those features where precise specification increases the risk (e.g., graphical screen layouts, the behavior of off-the-shelf components). Use anchor point milestones [ edit ] Boehm's original description of the spiral model did not include any process milestones. In later refinements, he introduces three anchor point milestones that serve as progress indicators and points of commitment. These anchor point milestones can be characterized by key questions. Life Cycle Objectives. Is there a sufficient definition of a technical and management approach to satisfying everyone's win conditions? If the stakeholders agree that the answer is \"Yes\", then the project has cleared this LCO milestone. Otherwise, the project can be abandoned, or the stakeholders can commit to another cycle to try to get to \"Yes.\" Life Cycle Architecture. Is there a sufficient definition of the preferred approach to satisfying everyone's win conditions, and are all significant risks eliminated or mitigated? If the stakeholders agree that the answer is \"Yes\", then the project has cleared this LCA milestone. Otherwise, the project can be abandoned, or the stakeholders can commit to another cycle to try to get to \"Yes.\" Initial Operational Capability. Is there sufficient preparation of the software, site, users, operators, and maintainers to satisfy everyone's win conditions by launching the system? If the stakeholders agree that the answer is \"Yes\", then the project has cleared the IOC milestone and is launched. Otherwise, the project can be abandoned, or the stakeholders can commit to another cycle to try to get to \"Yes.\" \"Hazardous spiral look-alikes\" that violate this invariant include evolutionary and incremental processes that commit significant resources to implementing a solution with a poorly defined architecture. [ clarification needed ] The three anchor point milestones fit easily into the Rational Unified Process (RUP), with LCO marking the boundary between RUP's Inception and Elaboration phases, LCA marking the boundary between Elaboration and Construction phases, and IOC marking the boundary between Construction and Transition phases. Focus on the system and its life cycle [ edit ] This invariant highlights the importance of the overall system and the long-term concerns spanning its entire life cycle. It excludes \"hazardous spiral look-alikes\" that focus too much on the initial development of software code. These processes can result from following published approaches to object-oriented or structured software analysis and design while neglecting other aspects of the project's process needs. References [ edit ] ^ a b c Boehm, B (July 2000). \"Spiral Development: Experience, Principles, and Refinements\" (PDF) . Special Report . Software Engineering Institute. CMU/SEI-2000-SR-008. ^ Boehm, B (August 1986). \"A Spiral Model of Software Development and Enhancement\". ACM SIGSOFT Software Engineering Notes . 11 (4): 14\u2013 24. doi : 10.1145/12944.12948 . S2CID 207165409 . ^ a b Boehm, B (May 1988). \"A Spiral Model of Software Development and Enhancement\" (PDF) . IEEE Computer . 21 (5): 61\u2013 72. doi : 10.1109/2.59 . S2CID 1781829 . Archived March 6, 2023, at the Wayback Machine ^ Pew, R.W.; Mavor, A.S., eds. (2007). Human-system integration in the system development process: A new look . Washington, D.C.: National Academy Press. doi : 10.17226/11893 . ISBN 978-0-309-10720-4 . v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Spiral_model&oldid=1258416251 \" Categories : Software development process Spirals Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata Articles lacking reliable references from February 2017 All articles lacking reliable references All articles with unsourced statements Articles with unsourced statements from August 2014 Articles with unsourced statements from March 2017 Wikipedia articles needing clarification from August 2014 This page was last edited on 19 November 2024, at 16:21 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Spiral model 23 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/V-model_(software_development)",
    "title": "V-model (software development) - Wikipedia",
    "content": "V-model (software development) - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Project definition phases Toggle Project definition phases subsection 1.1 Requirements analysis 1.2 System design 1.3 Architecture design 1.4 Module design 2 Validation phases Toggle Validation phases subsection 2.1 Unit testing 2.2 Integration testing 2.3 System testing 2.4 User acceptance testing 3 Criticism 4 Current state 5 See also 6 References 7 Further reading Toggle the table of contents V-model (software development) 24 languages Afrikaans \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais Galego \ud55c\uad6d\uc5b4 Bahasa Indonesia Italiano Magyar Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip Suomi T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Software development methodology This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"V-model\"\u00a0software development \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( September 2018 ) ( Learn how and when to remove this message ) The V-model of the Systems Engineering Process [ 1 ] Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e In software development , the V-model [ 2 ] represents a development process that may be considered an extension of the waterfall model and is an example of the more general V-model . Instead of moving down linearly, the process steps are bent upwards after the coding phase, to form the typical V shape. The V-Model demonstrates the relationships between each phase of the development life cycle and its associated phase of testing . The horizontal and vertical axes represent time or project completeness (left-to-right) and level of abstraction (coarsest-grain abstraction uppermost), respectively. Project definition phases [ edit ] Requirements analysis [ edit ] In the requirements analysis phase, the first step in the verification process, the requirements of the system are collected by analyzing the needs of the user(s) . This phase is concerned with establishing what the ideal system has to perform. However, it does not determine how the software will be designed or built. Usually, the users are interviewed and a document called the user requirements document is generated. The user requirements document will typically describe the system's functional, interface, performance, data, security, etc. requirements as expected by the user. It is used by business analysts to communicate their understanding of the system to the users. The users carefully review this document as this document would serve as the guideline for the system designers in the system design phase. The user acceptance tests are designed in this phase. See also Functional requirements . There are different methods for gathering requirements of both soft and hard methodologies including; interviews, questionnaires, document analysis, observation, throw-away prototypes, use case , and static and dynamic views with users. System design [ edit ] Systems design is the phase where system engineers analyze and understand the business of the proposed system by studying the user requirements document. They figure out possibilities and techniques by which the user requirements can be implemented. If any of the requirements are not feasible, the user is informed of the issue. A resolution is found and the user requirement document is edited accordingly. The software specification document which serves as a blueprint for the development phase is generated. This document contains the general system organization, menu structures, data structures etc. It may also hold example business scenarios, sample windows, and reports to aid understanding. Other technical documentation like entity diagrams, and data dictionaries will also be produced in this phase. The documents for system testing are prepared. Architecture design [ edit ] The phase of the design of computer architecture and software architecture can also be referred to as high-level design. The baseline in selecting the architecture is that it should realize all which typically consists of the list of modules, brief functionality of each module, their interface relationships, dependencies , database tables , architecture diagrams, technology details, etc. The integration testing design is carried out in the particular phase. [ 3 ] Module design [ edit ] The module design phase can also be referred to as low-level design. The designed system is broken up into smaller units or modules and each of them is explained so that the programmer can start coding directly.\nThe low-level design document or program specifications will contain a detailed functional logic of the module , in pseudocode : database tables, with all elements, including their type and size all interface details with complete API references all dependency issues error message listings complete input and outputs for a module. The unit test design is developed in this stage. Validation phases [ edit ] In the V-model, each stage of the design phase has a corresponding stage in the validation phase. [ 4 ] The following are the typical phases of validation in the V-Model, though they may be known by other names. Unit testing [ edit ] In the V-Model, Unit Test Plans (UTPs) are developed during the module design phase. These UTPs are executed to eliminate bugs at the code level or unit level. A unit is the smallest entity that can independently exist, e.g. a program module. Unit testing verifies that the smallest entity can function correctly when isolated from the rest of the codes/units. Integration testing [ edit ] Integration Test Plans are developed during the Architectural Design Phase. These tests verify that units created and tested independently can coexist and communicate among themselves. Test results are shared with the customer's team. System testing [ edit ] System Tests Plans are developed during the System Design Phase. Unlike Unit and Integration Test Plans, System Test Plans are composed by the client's business team. System Test ensures that expectations from the application developed are met. The whole application is tested for its functionality, interdependency, and communication. System Testing verifies that functional and non-functional requirements have been met. Load and performance testing, stress testing, regression testing , etc., are subsets of system testing. User acceptance testing [ edit ] User Acceptance Test (UAT) Plans are developed during the Requirements Analysis phase. Test Plans are composed by business users. UAT is performed in a user environment that resembles the production environment, using realistic data. UAT verifies that the delivered system meets the user's requirement and the system is ready for use in real-time. Criticism [ edit ] The V-Model has been criticized by Agile advocates and others as an inadequate model of software development for numerous reasons. [ 5 ] [ 6 ] [ 7 ] Criticisms include: It is too simple to accurately reflect the software development process, and can lead managers into a false sense of security. The V-Model reflects a project management view of software development and fits the needs of project managers, accountants and lawyers rather than software developers or users. Although it is easily understood by novices, that early understanding is useful only if the novice goes on to acquire a deeper understanding of the development process and how the V-Model must be adapted and extended in practice. If practitioners persist with their naive view of the V-Model they will have great difficulty applying it successfully. It is inflexible and encourages a rigid and linear view of software development and has no inherent ability to respond to change. It provides only a slight variant on the waterfall model and is therefore subject to the same criticisms as that model. It provides greater emphasis on testing, and particularly the importance of early test planning. However, a common practical criticism of the V-Model is that it leads to testing being squeezed into tight windows at the end of development when earlier stages have overrun but the implementation date remains fixed. It is consistent with, and therefore implicitly encourages, inefficient and ineffective approaches to testing. It implicitly promotes writing test scripts in advance rather than exploratory testing; it encourages testers to look for what they expect to find, rather than discover what is truly there. It also encourages a rigid link between the equivalent levels of either leg (e.g. user acceptance test plans being derived from user requirements documents), rather than encouraging testers to select the most effective and efficient way to plan and execute testing. It lacks coherence and precision. There is widespread confusion about what exactly the V-Model is. If one boils it down to those elements that most people would agree upon it becomes a trite and unhelpful representation of software development. Disagreement about the merits of the V-Model often reflects a lack of shared understanding of its definition. Current state [ edit ] Supporters of the V-Model argue that it has evolved and supports flexibility and agility throughout the development process. [ 8 ] They argue that in addition to being a highly disciplined approach, it promotes meticulous design, development, and documentation necessary to build stable software products. Lately, it is being adopted by the medical device industry. [ 9 ] [ 10 ] See also [ edit ] Product lifecycle management Systems development life cycle References [ edit ] ^ Clarus Concept of Operations. Archived 2009-07-05 at the Wayback Machine Publication No. FHWA-JPO-05-072, Federal Highway Administration (FHWA), 2005 ^ Kevin Forsberg and Harold Mooz , \"The Relationship of System Engineering to the Project Cycle\", in Proceedings of the First Annual Symposium of National Council on System Engineering, October 1991: 57\u201365. ^ What is V model - Advantages, disadvantages and when to use it ^ DeSpautz, Joseph; Kenneth S. Kovacs; Gerhard Werling (11 March 2008). \"GAMP Standards For Validation of Automated Systems\" . Pharmaceutical Processing. Archived from the original on 8 May 2012 . Retrieved 28 February 2012 . ^ \"V Model In Software Development\" , accessed October 14, 2024 (updated) ^ \"The Dangerous & Seductive V Model\" , archived version from September 15, 2019 ^ \"New Models for Test Development\" , accessed January 6, 2013 ^ \"Toward Agile Systems Engineering Processes\" , accessed August 9, 2022 ^ McHugh, Martin; McCaffery, Fergal; Casey, Valentine (2012). \"Barriers to Adopting Agile Practices when Developing Medical Device Software\" . Software Process Improvement and Capability Determination . Communications in Computer and Information Science. Vol.\u00a0290. pp. 141\u2013 147. doi : 10.1007/978-3-642-30439-2_13 . ISBN 978-3-642-30438-5 . ^ \"A Software Process Development, Assessment and Improvement Framework, for the Medical Device Industry \" Further reading [ edit ] Roger S. Pressman: Software Engineering: A Practitioner's Approach , The McGraw-Hill Companies, ISBN 0-07-301933-X Mark Hoffman & Ted Beaumont: Application Development: Managing the Project Life Cycle , Mc Press, ISBN 1-883884-45-4 Boris Beizer: Software Testing Techniques. Second Edition, International Thomson Computer Press, 1990, ISBN 1-85032-880-3 Wikimedia Commons has media related to V-models . v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=V-model_(software_development)&oldid=1299415717 \" Category : Software development process Hidden categories: Webarchive template wayback links Articles with short description Short description matches Wikidata Articles needing additional references from September 2018 All articles needing additional references Commons category link is locally defined Module:Interwiki extra: additional interwiki links This page was last edited on 8 July 2025, at 07:26 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents V-model (software development) 24 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Adaptive_software_development",
    "title": "Adaptive software development - Wikipedia",
    "content": "Adaptive software development - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 References Toggle the table of contents Adaptive software development 11 languages \u010ce\u0161tina Deutsch Espa\u00f1ol Fran\u00e7ais Bahasa Indonesia Italiano Magyar Nederlands Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Software development process Adaptive software development ( ASD ) is a software development process that grew out of the work by Jim Highsmith and Sam Bayer on rapid application development (RAD). It embodies the principle that continuous adaptation of the process to the work at hand is the normal state of affairs. Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Adaptive software development replaces the traditional waterfall cycle with a repeating series of speculate , collaborate , and learn cycles. This dynamic cycle provides for continuous learning and adaptation to the emergent state of the project. The characteristics of an ASD life cycle are that it is mission focused, feature based, iterative , timeboxed , risk driven, and change tolerant. As with RAD, ASD is also an antecedent to agile software development . The word speculate refers to the paradox of planning \u2013 it is more likely to assume that all stakeholders are comparably wrong for certain aspects of the project\u2019s mission, while trying to define it. During speculation, the project is initiated and adaptive cycle planning is conducted.\nAdaptive cycle planning uses project initiation information\u2014the customer\u2019s\nmission statement, project constraints (e.g., delivery dates or user descriptions), and\nbasic requirements\u2014to define the set of release cycles (software increments) that\nwill be required for the project. Collaboration refers to the efforts for balancing the work based on predictable parts of the environment (planning and guiding them) and adapting to the uncertain surrounding mix of changes caused by various factors, such as technology, requirements, stakeholders, software vendors.  The learning cycles, challenging all stakeholders, are based on the short iterations with design, build and testing. During these iterations the knowledge is gathered by making small mistakes based on false assumptions and correcting those mistakes, thus leading to greater experience and eventually mastery in the problem domain. [ 1 ] References [ edit ] ^ \"Messy, Exciting, and Anxiety-Ridden: Adaptive Software Development\" . Archived from the original on 2017-10-04 . Retrieved 2007-05-18 . Adaptive Software Development: A Collaborative Approach to Managing Complex Systems , Highsmith, J.A., 2000 New York: Dorset House, 392pp, ISBN 0-932633-40-4 Agile Project Management: Creating Innovative Products , Addison-Wesley , Jim Highsmith, March 2004, 277pp, ISBN 0-321-21977-5 Lev Virine & Michael Trumper (2007). Project Decisions: The Art and Science . Management Concepts. ISBN 978-1-56726-217-9 . Software Engineering: A Practitioner's Approach, Roger Pressman, Bruce Maxim. ISBN 978-0078022128 Retrieved from \" https://en.wikipedia.org/w/index.php?title=Adaptive_software_development&oldid=1317300099 \" Categories : Software development process Agile software development Hidden categories: Articles with short description Short description matches Wikidata This page was last edited on 17 October 2025, at 11:56 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Adaptive software development 11 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_development_methodology",
    "title": "Software development process - Wikipedia",
    "content": "Software development process - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Methodology Toggle Methodology subsection 1.1 History 1.2 Examples 1.3 Comparison 2 Process meta-models 3 See also 4 References 5 External links Toggle the table of contents Software development process 31 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Az\u0259rbaycanca \u09ac\u09be\u0982\u09b2\u09be Catal\u00e0 \u010ce\u0161tina \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 \u0939\u093f\u0928\u094d\u0926\u0940 Bahasa Indonesia Italiano Latvie\u0161u Magyar Nederlands \u65e5\u672c\u8a9e O\u02bbzbekcha / \u045e\u0437\u0431\u0435\u043a\u0447\u0430 Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u06a9\u0648\u0631\u062f\u06cc \u0421\u0440\u043f\u0441\u043a\u0438 / srpski \u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0627\u0631\u062f\u0648 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia (Redirected from Software development methodology ) Process by which software is developed This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Software development process\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( December 2010 ) ( Learn how and when to remove this message ) Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e A software development process prescribes a process for developing software . It typically divides an overall effort into smaller steps or sub-processes that are intended to ensure high-quality results. The process may describe specific deliverables \u2013 artifacts to be created and completed. [ 1 ] Although not strictly limited to it, software development process often refers to the high-level process that governs the development of a software system from its beginning to its end of life \u2013 known as a methodology, model or framework. The system development life cycle (SDLC) describes the typical phases that a development effort goes through from the beginning to the end of life for a system \u2013 including a software system. A methodology prescribes how engineers go about their work in order to move the system through its life cycle. A methodology is a classification of processes or a blueprint for a process that is devised for the SDLC. For example, many processes can be classified as a spiral model. Software process and software quality are closely interrelated; some unexpected facets and effects have been observed in practice. [ 2 ] Methodology [ edit ] The SDLC drives the definition of a methodology in that a methodology must address the phases of the SDLC. Generally, a methodology is designed to result in a high-quality system that meets or exceeds expectations (requirements) and is delivered on time and within budget even though computer systems can be complex and integrate disparate components. [ 3 ] Various methodologies have been devised, including waterfall , spiral , agile , rapid prototyping , incremental , and synchronize and stabilize. [ 4 ] A major difference between methodologies is the degree to which the phases are sequential vs. iterative. Agile methodologies, such as XP and scrum , focus on lightweight processes that allow for rapid changes. [ 5 ] Iterative methodologies, such as Rational Unified Process and dynamic systems development method , focus on stabilizing project scope and iteratively expanding or improving products. Sequential or big-design-up-front (BDUF) models, such as waterfall, focus on complete and correct planning to guide larger projects and limit risks to successful and predictable results. [ 6 ] Anamorphic development is guided by project scope and adaptive iterations. In scrum, [ 7 ] for example, one could say a single user story goes through all the phases of the SDLC within a two-week sprint. By contrast the waterfall methodology, where every business requirement [ citation needed ] is translated into feature/functional descriptions which are then all implemented typically over a period of months or longer. [ citation needed ] A project can include both a project life cycle (PLC) and an SDLC, which describe different activities. According to Taylor (2004), \"the project life cycle encompasses all the activities of the project , while the systems development life cycle focuses on realizing the product requirements \". [ 8 ] History [ edit ] The term SDLC is often used as an abbreviated version of SDLC methodology . Further, some use SDLC and traditional SDLC to mean the waterfall methodology. According to Elliott (2004), SDLC \"originated in the 1960s, to develop large scale functional business systems in an age of large scale business conglomerates . Information systems activities revolved around heavy data processing and number crunching routines\". [ 9 ] The structured systems analysis and design method (SSADM) was produced for the UK government Office of Government Commerce in the 1980s. Ever since, according to Elliott (2004), \"the traditional life cycle approaches to systems development have been increasingly replaced with alternative approaches and frameworks, which attempted to overcome some of the inherent deficiencies of the traditional SDLC\". [ 9 ] The main idea of the SDLC has been \"to pursue the development of information systems in a very deliberate, structured and methodical way, requiring each stage of the life cycle\u2013\u2013from the inception of the idea to delivery of the final system\u2013\u2013to be carried out rigidly and sequentially\" [ 9 ] within the context of the framework being applied. Other methodologies were devised later: 1970s Structured programming since 1969 Cap Gemini SDM , originally from PANDATA, the first English translation was published in 1974. SDM stands for System Development Methodology 1980s Structured systems analysis and design method (SSADM) from 1980 onwards Information Requirement Analysis/Soft systems methodology 1990s Object-oriented programming (OOP) developed in the early 1960s and became a dominant programming approach during the mid-1990s Rapid application development (RAD), since 1991 Dynamic systems development method (DSDM), since 1994 Scrum , since 1995 Team software process , since 1998 Rational Unified Process (RUP), maintained by IBM since 1998 Extreme programming , since 1999 2000s Agile Unified Process (AUP) maintained since 2005 by Scott Ambler Disciplined agile delivery (DAD) Supersedes AUP 2010s Scaled Agile Framework (SAFe) Large-Scale Scrum (LeSS) DevOps Since DSDM in 1994, all of the methodologies on the above list except RUP have been agile methodologies - yet many organizations, especially governments, still use pre-agile processes (often waterfall or similar). Examples [ edit ] The following are notable methodologies somewhat ordered by popularity. Agile Agile software development refers to a group of frameworks based on iterative development, where requirements and solutions evolve via collaboration between self-organizing cross-functional teams. The term was coined in the year 2001 when the Agile Manifesto was formulated. Waterfall The waterfall model is a sequential development approach, in which development flows one-way (like a waterfall) through the SDLC phases. Spiral In 1988, Barry Boehm published a software system development spiral model , which combines key aspects of the waterfall model and rapid prototyping , in an effort to combine advantages of top-down and bottom-up concepts. It emphases a key area many felt had been neglected by other methodologies: deliberate iterative risk analysis, particularly suited to large-scale complex systems. Incremental Various methods combine linear and iterative methodologies , with the primary objective of reducing inherent project risk by breaking a project into smaller segments and providing more ease-of-change during the development process. Prototyping Software prototyping is about creating prototypes, i.e. incomplete versions of the software program being developed. Rapid Rapid application development (RAD) is a methodology which favors iterative development and the rapid construction of prototypes instead of large amounts of up-front planning. The \"planning\" of software developed using RAD is interleaved with writing the software itself. The lack of extensive pre-planning generally allows software to be written much faster and makes it easier to change requirements. Shape Up Shape Up is a software development approach introduced by Basecamp in 2018. It is a set of principles and techniques that Basecamp developed internally to overcome the problem of projects dragging on with no clear end. Its primary target audience is remote teams. Shape Up has no estimation and velocity tracking, backlogs, or sprints, unlike waterfall , agile , or scrum . Instead, those concepts are replaced with appetite, betting, and cycles. As of 2022, besides Basecamp, notable organizations that have adopted Shape Up include UserVoice and Block. [ 10 ] [ 11 ] Chaos Chaos model has one main rule: always resolve the most important issue first. Incremental funding Incremental funding methodology - an iterative approach. Lightweight Lightweight methodology - a general term for methods that only have a few rules and practices. Structured systems analysis and design Structured systems analysis and design method - a specific version of waterfall. Slow programming As part of the larger slow movement , emphasizes careful and gradual work without (or minimal) time pressures. Slow programming aims to avoid bugs and overly quick release schedules. V-Model V-Model (software development) - an extension of the waterfall model. Unified Process Unified Process (UP) is an iterative software development methodology framework, based on Unified Modeling Language (UML). UP organizes the development of software into four phases, each consisting of one or more executable iterations of the software at that stage of development: inception, elaboration, construction, and guidelines. Comparison [ edit ] This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. ( January 2024 ) ( Learn how and when to remove this message ) The waterfall model describes the SDLC phases such that each builds on the result of the previous one. [ 12 ] [ 13 ] [ 14 ] [ 15 ] Not every project requires that the phases be sequential. For relatively simple projects, phases may be combined or overlapping. [ 12 ] Alternative methodologies to waterfall are described and compared below. [ 16 ] Comparison of methodologies Waterfall RAD Open source OOP JAD proto-typing End User Control Formal MIS Weak Standards Joint User User Time frame Long Short Medium Any Medium Short Short \u2013 Users Many Few Few Varies Few One or two One MIS staff Many Few Hundreds Split Few One or two None Transaction/ DSS Transaction Both Both Both DSS DSS DSS Interface Minimal Minimal Weak Windows Crucial Crucial Crucial Documentation and training Vital Limited Internal In Objects Limited Weak None Integrity and security Vital Vital Unknown In Objects Limited Weak Weak Reusability Limited Some Maybe Vital Limited Weak None Process meta-models [ edit ] Further information: Process patterns Some process models are abstract descriptions for evaluating, comparing, and improving the specific process adopted by an organization. ISO/IEC 12207 ISO/IEC 12207 is the international standard describing the method to select, implement, and monitor the life cycle for software. Capability Maturity Model Integration The Capability Maturity Model Integration (CMMI) is one of the leading models and is based on best practices. Independent assessments grade organizations on how well they follow their defined processes, not on the quality of those processes or the software produced. CMMI has replaced CMM . ISO 9000 ISO 9000 describes standards for a formally organized process to manufacture a product and the methods of managing and monitoring progress. Although the standard was originally created for the manufacturing sector, ISO 9000 standards have been applied to software development as well. Like CMMI, certification with ISO 9000 does not guarantee the quality of the end result, only that formalized business processes have been followed. ISO/IEC 15504 ISO/IEC 15504 Information technology\u2014Process assessment , a.k.a. Software Process Improvement Capability Determination (SPICE), is a framework for the assessment of software processes. This standard is aimed at setting out a clear model for process comparison. SPICE is used much like CMMI. It models processes to manage, control, guide, and monitor software development. This model is then used to measure what a development organization or project team actually does during software development. This information is analyzed to identify weaknesses and drive improvement. It also identifies strengths that can be continued or integrated into common practice for that organization or team. ISO/IEC 24744 ISO/IEC 24744 Software Engineering\u2014Metamodel for Development Methodologies , is a power type-based metamodel for software development methodologies. Soft systems methodology Soft systems methodology is a general method for improving management processes. Method engineering Method engineering is a general method for improving information system processes. See also [ edit ] Computer-aided software engineering List of software development philosophies Outline of software engineering Program lifecycle phase Software development effort estimation Software documentation Software project management Software release life cycle References [ edit ] ^ \"Selecting a development approach\" (PDF) . Centers for Medicare & Medicaid Services (CMS) Office of Information Service . United States Department of Health and Human Services (HHS). March 27, 2008 [Original Issuance: February 17, 2005]. Archived from the original (PDF) on June 20, 2012 . Retrieved October 27, 2008 . ^ Suryanarayana, Girish (2015). \"Software Process versus Design Quality: Tug of War?\" . IEEE Software . 32 (4): 7\u2013 11. doi : 10.1109/MS.2015.87 . ^ \"Systems Development Life Cycle from\" . FOLDOC . Retrieved June 14, 2013 . ^ \"Software Development Life Cycle (SDLC)\" (PDF) . softwarelifecyclepros.com . May 2012 . Retrieved June 26, 2025 . ^ \"SDLC Overview: Models & Methodologies\" . Retrieved December 12, 2021 . ^ Arden, Trevor (1991). Information technology applications . London: Pitman. ISBN 978-0-273-03470-4 . ^ \"What is Scrum?\" . December 24, 2019. ^ Taylor, James (2004). Managing Information Technology Projects . p.\u00a039. ^ a b c Geoffrey Elliott (2004). Global Business Information Technology: an integrated systems approach . Pearson Education. p.\u00a087. ^ \"Foreword by Jason Fried | Shape Up\" . basecamp.com . Retrieved September 11, 2022 . ^ \"Is Shape Up just a nice theory?\" . Curious Lab . Retrieved September 12, 2022 . ^ a b US Department of Justice (2003). INFORMATION RESOURCES MANAGEMENT Chapter 1. Introduction. ^ Everatt, G.D.; McLeod, R Jr (2007). \"Chapter 2: The Software Development Life Cycle\" . Software Testing: Testing Across the Entire Software Development Life Cycle . John Wiley & Sons. pp. 29\u2013 58. ISBN 9780470146347 . ^ Unhelkar, B. (2016). The Art of Agile Practice: A Composite Approach for Projects and Organizations . CRC Press. pp. 56\u2013 59. ISBN 9781439851197 . ^ Land, S.K. ; Smith, D.B.; Walz, J.W. (2012). Practical Support for Lean Six Sigma Software Process Definition: Using IEEE Software Engineering Standards . John Wiley & Sons. pp. 341\u2013 3. ISBN 9780470289952 . ^ Post, G., & Anderson, D., (2006). Management information systems: Solving business problems with information technology . (4th ed.).  New York:  McGraw-Hill Irwin. External links [ edit ] Wikimedia Commons has media related to Software development methodology . Selecting a development approach Archived January 2, 2019, at the Wayback Machine at cms.hhs.gov. Gerhard Fischer, \"The Software Technology of the 21st Century: From Software Reuse to Collaborative Software Design\" Archived September 15, 2009, at the Wayback Machine , 2001 v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_development_process&oldid=1325364542 \" Categories : Software development process Methodology Software engineering Hidden categories: Articles with short description Short description matches Wikidata Use mdy dates from December 2023 Articles needing additional references from December 2010 All articles needing additional references Use American English from April 2022 All Wikipedia articles written in American English All articles with unsourced statements Articles with unsourced statements from August 2021 Articles needing additional references from January 2024 Commons category link is on Wikidata Webarchive template wayback links This page was last edited on 2 December 2025, at 18:16 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software development process 31 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Iterative_and_incremental_development",
    "title": "Iterative and incremental development - Wikipedia",
    "content": "Iterative and incremental development - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Overview Toggle Overview subsection 1.1 Phases 1.2 Usage and history 2 Use in hardware and embedded systems 3 See also 4 References 5 Additional reading Toggle the table of contents Iterative and incremental development 15 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc \ud55c\uad6d\uc5b4 Italiano Nederlands \u65e5\u672c\u8a9e Polski \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u0421\u0440\u043f\u0441\u043a\u0438 / srpski \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Development methodology Iterative and incremental development is any combination of both iterative design (or iterative method) and incremental build model for development . Usage of the term began in software development , with a long-standing combination of the two terms iterative and incremental [ 1 ] having been widely suggested for large development efforts. For example, the 1985 DOD-STD-2167 [ 2 ] mentions (in section 4.1.2): \"During software development, more than one iteration of the software development cycle may be in progress at the same time.\" and \"This process may be described as an 'evolutionary acquisition' or 'incremental build' approach.\" In software, the relationship between iterations and increments is determined by the overall software development process . Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Iterative development model Overview [ edit ] A simplified version of a typical iteration cycle in agile project management The basic idea behind this method is to develop a system through repeated cycles (iterative) and in smaller portions at a time (incremental), allowing software developers to take advantage of what was learned during development of earlier parts or versions of the system. Learning comes from both the development and use of the system, where possible key steps in the process start with a simple implementation of a subset of the software requirements and iteratively enhance the evolving versions until the full system is implemented. At each iteration , design modifications are made and new functional capabilities are added. [ 3 ] The procedure itself consists of the initialization step, the iteration step, and the Project Control List. The initialization step creates a base version of the system. The goal for this initial implementation is to create a product to which the user can react. It should offer a sampling of the key aspects of the problem and provide a solution that is simple enough to understand and implement easily. To guide the iteration process, a project control list is created that contains a record of all tasks that need to be performed. It includes items such as new features to be implemented and areas of redesign of the existing solution. The control list is constantly being revised as a result of the analysis phase. An iteration involves redesign and implementation, which is meant to be simple, straightforward, and modular, supporting redesign at that stage or as a future task added to the project control list. [ clarification needed ] The level of design detail is not dictated by the iterative approach. In a light-weight iterative project the code may represent the major source of documentation of the system; however, in a critical iterative project a formal Software Design Document may be used. The analysis of an iteration is based upon user feedback and the program analysis facilities available. It involves analysis of the structure, modularity, usability , reliability, efficiency, and achievement of goals. The project control list is modified in light of the analysis results. Iterative development Phases [ edit ] Incremental development slices the system functionality into increments (portions). In each increment, a slice of functionality is delivered through cross-discipline work, from the requirements to the deployment . The Unified Process groups increments/iterations into phases: inception, elaboration, construction, and transition. Inception identifies project scope, requirements (functional and non-functional) and risks at a high level but in enough detail that work can be estimated. Elaboration delivers a working architecture that mitigates the top risks and fulfills the non-functional requirements. Construction incrementally fills-in the architecture with production-ready code produced from analysis, design, implementation, and testing of the functional requirements. Transition delivers the system into the production operating environment. Each of the phases may be divided into 1 or more iterations, which are usually time-boxed rather than feature-boxed. Architects and analysts work one iteration ahead of developers and testers to keep their work-product backlog full. Usage and history [ edit ] Many examples of early usage are provided in Craig Larman and Victor Basili 's article \"Iterative and Incremental Development: A Brief History\", [ 4 ] with one of the earliest being NASA's 1960s Project Mercury . Some of those Mercury engineers later formed a new division within IBM , where \"another early and striking example of a major IID success [was] the very heart of NASA\u2019s space shuttle software\u2014the primary avionics software system, which [they] built from 1977 to 1980. The team applied IID in a series of 17 iterations over 31 months, averaging around eight weeks per iteration. Their motivation for avoiding the waterfall life cycle was that the shuttle program\u2019s requirements changed during the software development process.\" [ 4 ] Some organizations, such as the US Department of Defense, have a preference for iterative methodologies, starting with MIL-STD-498 \"clearly encouraging evolutionary acquisition and IID\". The DoD Instruction 5000.2 released in 2000 stated a clear preference for IID: There are two approaches, evolutionary and single step [waterfall], to full capability. An evolutionary approach is preferred. \u2026 [In this] approach, the ultimate capability delivered to the user is divided into two or more blocks, with increasing increments of capability...software development shall follow an iterative spiral development process in which continually expanding software versions are based on learning from earlier development. It can also be done in phases. Recent revisions to DoDI 5000.02 no longer refer to \"spiral development,\" but do advocate the general approach as a baseline for software-intensive development/procurement programs. [ 5 ] In addition, the United States Agency for International Development (USAID) also employs an iterative and incremental developmental approach to its programming cycle to design, monitor, evaluate, learn and adapt international development projects with a project management approach that focuses on incorporating collaboration, learning, and adaptation strategies to iterate and adapt programming. [ 6 ] Use in hardware and embedded systems [ edit ] While the term iterative and incremental development got started in the software industry, many hardware and embedded software development efforts are using iterative and incremental techniques. Examples of this may be seen in a number of industries. One sector that has recently been substantially affected by this shift of thinking has been the space launch industry, with substantial new competitive forces at work brought about by faster and more extensive technology innovation brought to bear by the formation of private companies pursuing space launch. These companies, such as SpaceX [ 7 ] and Rocket Lab , [ 8 ] are now both providing commercial orbital launch services in the past decade, something that only six nations had done prior to a decade [ 9 ] ago. New innovation in technology development approaches, pricing, and service offerings\u2014including the ability that has existed only since 2016 to fly to space on a previously flown (reusable) booster stage \u2014further decreasing the price of obtaining access to space. [ 10 ] [ 7 ] SpaceX has been explicit about its effort to bring iterative design practices into the space industry, and uses the technique on spacecraft, launch vehicles, electronics and avionics, and operational flight hardware operations. [ 11 ] As the industry has begun to change, other launch competitors are beginning to change their long-term development practices with government agencies as well. For example, the large US launch service provider United Launch Alliance (ULA) began in 2015 a decade-long project to restructure its launch business\u2014reducing two lau nch vehicles to one \u2014using an iterative and incremental approach to get to a partially-reusable and much lower-cost launch system over the next decade. [ 12 ] See also [ edit ] Adaptive management Agile software development Continuous integration DevOps \u00a7\u00a0Incremental adoption Dynamic systems development method Goal-Driven Software Development Process Interaction design Kaizen Microsoft Solutions Framework Object-oriented analysis and design PDCA Rapid application development Release early, release often References [ edit ] ^ Larman, Craig (June 2003). \"Iterative and Incremental Development: A Brief History\" (PDF) . Computer . 36 (6): 47\u2013 56. doi : 10.1109/MC.2003.1204375 . ISSN 0018-9162 . S2CID 9240477 . We were doing incremental development as early as 1957, in Los Angeles, under the direction of Bernie Dimsdale [at IBM's ServiceBureau Corporation]. He was a colleague of John von Neumann , so perhaps he learned it there, or assumed it as totally natural. I do remember Herb Jacobs (primarily, though we all participated) developing a large simulation for Motorola, where the technique used was, as far as I can tell ...' ^ DOD-STD-2167 Defense Systems Software Development (04 JUN 1985) on everyspec.com ^ Farcic, Viktor (January 21, 2014). \"Software Development Models: Iterative and Incremental Development\" . Technology Conversations . Archived from the original on March 25, 2014. ^ a b Iterative and Incremental Development: A Brief History , Craig Larman and Victor Basili, IEEE Computer, June 2003 ^ Kendall, Frank; Gilmore, J. Michael; Halvorsen, Terry (2017-02-02). \"Operation of the Defense Acquisition System\" (PDF) . DoD Issuances . Under Secretary of Defense for Acquisition, Technology, and Logistics. pp. 12\u2013 14. Archived from the original (PDF) on 2017-08-09 . Retrieved 2017-08-09 . ^ USAID. \"ADS Chapter 201 Program Cycle Operational Policy\" Archived 2019-10-23 at the Wayback Machine . Retrieved April 19, 2017 ^ a b Belfiore, Michael (9 December 2013). \"The Rocketeer\" . Foreign Policy . Archived from the original on 10 December 2013 . Retrieved 11 November 2018 . ^ \"Exclusive Inside Look at Rocket Lab's Previously-secret new Mega Factory!\" . Everyday Astronaut . 11 October 2018. Archived from the original on 12 October 2018 . Retrieved 11 November 2018 . ^ Clark, Stephen (28 September 2008). \"Sweet Success at Last for Falcon 1 Rocket\" . Spaceflight Now . Retrieved 11 November 2018 . the first privately developed liquid-fueled rocket to successfully reach orbit. ^ Berger, Eric (2018-06-25). \"Russia's Proton rocket, which predates Apollo, will finally stop flying Technical problems, rise of SpaceX are contributing factors\" . arsTechica . Retrieved 2018-06-26 . the rapid rise of low-cost alternatives such as SpaceX's Falcon 9 rocket, have caused the number of Proton launches in a given year to dwindle from eight or so to just one or two. ^ Fernholz, Tim (21 October 2014). \"What it took for Elon Musk's SpaceX to disrupt Boeing, leapfrog NASA, and become a serious space company\" . Quartz . Retrieved 11 November 2018 . But SpaceX always thought of itself as a tech firm, and its clashes with NASA often took a form computer developers\u2014or anyone familiar with the troubled roll-out of healthcare.gov\u2014would recognize as generational. SpaceX followed an iterative design process, continually improving prototypes in response to testing. Traditional product management calls for a robust plan executed to completion, a recipe for cost overruns. ^ Gruss, Mike (2015-04-24). \"Evolution of a Plan\u00a0: ULA Execs Spell Out Logic Behind Vulcan Design Choices\" . Space News . Retrieved 25 April 2015 . ULA's April 13 announcement that it would develop a rocket dubbed Vulcan using an incremental approach whose first iteration essentially is an Atlas 5 outfitted with a new first stage. This article includes a list of general references , but it lacks sufficient corresponding inline citations . Please help to improve this article by introducing more precise citations. ( September 2010 ) ( Learn how and when to remove this message ) Additional reading [ edit ] Dr. Alistair Cockburn (May 2008). \"Using Both Incremental and Iterative Development\" (PDF) . STSC CrossTalk . 21 (5). USAF Software Technology Support Center: 27\u2013 30. ISSN 2160-1593 . Archived from the original (PDF) on 2012-05-26 . Retrieved 2011-07-20 . Craig Larman, Victor R. Basili (June 2003). \"Iterative and Incremental Development: A Brief History\" (PDF) . IEEE Computer . 36 (6). IEEE Computer Society: 47\u2013 56. doi : 10.1109/MC.2003.1204375 . ISSN 0018-9162 . S2CID 9240477 . Retrieved 2009-01-10 . v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Iterative_and_incremental_development&oldid=1320133207 \" Categories : Software development philosophies Software project management Hidden categories: CS1: unfit URL Webarchive template wayback links Articles with short description Short description is different from Wikidata Wikipedia articles needing clarification from October 2018 Articles lacking in-text citations from September 2010 All articles lacking in-text citations This page was last edited on 2 November 2025, at 23:05 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Iterative and incremental development 15 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/DevOps",
    "title": "DevOps - Wikipedia",
    "content": "DevOps - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Relevant metrics 3 Relationship to other approaches Toggle Relationship to other approaches subsection 3.1 Platform engineering 3.2 Agile 3.3 ArchOps 3.4 Continuous Integration and Delivery (CI/CD) 3.5 Database DevOps 3.6 Mobile DevOps 3.7 Site-reliability engineering 3.8 Toyota production system, lean thinking, kaizen 3.9 DevSecOps, shifting security left 4 Culture 5 GitOps 6 Best practices for cloud systems 7 See also 8 Notes 9 References 10 Further reading Toggle the table of contents DevOps 35 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Az\u0259rbaycanca \u09ac\u09be\u0982\u09b2\u09be \u0411\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f (\u0442\u0430\u0440\u0430\u0448\u043a\u0435\u0432\u0456\u0446\u0430) \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Bosanski Catal\u00e0 \u010ce\u0161tina Dansk Deutsch Eesti Espa\u00f1ol Euskara \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 \u0939\u093f\u0928\u094d\u0926\u0940 Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Kiswahili Magyar Nederlands \u65e5\u672c\u8a9e Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u06a9\u0648\u0631\u062f\u06cc \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Suomi \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikiversity Wikidata item Appearance move to sidebar hide Checked From Wikipedia, the free encyclopedia Page version status This is an accepted version of this page This is the latest accepted revision , reviewed on 16 November 2025 . Integration of software development and operations DevOps is the integration and automation of the software development and information technology operations . [ a ] DevOps encompasses necessary tasks of software development and can lead to shortening development time and improving the development life cycle . [ 1 ] According to Neal Ford, DevOps, particularly through continuous delivery , employs the \"Bring the pain forward\" principle, tackling tough tasks early, fostering automation and swift issue detection. [ 2 ] Software programmers and architects should use fitness functions to keep their software in check. [ 3 ] Although debated, [ b ] [ c ] [ d ] [ e ] DevOps is characterized by key principles: shared ownership, workflow automation, and rapid feedback.\nFrom an academic perspective, Len Bass , Ingo Weber, and Liming Zhu\u2014three computer science researchers from the CSIRO and the Software Engineering Institute \u2014suggested defining DevOps as \"a set of practices intended to reduce the time between committing a change to a system and the change being placed into normal production, while ensuring high quality\". [ 7 ] However, the term is used in multiple contexts. At its most successful, DevOps is a combination of specific practices, culture change, and tools. [ 8 ] History [ edit ] Proposals to combine software development methodologies with deployment and operations concepts began to appear in the late 80s and early 90s. [ 9 ] In 2009, the first conference named DevOps Days was held in Ghent , Belgium. The conference was founded by Belgian consultant, project manager and agile practitioner Patrick Debois. [ 10 ] [ 11 ] The conference has now spread to other countries. [ 12 ] In 2012, a report called \"State of DevOps\" was first published by Alanna Brown at Puppet Labs . [ 13 ] [ 14 ] As of 2014, the annual State of DevOps report was published by Nicole Forsgren , Gene Kim, Jez Humble and others. They stated that the adoption of DevOps was accelerating. [ 15 ] [ 16 ] Also in 2014, Lisa Crispin and Janet Gregory wrote the book More Agile Testing, containing a chapter on testing and DevOps. [ 17 ] [ 18 ] In 2016, the DORA metrics for throughput (deployment frequency, lead time for changes), and stability (mean time to recover, change failure rate) were published in the State of DevOps report. [ 13 ] However, the research methodology and metrics were criticized by experts. [ 19 ] [ 20 ] [ 21 ] [ 22 ] In response to these criticisms, the 2023 State of DevOps report [ 23 ] published changes that updated the stability metric \"mean time to recover\" to \"failed deployment recovery time\" acknowledging the confusion the former metric has caused. [ 24 ] Relevant metrics [ edit ] DevOps Research and Assessment (DORA) has developed a series of metrics which are intended to measure software development efficiency and reliability. These metrics include: [ 25 ] [ 26 ] Deployment Frequency: Time between code deployments. Mean Lead Time for Changes: Time between code commit and deployment. Change Failure Rate: Percentage of deployments causing production issues. Failed Deployment Recovery Time (formerly Mean Time To Recover) Reliability (added in 2021): Measures operational performance, focusing on availability and adherence to user expectations. Relationship to other approaches [ edit ] Many of the ideas fundamental to DevOps practices are inspired by, or mirror, other well known practices such as Lean and Deming's Plan-Do-Check-Act cycle, through to The Toyota Way and the Agile approach of breaking down components and batch sizes. [ 27 ] Contrary to the \"top-down\" prescriptive approach and rigid framework of ITIL in the 1990s, DevOps is \"bottom-up\" and flexible, having been created by software engineers for their own needs. [ 28 ] Platform engineering [ edit ] Main article: Platform engineering Platform engineering is an emerging discipline within software engineering that supports DevOps by building and maintaining internal developer platforms (IDPs). These platforms provide standardized tools and reusable components\u2014such as CI/CD pipelines, infrastructure provisioning, observability, and security controls\u2014to streamline software delivery and reduce the cognitive load on developers. The goal is to enable self-service capabilities, improve productivity, and ensure consistency across development and operations teams. [ 29 ] [ 30 ] Agile [ edit ] Main article: Agile software development The motivations for what has become modern DevOps and several standard DevOps practices such as automated build and test, continuous integration , and continuous delivery originated in the Agile world, which dates (informally) to the 1990s, and formally to 2001. Agile development teams using methods such as extreme programming couldn't \"satisfy the customer through early and continuous delivery of valuable software\" [ 31 ] unless they took responsibility for operations and infrastructure for their applications, automating much of that work. Because Scrum emerged as the dominant Agile framework in the early 2000s and it omitted the engineering practices that were part of many Agile teams, the movement to automate operations and infrastructure functions splintered from Agile and expanded into what has become modern DevOps. Today, DevOps focuses on the deployment of developed software, whether it is developed using Agile oriented methodologies or other methodologies. ArchOps [ edit ] ArchOps presents an extension for DevOps practice, starting from software architecture artifacts, instead of source code, for operation deployment. [ 32 ] ArchOps states that architectural models are first-class entities in software development, deployment, and operations. Continuous Integration and Delivery (CI/CD) [ edit ] Main article: CI/CD Automation is a core principle for achieving DevOps success and CI/CD is a critical component. [ 33 ] Plus, improved collaboration and communication between and within teams helps achieve faster time to market , with reduced risks. [ 34 ] Database DevOps [ edit ] Database DevOps applies DevOps and CI/CD principles directly to database development and operations. Integrating schema changes, migrations, reference data, and other data-layer updates into the same version-controlled and automated pipelines used for application code enables more reliable deployments and better coordination between application and data changes. [ 35 ] [ 36 ] Typical practices documented in both research and industry benchmarks include placing database schema definitions under version control, applying automated tests (such as unit tests or migration validation) to database changes, and deploying those changes through CI/CD pipelines. These practices reduce \"schema drift\" between development and production systems and lower the risk of deployment failures. [ 37 ] [ 38 ] Mobile DevOps [ edit ] Main article: Mobile DevOps Mobile DevOps is a set of practices that applies the principles of DevOps specifically to the development of mobile applications. Traditional DevOps focuses on streamlining the software development process in general, but mobile development has its own unique challenges that require a tailored approach. [ 39 ] Mobile DevOps is not simply as a branch of DevOps specific to mobile app development, instead an extension and reinterpretation of the DevOps philosophy due to very specific requirements of the mobile world. Site-reliability engineering [ edit ] Main article: Site reliability engineering In 2003, Google developed site reliability engineering (SRE), an approach for releasing new features continuously into large-scale high-availability systems while maintaining high-quality end-user experience. [ 40 ] While SRE predates the development of DevOps, they are generally viewed as being related to each other. Some of the original authors of the discipline consider SRE as an implementation of DevOps. [ 41 ] Toyota production system, lean thinking, kaizen [ edit ] Main article: Toyota Production System Toyota production system, also known under the acronym TPS, was the inspiration for lean thinking with its focus on continuous improvement , kaizen , flow and small batches. The andon cord principle to create fast feedback, swarm and solve problems stems from TPS. [ 42 ] [ 43 ] DevSecOps, shifting security left [ edit ] DevSecOps is an augmentation of DevOps to allow for security practices to be integrated into the DevOps approach. Contrary to a traditional centralized security team model, each delivery team is empowered to factor in the correct security controls into their software delivery. Security practices and testing are performed earlier in the development lifecycle, hence the term \" shift left \". Security is tested in three main areas: static, software composition, and dynamic. Checking software statically via static application security testing (SAST) is white-box testing with special focus on security. Depending on the programming language, different tools are needed to do such static code analysis. The software composition is analyzed, especially libraries, and the version of each component is checked against vulnerability lists published by CERT and other expert groups. When giving software to clients, library licenses and their match to the license of the software distributed are in focus, especially copyleft licenses. In dynamic testing, also called black-box testing , software is tested without knowing its inner functions. In DevSecOps this practice may be referred to as dynamic application security testing (DAST) or penetration testing. The goal is early detection of defects including cross-site scripting and SQL injection vulnerabilities. Often, detected defects from static and dynamic testing are triaged and categorized under taxonomies like the Common Weakness Enumeration (CWE) , maintained by the Mitre Corporation . This facilitates the prioritization of security bug fixes and also allows frequently recurring weaknesses to be fixed with recommended mitigations. As of 2025, CWE maintained its own list of frequently-occurring weaknesses, the CWE Top 25. [ 44 ] In addition, organizations like Open Worldwide Application Security Project (OWASP) maintain lists of industry-wide frequently recurring software weaknesses. [ 45 ] DevSecOps has also been described as a cultural shift involving a holistic approach to producing secure software by integrating security education, security by design, and security automation. [ 46 ] Culture [ edit ] DevOps initiatives can change how a company's operations , developers , and testers collaborate during the development and delivery processes. [ 47 ] [ 48 ] DevOps attempts to support consistency, reliability, and efficiency within an organization. This is usually enabled by a shared code repository or version control. [ 49 ] Many organizations use version control to facilitate DevOps automation technologies like virtual machines , containerization (or OS-level virtualization ), and CI/CD , [ 50 ] with the Git version control system and the GitHub platform referenced as examples. GitOps [ edit ] GitOps evolved from DevOps. The specific state of deployment configuration is version-controlled . Because the most popular version-control is Git, the GitOps approach has been named after Git. Changes to configuration can be managed using code review practices, and can be rolled back using version-controlling. Essentially, all of the changes to a code are tracked, bookmarked, and making any updates to the history can be made easier. As explained by Red Hat , \"visibility to change means the ability to trace and reproduce issues quickly, improving overall security.\" [ 51 ] Best practices for cloud systems [ edit ] The following practices can enhance productivity of DevOps pipelines , especially in systems hosted in the cloud : [ 52 ] [ 53 ] [ 54 ] Number of Pipelines : Small teams can be more productive by having one repository and one pipeline. In contrast, larger organizations may have separate repositories and pipelines for each team or even separate repositories and pipelines for each service within a team. Permissions : In the context of pipeline-related permissions, adhering to the principle of least privilege can be challenging due to the dynamic nature of architecture . Administrators may opt for more permissive permissions while implementing compensating security controls to minimize the blast radius. See also [ edit ] DataOps \u2013 Aspect of data analytics DevOps toolchain \u2013 Tools for software development Infrastructure as code \u2013 Data center management method Lean software development \u2013 Use of lean manufacturing principles in software development List of build automation software Site reliability engineering \u2013 Use of software engineering practices for IT Value stream \u2013 Principle in economics Twelve-Factor App methodology \u2013 Software methodology Notes [ edit ] ^ a portmanteau of dev elopment op erations ^ Dyck et al. (2015) \"To our knowledge, there is no uniform definition for the terms release engineering and DevOps. As a consequence, many people use their own definitions or rely on others, which results in confusion about those terms.\" [ 4 ] ^ Jabbari et al. (2016) \"The research results of this study showed the need for a definition as individual studies do not consistently define DevOps.\" [ 5 ] ^ Erich et al. (2017) \"We noticed that there are various gaps in the study of DevOps: There is no consensus of what concepts DevOps covers, nor how DevOps is defined.\" [ 6 ] ^ Erich et al. (2017) \"We discovered that there exists little agreement about the characteristics of DevOps in the academic literature.\" [ 6 ] References [ edit ] ^ Courtemanche, Meredith; Mell, Emily; Gills, Alexander S. \"What Is DevOps? The Ultimate Guide\" . TechTarget . Retrieved 2023-01-22 . ^ Building Evolutionary Architectures: Automated Software Governance . ISBN 978-1-4920-9754-9 . ^ Fundamentals of Software Architecture: An Engineering Approach . O'Reilly Media. 2020. ISBN 978-1-4920-4345-4 . ^ Dyck, Andrej; Penners, Ralf; Lichter, Horst (2015-05-19). \"Towards Definitions for Release Engineering and DevOps\". 2015 IEEE/ACM 3rd International Workshop on Release Engineering . IEEE . p.\u00a03. doi : 10.1109/RELENG.2015.10 . ISBN 978-1-4673-7070-7 . S2CID 4659735 . ^ Jabbari, Ramtin; bin Ali, Nauman; Petersen, Kai; Tanveer, Binish (May 2016). \"What is DevOps?: A Systematic Mapping Study on Definitions and Practices\". Proceedings of the 2016 Scientific Workshop . Association for Computing Machinery . ^ a b Erich, F.M.A.; Amrit, C.; Daneva, M. (June 2017). \"A Qualitative Study of DevOps Usage in Practice\" (PDF) . Journal of Software: Evolution and Process . 29 (6) e1885. doi : 10.1002/smr.1885 . S2CID 35914007 . ^ Bass, Len; Weber, Ingo; Zhu, Liming (2015). DevOps: A Software Architect's Perspective . Addison-Wesley. ISBN 978-0-13-404984-7 . ^ Mu\u00f1oz, Mirna; Negrete Rodr\u00edguez, Mario (2021-04-01). \"A guidance to implement or reinforce a DevOps approach in organizations: A case study\" . Journal of Software: Evolution and Process . 36 (3). Wiley. doi : 10.1002/smr.2342 . ^ Chapman, M., Gatti, N: A model of a service life cycle, Proceedings of TINA '93, pp. I-205\u2013I-215, Sep., 1993. ^ Mezak, Steve (25 January 2018). \"The Origins of DevOps: What's in a Name?\" . devops.com . Retrieved 6 May 2019 . ^ Debois, Patrick (9 October 2008). \"Agile 2008 Toronto\" . Just Enough Documented Information . Retrieved 12 March 2015 . ^ Debois, Patrick. \"DevOps Days\" . DevOps Days . Retrieved 31 March 2011 . ^ a b Alana Brown; Nicole Forsgren; Jez Humble; Nigel Kersten; Gene Kim (2016). \"2016 State of DevOps Report\" (PDF) . Puppet Labs, DORA (DevOps Research . Retrieved 2024-04-24 . ^ \"Puppet - Alanna Brown\" . Puppet Labs . Retrieved 2019-04-27 . ^ Nicole Forsgren; Gene Kim; Nigel Kersten; Jez Humble (2014). \"2014 State of DevOps Report\" (PDF) . Puppet Labs, IT Revolution Press and ThoughtWorks . Retrieved 2024-04-24 . ^ \"2015 State of DevOps Report\" (PDF) . Puppet Labs, Pwc, IT Revolution Press. 2015 . Retrieved 2024-04-24 . ^ \"More Agile Testing\" (PDF) . October 2014 . Retrieved 2019-05-06 . ^ Crispin, Lisa; Gregory, Janet (October 2014). More Agile Testing . Addison-Wesley. ISBN 978-0-13-374957-1 . Retrieved 2019-05-06 . ^ Turner, Graham (20 November 2023). \"Report: Software Engineers Face Backlash for Reporting Wrongdoing\" . DIGIT . Retrieved 5 January 2024 . ^ Saran, Cliff. \"Software engineers worry about speaking out - Computer Weekly\" . ComputerWeekly.com . Retrieved 5 January 2024 . ^ \"75% of software engineers faced retaliation the last time they reported wrongdoing - ETHRWorldSEA\" . ETHRWorld.com . ^ Cummins, Holly. \"Holly Cummins on X\" . X.com . Retrieved 5 January 2024 . ^ DeBellis, Derek; Lewis, Amanda; Villalba, Daniella; Farley, Dave. \"2023 State of DevOps Report\" . Google Cloud DevOps Research and Assessment . Retrieved 2024-04-24 . ^ DeBellis, Derek; Harvey, Nathan. \"2023 State of DevOps Report: Culture is everything\" . Google Cloud Blog . Retrieved 2024-04-24 . ^ Forsgren, Nicole. Accelerate: The Science of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations . ISBN 978-1-942788-33-1 . ^ \"DORA Accelerate State of DevOps 2021\". DevOps Research and Assessment (2021). 2021. ^ Klein, Brandon Thorin (2021-05-01). \"The DevOps: A Concise Understanding to the DevOps Philosophy and Science\" . Osti.gov . doi : 10.2172/1785164 . OSTI 1785164 . S2CID 236606284 . ^ \"The History and Evolution of DevOps | Tom Geraghty\" . 5 July 2020 . Retrieved 2020-11-29 . ^ \"What is platform engineering?\" . Microsoft Learn . Retrieved 2025-04-01 . ^ \"What is platform engineering?\" . Red Hat . Retrieved 2025-04-01 . ^ \"Principles behind the Agile Manifesto\" . agilemanifesto.org . Retrieved 2020-12-06 . ^ Castellanos, Camilo; Correal, Dario (15 September 2018). \"Executing Architectural Models for Big Data Analytics\". Software Architecture . Lecture Notes in Computer Science. Vol.\u00a011048. pp. 364\u2013 371. doi : 10.1007/978-3-030-00761-4_24 . ISBN 978-3-030-00760-7 . ^ Humble, Jez; Farley, David (2011). Continuous Delivery: reliable software releases through build, test, and deployment automation . Pearson Education Inc. ISBN 978-0-321-60191-9 . ^ Chen, Lianping (2015). \"Continuous Delivery: Huge Benefits, but Challenges Too\". IEEE Software . 32 (2): 50\u2013 54. doi : 10.1109/MS.2015.27 . S2CID 1241241 . ^ Fluri, Jasmin; Fornari, Fabrizio; Pustulka, Elzbieta (2024). \"On the importance of CI/CD practices for database applications\" . Journal of Software: Evolution and Process . doi : 10.1002/smr.2720 . Retrieved 2025-08-24 . ^ Shahin, Mojtaba; Ali Babar, Muhammad; Zhu, Liming (2017). \"Continuous Integration, Delivery and Deployment: A Systematic Review on Approaches, Tools, Challenges and Practices\" . IEEE Access . 5 : 3909\u2013 3943. arXiv : 1703.07019 . doi : 10.1109/ACCESS.2017.2685629 . Retrieved 2025-08-24 . ^ \"Database Change Management\" . DORA . Retrieved 2025-08-24 . ^ \"A Guide to Database DevOps\" . Liquibase . Retrieved 2025-08-24 . ^ Tak, Rohin; Modi, Jhalak (2018). Mobile DevOps: Deliver continuous integration and deployment within your mobile applications . Packt Publishing. pp. 12\u2013 18. ISBN 978-1-78829-624-3 . ^ Beyer, Betsy; Jones, Chris; Petoff, Jennifer; Murphy, Niall Richard (April 2016). Site Reliability Engineering . O'Reilly Media. ISBN 978-1-4919-2909-4 . ^ Dave Harrison (9 Oct 2018). \"Interview with Betsy Beyer, Stephen Thorne of Google\" . Retrieved 24 July 2024 . ^ Analyzing the DNA of DevOps , Brent Aaron Reed, Willy Schaub, 2018-11-14. ^ Gene Kim; Patrick Debois; John Willis; Jezz Humble (2016). The DevOps Handbook: How to Create World-Class Agility, Reliability, and Security in Technology Organizations . ^ \"CWE Top 25 Most Dangerous Software Weaknesses\" . Retrieved September 21, 2025 . ^ \"OWASP TOP10\" . Archived from the original on June 8, 2023 . Retrieved June 8, 2023 . ^ Wilson, Glenn (December 2020). 'DevSecOps: A leader's guide to producing secure software without compromising flow, feedback and continuous improvement' . Rethink Press. ISBN 978-1-78133-502-4 . ^ Emerging Technology Analysis: DevOps a Culture Shift, Not a Technology (Report). Gartner. ^ Loukides, Mike (7 June 2012). \"What is DevOps?\" . O'Reilly Media . ^ Teja Yarlagadda, Ravi (9 March 2021). \"DevOps and Its Practices\". SSRN 3798877 . ^ Morisio, Maurizio (16 April 2021). DevOps: development of a toolchain in the banking domain . Politecnico di Torino (laurea thesis) . Retrieved 16 August 2021 . ^ \"What is GitOps?\" . www.redhat.com . Retrieved 2023-03-30 . ^ Serverless Architectures on AWS . Manning. 29 March 2022. ISBN 978-1-61729-542-3 . ^ Pipeline as Code Continuous Delivery with Jenkins, Kubernetes, and Terraform . Manning. 23 November 2021. ISBN 978-1-63835-037-8 . ^ Humble, Jez; Farley, David (27 July 2010). Continuous Delivery Reliable Software Releases Through Build, Test, and Deployment Automation . Pearson Education. ISBN 978-0-321-67022-9 . Further reading [ edit ] Davis, Jennifer; Daniels, Ryn (2016-05-30). Effective DevOps: building a culture of collaboration, affinity, and tooling at scale . Sebastopol, CA: O'Reilly. ISBN 978-1-4919-2643-7 . OCLC 951434424 . Kim, Gene; Debois, Patrick; Willis, John; Humble, Jez; Allspaw, John (2015-10-07). The DevOps handbook: how to create world-class agility, reliability, and security in technology organizations (First\u00a0ed.). Portland, OR. ISBN 978-1-942788-00-3 . OCLC 907166314 . {{ cite book }} :  CS1 maint: location missing publisher ( link ) Forsgren, Nicole; Humble, Jez; Kim, Gene (27 March 2018). Accelerate: The Science of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations (First\u00a0ed.). IT Revolution Press. ISBN 978-1-942788-33-1 . v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=DevOps&oldid=1322433136 \" Category : DevOps Hidden categories: Articles with short description Short description is different from Wikidata Wikipedia pending changes protected pages CS1 maint: location missing publisher This page was last edited on 16 November 2025, at 05:30 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents DevOps 35 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Feature-driven_development",
    "title": "Feature-driven development - Wikipedia",
    "content": "Feature-driven development - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Overview Toggle Overview subsection 2.1 Develop overall model 2.2 Build feature list 2.3 Plan by feature 2.4 Design by feature 2.5 Build by feature 3 Milestones 4 Best practices 5 Metamodel (Metamodelling) 6 See also 7 References 8 External links Toggle the table of contents Feature-driven development 14 languages Catal\u00e0 \u010ce\u0161tina Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais Bahasa Indonesia Italiano Nederlands \u65e5\u672c\u8a9e Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Software development process Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Feature-driven development ( FDD ) is an iterative and incremental software development process . It is a lightweight or agile method for developing software . FDD blends several best practices into a cohesive whole. These practices are driven from the perspective of delivering functionality ( features ) valued by the client. [ 1 ] Its main purpose is to deliver tangible, working software repeatedly in a timely manner in accordance with the Principles behind the agile manifesto . [ 2 ] History [ edit ] FDD was initially devised by Jeff De Luca to meet the specific needs of a 15-month, 50-person software development project at a large Singapore bank in 1997. This resulted in a set of five processes that covered the development of an overall model and the listing, planning, design, and building of features. The first process is heavily influenced by Peter Coad 's approach to object modeling . The second process incorporates Coad's ideas of using a feature list to manage functional requirements and development tasks. The other processes are a result of Jeff De Luca's experience. There have been several implementations of FDD since its successful use on the Singapore project. The description of FDD was first introduced to the world in Chapter 6 of the book Java modelling in Color with UML [1] by Peter Coad, Eric Lefebvre , and Jeff De Luca in 1999. Later, in Stephen Palmer and Mac Felsing 's book A Practical Guide to Feature-Driven Development [2] (published in 2002), a more general description of FDD was given decoupled from Java modelling. Overview [ edit ] FDD is a model-driven short-iteration process that consists of five basic activities. For accurate state reporting and keeping track of the software development project, milestones that mark the progress made on each feature are defined. This section gives a high-level overview of the activities. In the figure on the right, the meta-process model for these activities is displayed. During the first two sequential activities, an overall model shape is established. The final three activities are iterated for each feature. Process model for FDD Develop overall model [ edit ] The FDD project starts with a high-level walkthrough of the scope of the system and its context. Next, detailed domain models are created for each modelling area by small groups and presented for peer review . One or more of the proposed models are selected to become the model for each domain area. Domain area models are progressively merged into an overall model. Build feature list [ edit ] Knowledge gathered during the initial modeling is used to identify a list of features by functionally decomposing the domain into subject areas. Subject areas each contain business activities, and the steps within each business activity form the basis for a categorized feature list. Features in this respect are small pieces of client-valued functions expressed in the form \"<action> <result> <object>\", for example: 'Calculate the total of a sale' or 'Validate the password of a user'. Features should not take more than two weeks to complete, else they should be broken down into smaller pieces. Plan by feature [ edit ] After the feature list is completed, the next step is to produce the development plan and assign ownership of features (or feature sets) as classes to programmers . Design by feature [ edit ] A design package is produced for each feature. A chief programmer selects a small group of features that are to be developed within two weeks. Together with the corresponding class owners, the chief programmer works out detailed sequence diagrams for each feature and refines the overall model. Next, the class and method prologues are written, and finally a design inspection is held. Build by feature [ edit ] After a successful design inspection for each activity to produce a feature is planned, the class owners develop code for their classes. After unit testing and successful code inspection , the completed feature is promoted to the main build. Milestones [ edit ] Since features are small, completing a feature is a relatively small task. For accurate state reporting and keeping track of the software development project, it is important to mark the progress made on each feature. FDD therefore defines six milestones per feature that are to be completed sequentially. The first three milestones are completed during the Design By Feature activity, and the last three are completed during the Build By Feature activity. To track progress, a percentage complete is assigned to each milestone. In the table below the milestones and their completion percentage are shown. At the point that coding begins, a feature is already 44% complete (Domain Walkthrough 1%, Design 40% and Design Inspection 3% = 44%). Table 1: Milestones Domain Walkthrough Design Design Inspection Code Code Inspection Promote To Build 1% 40% 3% 45% 10% 1% Best practices [ edit ] Feature-driven development is built on a core set of software engineering best practices aimed at a client-valued feature perspective. Domain object modeling . Domain object modeling consists of exploring and explaining the domain of the problem to be solved. The resulting domain object model provides an overall framework in which to add features. Developing by feature . Any function that is too complex to be implemented within two weeks is further decomposed into smaller functions until each sub-problem is small enough to be called a feature. This makes it easier to deliver correct functions and to extend or modify the system. Individual class ownership ( code ownership ). Individual class ownership means that distinct pieces or grouping of code are assigned to a single owner. The owner is responsible for the consistency, performance, and conceptual integrity of the class. Feature teams . A feature team is a small, dynamically formed team that develops a small activity. Multiple minds are always applied to each design decision, and multiple design options are evaluated before one is chosen. Inspections . Inspections are carried out to ensure good quality design and code primarily by the detection of defects. Configuration management . Configuration management helps with identifying the source code for all features that have been completed to date and maintaining a history of changes to classes as feature teams enhance them. Regular builds . Regular builds ensure there is always an up-to-date system that can be demonstrated to the client and help highlight integration errors of source code for the features early. Visibility of progress and results . Managers steer a project using frequent, appropriate, and accurate progress reporting from all levels inside and outside the project based on completed work. Metamodel (Metamodelling) [ edit ] Process-Data Model for FDD Metamodelling helps visualize both the processes and the data of a method . This allows methods to be compared, and method fragments in the method engineering process can easily be reused. The usage of this technique is consistent with UML standards. The left side of the metadata model shows the five basic activities involved in a software development project using FDD. The activities all contain sub-activities that corresponding to sub-activities in the FDD process description. The right side of the model shows the concepts involved. These concepts originate from the activities depicted in the left side of the diagram. See also [ edit ] Agile software development Behavior-driven development Project lifecycle Software architecture Software development process Software engineering References [ edit ] ^ Cadle, James; Ahmed, Tahir; BCS, The Chartered Institute for IT, eds. (2014). Developing information systems: practical guidance for IT professionals . London: BCS, The Chartered Institute for IT. p.\u00a099. ISBN 978-1-78017-245-3 . ^ \"Principles behind the Agile Manifesto\" . 2019-06-11. 1. ^ Coad, P. , Lefebvre, E. & De Luca, J. (1999). Java modelling In Color With UML: Enterprise Components and Process . Prentice Hall International. ( ISBN 0-13-011510-X ) 2. ^ Palmer, S.R., & Felsing, J.M. (2002). A Practical Guide to Feature-Driven Development . Prentice Hall. ( ISBN 0-13-067615-2 ) External links [ edit ] Feature Driven Development Community Nebulon FDD Page - Nebulon is the consulting practice of Jeff De Luca Successful Web Development Methodologies - Use of FDD for Web Development projects Delivering Real Business Value using Feature Driven Development - Article gives basic overview of FDD FDD and Agile modelling Better Software Faster - Another book in the Coad Series referencing Feature Driven Development. Authors Andy Carmichael and Dan Haywood ISBN 0-13-008752-1 Interview with FDD-Creator Jeff DeLuca (Podcast) v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Feature-driven_development&oldid=1316374257 \" Categories : Agile software development Software project management Software features Hidden categories: Articles with short description Short description is different from Wikidata This page was last edited on 12 October 2025, at 02:39 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Feature-driven development 14 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Dynamic_systems_development_method",
    "title": "Dynamic systems development method - Wikipedia",
    "content": "Dynamic systems development method - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Description Toggle Description subsection 2.1 Principles 2.2 Core techniques 2.3 Roles 2.4 Critical success factors 3 Comparison to other development frameworks 4 See also 5 References 6 Further reading 7 External links Toggle the table of contents Dynamic systems development method 16 languages Catal\u00e0 Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Bahasa Indonesia Italiano Magyar Nederlands Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Suomi Svenska \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Agile project delivery framework This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article relies excessively on references to primary sources . Please improve this article by adding secondary or tertiary sources . Find sources: \"Dynamic systems development method\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( March 2016 ) ( Learn how and when to remove this message ) This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Dynamic systems development method\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( October 2008 ) ( Learn how and when to remove this message ) ( Learn how and when to remove this message ) Model of the DSDM project management method Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Dynamic systems development method ( DSDM ) is an agile project delivery framework, initially used as a software development method . [ 1 ] [ 2 ] First released in 1994, DSDM originally sought to provide some discipline to the rapid application development (RAD) method. [ 3 ] In later versions the DSDM Agile Project Framework was revised and became a generic approach to project management and solution delivery rather than being focused specifically on software development and code creation [ clarification needed ] [ citation needed ] and could be used for non-IT projects. [ 4 ] The DSDM Agile Project Framework covers a wide range of activities across the whole project lifecycle and includes strong foundations and governance, which set it apart from some other Agile methods. [ 5 ] The DSDM Agile Project Framework is an iterative and incremental approach that embraces principles of Agile development, including continuous user/customer involvement. DSDM fixes cost, quality and time at the outset and uses the MoSCoW prioritisation of scope into musts , shoulds , coulds and will not haves to adjust the project deliverable to meet the stated time constraint. DSDM is one of a number of agile methods for developing software and non-IT solutions, and it forms a part of the Agile Alliance. In 2014, DSDM released the latest version of the method in the 'DSDM Agile Project Framework'. At the same time the new DSDM manual recognised the need to operate alongside other frameworks for service delivery (esp. ITIL ) PRINCE2 , Managing Successful Programmes, and PMI. [ 6 ] The previous version (DSDM 4.2) had only contained guidance on how to use DSDM with extreme programming . History [ edit ] In the early 1990s, rapid application development (RAD) was spreading across the IT industry. The user interfaces for software applications were moving from the old green screens to the graphical user interfaces that are used today. New application development tools were coming on the market, such as PowerBuilder . These enabled developers to share their proposed solutions much more easily with their customers \u2013 prototyping became a reality and the frustrations of the classical, sequential ( waterfall ) development methods could be put to one side. However, the RAD movement was very unstructured: there was no commonly agreed definition of a suitable process and many organizations came up with their own definition and approach. Many major corporations were very interested in the possibilities but they were also concerned that they did not lose the level of quality in the end deliverables that free-flow development could give rise to. The DSDM Consortium was founded in 1994 by an association of vendors and experts in the field of software engineering and was created with the objective of \"jointly developing and promoting an independent RAD framework\" by combining their best practice experiences. The origins were an event organized by the Butler Group in London. People at that meeting all worked for blue-chip organizations such as British Airways, American Express, Oracle, and Logica (other companies such as Data Sciences and Allied Domecq have since been absorbed by other organizations). In July 2006, DSDM Public Version 4.2 [ 7 ] was made available for individuals to view and use; however, anyone reselling DSDM must still be a member of the not-for-profit consortium. In 2014, the DSDM handbook was made available online and public. [ 8 ] Additionally, templates for DSDM can be downloaded. [ 9 ] In October 2016 the DSDM Consortium rebranded as the Agile Business Consortium (ABC). [ 10 ] The Agile Business Consortium is a not-for-profit, vendor-independent organisation which owns and administers the DSDM framework. [ 11 ] Description [ edit ] DSDM is a vendor-independent approach that recognises that more projects fail because of people problems than technology. DSDM's focus is on helping people to work effectively together to achieve the business goals. DSDM is also independent of tools and techniques enabling it to be used in any business and technical environment without tying the business to a particular vendor. [ 8 ] Principles [ edit ] There are eight principles underpinning DSDM. [ 12 ] These principles direct the team in the attitude they must take and the mindset they must adopt to deliver consistently. Focus on the business need Deliver on time Collaborate Never compromise quality Build incrementally from firm foundations Develop iteratively Communicate continuously and clearly Demonstrate control Core techniques [ edit ] This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. ( March 2016 ) ( Learn how and when to remove this message ) Timeboxing : is the approach for completing the project incrementally by breaking it down into splitting the project in portions, each with a fixed budget and a delivery date. For each portion a number of requirements are prioritised and selected. Because time and budget are fixed, the only remaining variables are the requirements. So if a project is running out of time or money the requirements with the lowest priority are omitted. This does not mean that an unfinished product is delivered, because of the Pareto principle that 80% of the project comes from 20% of the system requirements, so as long as those most important 20% of requirements are implemented into the system, the system therefore meets the business needs and that no system is built perfectly in the first try. MoSCoW : is a technique for prioritising work items or requirements. It is an acronym that stands for: Must have Should have Could have Won't have Prototyping: refers to the creation of prototypes of the system under development at an early stage of the project. It enables the early discovery of shortcomings in the system and allows future users to 'test-drive' the system. This way good user involvement is realised, one of the key success factors of DSDM, or any system development project for that matter. Testing: helps ensure a solution of good quality, DSDM advocates testing throughout each iteration. Since DSDM is a tool and technique independent method, the project team is free to choose its own test management method. Workshop: brings project stakeholders together to discuss requirements, functionalities and mutual understanding. Modeling : helps visualise a business domain and improve understanding. Produces a diagrammatic representation of specific aspects of the system or business area that is being developed. Configuration management : with multiple deliverables under development at the same time and being delivered incrementally at the end of each time-box, the deliverables need to be well managed towards completion. Roles [ edit ] This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. ( March 2016 ) ( Learn how and when to remove this message ) There are some roles introduced within DSDM environment. It is important that the project members need to be appointed to different roles before they commence the project. Each role has its own responsibility. The roles are: Executive sponsor : So called the project champion . An important role from the user organisation who has the ability and responsibility to commit appropriate funds and resources. This role has an ultimate power to make decisions. Visionary : The one who has the responsibility to initialise the project by ensuring that essential requirements are found early on. Visionary has the most accurate perception of the business objectives of the system and the project. Another task is to supervise and keep the development process in the right track. Ambassador user : Brings the knowledge of the user community into the project, ensures that the developers receive enough user feedback during the development process. Advisor user : Can be any user that represents an important viewpoint and brings daily knowledge of the project. Project manager : Can be anyone from the user community or IT staff who manages the project in general. Technical co-ordinator : Responsible in designing the system architecture and control the technical quality of the project. Team leader : Leads their team and ensures that the team works effectively as a whole. Solution developer : Interpret the system requirements and model it including developing the deliverable codes and build the prototypes. Solution tester : Checks the correctness in a technical extent by performing some testing, raise defects where necessary and retest once fixed. Tester will have to provide some comment and documentation. Scribe : Responsible for gathering and recording the requirements, agreements, and decisions made in every workshop. Facilitator : Responsible for managing the workshops' progress, acts as a motivator for preparation and communication. Specialist roles : Business architect, quality manager, system integrator, etc. Critical success factors [ edit ] Within DSDM a number of factors are identified as being of great importance to ensure successful projects. Factor 1: First there is the acceptance of DSDM by senior management and other employees. This ensures that the different actors of the project are motivated from the start and remain involved throughout the project. Factor 2: Directly derived from factor 1: The commitment of the management to ensure end-user involvement. The prototyping approach requires a strong and dedicated involvement by end users to test and judge the functional prototypes. Factor 3: The project team has to be composed of skillful members that form a stable union. An important issue is the empowerment of the project team. This means that the team (or one or more of its members) has to possess the power and possibility to make important decisions regarding the project without having to write formal proposals to higher management, which can be very time-consuming. In order to enable the project team to run a successful project, they also need the appropriate technology to conduct the project. This means a development environment, project management tools, etc. Factor 4: Finally, DSDM also states that a supportive relationship between customer and vendor is required. This goes for both projects that are realised internally within companies or by external contractors. An aid in ensuring a supporting relationship could be ISPL . Comparison to other development frameworks [ edit ] DSDM can be considered as part of a broad range of iterative and incremental development frameworks, especially those supporting agile and object-oriented methods. These include (but are not limited to) scrum , extreme programming (XP) , disciplined agile delivery (DAD) , and rational unified process (RUP) . Like DSDM, these share the following characteristics: They all prioritise requirements and work though them iteratively, building a system or product in increments. They are tool-independent frameworks. This allows users to fill in the specific steps of the process with their own techniques [ 5 ] and software aids of choice. The variables in the development are not time/resources, but the requirements. This approach ensures the main goals of DSDM, namely to stay within the deadline and the budget. A strong focus on communication between and the involvement of all the stakeholders in the system. Although this is addressed in other methods, DSDM strongly believes in commitment to the project to ensure a successful outcome. See also [ edit ] Agile software development Lean software development References [ edit ] ^ Keith Richards , Agile project management: running PRINCE2 projects with DSDM Atern. OGC \u2013 Office of Government Commerce. The Stationery Office, 31 jul. 2007. ^ Plonka, Laura, et al. \"UX Design in Agile: A DSDM Case Study.\" Agile Processes in Software Engineering and Extreme Programming. Springer International Publishing, 2014. 1-15. ^ Abrahamsson, Pekka, et al. \" New directions on agile methods: a comparative analysis Archived 2018-10-24 at the Wayback Machine .\" Software Engineering, 2003. Proceedings. 25th International Conference on. Ieee, 2003. ^ Stapleton, Jennifer (January 2003). Business Focused Development . Pearson Education. p.\u00a0113. ISBN 9780321112248 . ^ a b Moran, Alan (March 2015). Managing Agile . Springer. pp. 21\u2013 24. ISBN 9783319162614 . ^ The DSDM Agile Project Framework manual, 2014 pages 4, 16 ^ ( www.dsdm.org Archived 2016-10-02 at the Wayback Machine ) ^ a b \"The DSDM Agile Project Framework (2014 Onwards)\" . Agile Business Consortium . February 4, 2016. ^ www.agilebusiness.org https://www.agilebusiness.org/resources/templates-and-tools/atern-template-complete-set . {{ cite web }} : Missing or empty |title= ( help ) ^ \"Agile's DSDM Consortium evolves into Agile Business Consortium\" . Press Dispensary . ^ \"Terms and Conditions of Community Membership\" (PDF) . GLOBAL G.A.P. ^ Agile Business Consortium. The DSDM Agile Project Framework (2014 Onwards) Handbook \u2013 Principles . Further reading [ edit ] Coleman and Verbruggen: A quality software process for rapid application development , Software Quality Journal 7, p.\u00a0107-1222 (1998) Beynon-Davies and Williams: The diffusion of information systems development methods , Journal of Strategic Information Systems 12 p.\u00a029-46 (2003) Sjaak Brinkkemper , Saeki and Harmsen: Assembly Techniques for Method Engineering , Advanced Information Systems Engineering, Proceedings of CaiSE'98, Springer Verlag (1998) Abrahamsson, Salo, Ronkainen, Warsta Agile Software Development Methods: Review and Analysis , VTT Publications 478, p.\u00a061-68 (2002) Tuffs, Stapleton, West, Eason: Inter-operability of DSDM with the Rational Unified Process , DSDM Consortium, Issue 1, p.\u00a01-29 (1999) Rietmann: DSDM in a bird\u2019s eye view , DSDM Consortium, p.\u00a03-8 (2001) Chris Barry, Kieran Conboy, Michael Lang, Gregory Wojtkowski and Wita Wojtkowski: Information Systems Development: Challenges in Practice, Theory, and Education, Volume 1 Keith Richards: Agile Project Management: running PRINCE2 projects with DSDM Atern, TSO (2007) Archived 2021-01-23 at the Wayback Machine The DSDM Agile Project Framework (2014) DSDM Agile Project Management Framework (v6, 2014) interactive mind map External links [ edit ] Wikimedia Commons has media related to Dynamic Systems Development Method . The Agile Business Consortium (formerly, DSDM Consortium) AgilePM wiki Retrieved from \" https://en.wikipedia.org/w/index.php?title=Dynamic_systems_development_method&oldid=1297410817 \" Category : Dynamic systems development method Hidden categories: Webarchive template wayback links CS1 errors: missing title CS1 errors: bare URL Articles with short description Short description matches Wikidata Articles lacking reliable references from March 2016 All articles lacking reliable references Articles needing additional references from October 2008 All articles needing additional references Articles with multiple maintenance issues Wikipedia articles needing clarification from November 2014 All articles with unsourced statements Articles with unsourced statements from November 2014 Articles needing additional references from March 2016 Commons category link is on Wikidata This page was last edited on 26 June 2025, at 01:27 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Dynamic systems development method 16 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Disciplined_agile_delivery",
    "title": "Disciplined agile delivery - Wikipedia",
    "content": "Disciplined agile delivery - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Key aspects Toggle Key aspects subsection 2.1 People-first 2.2 Hybrid 2.3 Full delivery lifecycle 2.4 Support for multiple lifecycles 2.5 Complete 2.6 Context-sensitive 2.7 Consumable solutions over working software 2.8 Self-organization with appropriate governance 3 Lifecycles 4 Process goals 5 Roles Toggle Roles subsection 5.1 Primary roles 5.2 Potential supporting roles 6 See also 7 References 8 Further reading Toggle the table of contents Disciplined agile delivery 2 languages \u010ce\u0161tina \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Concept in Agile software development This article may rely excessively on sources too closely associated with the subject , potentially preventing the article from being verifiable and neutral . Please help improve it by replacing them with more appropriate citations to reliable, independent sources . ( November 2019 ) ( Learn how and when to remove this message ) Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Disciplined agile delivery ( DAD ) is the software development portion of the Disciplined Agile Toolkit. DAD enables teams to make simplified process decisions around incremental and iterative solution delivery. DAD builds on the many practices espoused by advocates of agile software development , including scrum , agile modeling , lean software development , and others. The primary reference for disciplined agile delivery is the book Choose Your WoW! , [ 1 ] written by Scott Ambler and Mark Lines. WoW refers to \"way of working\" or \"ways of working\". [ 2 ] In particular, DAD has been identified as a means of moving beyond scrum. [ 3 ] According to Cutter Senior Consultant Bhuvan Unhelkar, \"DAD provides a carefully constructed mechanism that not only streamlines IT work, but more importantly, enables scaling.\" [ 4 ] Paul Gorans and Philippe Kruchten call for more discipline in implementation of agile approaches and indicate that DAD, as an example framework, is \"a hybrid agile approach to enterprise IT solution delivery that provides a solid foundation from which to scale.\" [ 5 ] History [ edit ] Scott Ambler and Mark Lines initially led the development of DAD, and continue to lead its evolution. DAD was developed to provide a more cohesive approach to agile software development; one that tries to fill in the process gaps that are (purposely) ignored by scrum, and one that is capable of enterprise-level scale. According to Ambler, \"Many agile methodologies\u2014including scrum, XP, AM, Agile Data, kanban , and more\u2014focus on a subset of the activities required to deliver a solution from project initiation to delivery. Before DAD was developed, you needed to cobble together your own agile methodology to get the job done.\" [ 6 ] DAD was developed as a result of observing common patterns where agility was applied at scale successfully. [ 7 ] In 2015 the Disciplined Agile (DA) framework, later to become the Disciplined Agile Toolkit, was developed. [ 8 ] This was called Disciplined Agile 2.x. DAD formed the foundation for DA. [ citation needed ] A second layer, disciplined DevOps, was added as was a third layer called Disciplined Agile IT (DAIT). [ citation needed ] These layers, respectively, addressed how to address DevOps and IT processes in an enterprise-class setting. Disciplined Agile 3.x was released in August 2017 to introduce a fourth layer, Disciplined Agile Enterprise (DAE), to address the full process range required for business agility. [ 9 ] In December 2018, Disciplined Agile 4, now referred to as the Disciplined Agile Toolkit, was released. [ citation needed ] It focused on a completely revamped description of DAD and a team-based improvement strategy called guided continuous improvement (GCI). [ citation needed ] In August 2019, Disciplined Agile was acquired by Project Management Institute . [ 10 ] Key aspects [ edit ] Many of the challenges that teams are facing are out of scope for scrum and the teams need to look to other methods with overlapping parts and conflicting terminology. DAD attempts to address these challenges by using a people-first, learning-oriented, hybrid approach to IT solution delivery. [ 11 ] People-first [ edit ] Disciplined agile delivery (DAD) identifies that \"People, and the way they interact with each other, are the primary determinant of success for a solution delivery team.\" [ 12 ] DAD supports a robust set of roles (see below section), rights, and responsibilities that you can tailor to meet the needs of your situation.\u00a0DAD promotes the ideas that team members should collaborate closely and learn from each other, that the team should invest effort to learn from their experiences and evolve their approach, and that individuals should do so as well. [ 13 ] Hybrid [ edit ] DAD is a hybrid toolkit that adopts and tailors proven strategies from existing methods such as scrum , extreme programming (XP), SAFe , agile modeling (AM), Unified Process (UP), Kanban , outside-in software development , agile data (AD) and Spotify 's development model. Rather than taking the time to adapt one of these existing frameworks, with DAD all of the effort of combining relevant pieces of each technique has already been done. Full delivery lifecycle [ edit ] Unlike first generation agile methods that typically focus on the construction aspects of the lifecycle, DAD addresses the full delivery lifecycle, from team initiation all the way to delivering a solution to your end users. Support for multiple lifecycles [ edit ] DAD supports six lifecycles to choose from: agile, lean, continuous delivery, exploratory, and large-team versions of the lifecycle. DAD does not prescribe a single lifecycle because it recognizes that one approach does not fit all. Complete [ edit ] DAD shows how development, modeling, architecture, management, requirements/outcomes, documentation, governance and other strategies fit together in a streamlined whole. DAD does the \"process heavy lifting\" that other methods leave up to you. Context-sensitive [ edit ] The approach is goal-driven or outcome-driven rather than prescriptive. In doing so, DAD provides contextual advice regarding viable alternatives - what works, what doesn't and more importantly why - and their trade-offs, enabling you to tailor your way of working to address the situation in which you find yourself and do so in a streamlined manner. Consumable solutions over working software [ edit ] DAD matures focus from simply producing software to providing consumable solutions that provide real business value to stakeholders. While software is clearly an important part of the deliverable, being solution focused means taking a holistic view of the overall problem. This can lead to suggested updates in hardware, business and organizational processes, and overall organizational structures. Self-organization with appropriate governance [ edit ] Agile and lean teams are self-organizing, which means that the people who do the work are the ones who plan and estimate it. They must still work in an enterprise aware manner that reflects the priorities of their organization, and to do that they will need to be governed appropriately by senior leadership. Lifecycles [ edit ] Disciplined originally supported an agile (scrum-based) project lifecycle and a Lean (Kanban-based) project lifecycle. It has since been extended to support six lifecycles: Agile . A three-phase project lifecycle based on scrum. The phases are Inception (what is sometimes called \"Sprint 0\"), Construction, and Transition (what is sometimes called a Release sprint). Lean . A three-phase project lifecycle based on Kanban. Continuous delivery: Agile . An Agile-based product lifecycle that supports a continuous flow of work resulting in incremental releases (typically once a week). Continuous delivery: Lean . A lean-based product lifecycle that supports a continuous flow of work. Exploratory . An experimentation-based lifecycle based on lean startup that has been extended to address the parallel development of minimum viable products as per the advice of cynefin . Program . A lifecycle for coordinating a team of teams. Process goals [ edit ] DAD is described as a collection of twenty-one process goals , or process outcomes. [ 14 ] These goals guides teams through a leaner process to decisions that address the context of the situation they face. It enables teams to focus on outcomes and not on process compliance and on guesswork of extending agile methods. It enables scaling by providing sophisticated-enough strategies to address the complexities you face. Inception phase Construction phase Transition phase Get the team going in the right direction. Incrementally build a consumable solution. Release the solution into production. Form Team Align with enterprise direction Develop common project vision Explore scope Identify architecture strategy Plan the release Develop test strategy Develop common vision Secure funding Prove architecture early Address changing stakeholder needs Produce potentially consumable solution Improve quality Accelerate value delivery Ensure production readiness Deploy the Solution Ongoing goals Improve and work in an enterprise aware manner. Grow team members Coordinate activities Address risk Evolve ways of working (WoW) Leverage and enhance existing infrastructure Govern delivery team Roles [ edit ] Primary roles [ edit ] These five primary roles [ 15 ] in the disciplined agile delivery are typically found regardless of scale. Stakeholder . Someone who is materially impacted by the outcome of the solution. More than just an end-user or customer, this is anyone potentially affected by the development and deployment of a software project. Product owner . The person on the team who speaks as the \"one voice of the customer\", representing the needs of the stakeholder community to the agile delivery team. Team member . The team member focuses on producing the actual solution for stakeholders, including but not limited to: testing, analysis, architecture, design, programming, planning, and estimation. They will have a subset of the overall needed skills and they will strive to gain more to become generalizing specialists. Team lead . The team lead is a host leader and also the agile coach, responsible for facilitating communication, empowering them to choose their way of working, and ensuring the team has the resources it needs and is free of obstacles. Architecture owner . Owns the architecture decisions for the team and facilitates the creation and evolution of the overall solution design. Potential supporting roles [ edit ] These supporting roles [ 16 ] are introduced (sometimes on a temporary basis) to address scaling issues. Specialist . Although most agile team members are generalizing specialists, [ 17 ] sometimes other specialists are required depending on the needs of the project. Domain expert . While the product owner represents a wide range of stakeholders, a domain expert is sometimes required for complex domains where a more nuanced understanding is required. Technical expert . In cases where a particularly difficult problem is encountered, a technical expert can be brought in as needed. These could be build-masters, agile database administrators, user experience (UX) designers, or security experts. Independent tester . Although the majority of testing is done by the DAD team members, in cases with complex domains or technology an independent testing team can be brought in to work in parallel to validate the work. Integrator . For complex technical solutions at scale, an integrator (or multiple integrators) can be used to build the entire system from its various subsystems. See also [ edit ] Rational unified process References [ edit ] ^ Ambler, Scott ; Lines, Mark (2019). Choose Your WoW! A Disciplined Agile Delivery Handbook for Optimizing Your Way of Working . ISBN 978-1-7904-4784-8 . ^ Book: Choose Your WoW! \u2013 Disciplined Agile (DA) ^ Ambler, Scott (2013). \"Going Beyond Scrum: Disciplined Agile Delivery\" . ^ Disciplined Agile Delivery in the Enterprise (Cutter IT Journal, Special Issue, June 2013) ^ Kruchten, Philippe ; Gorans, Paul (February 2014). A Guide to Critical Success Factors in Agile Delivery (Report). IBM Center for the Business of Government. p.\u00a014 . Retrieved February 1, 2014 . a hybrid agile approach to enterprise IT solution delivery that provides a solid foundation from which to scale ^ Disciplined Agile Delivery Meets CMMI (Cutter IT Journal, November 2013) ^ \"Disciplined Agile Delivery\" . Crosstalk. Archived from the original on 2014-02-22 . Retrieved 2014-01-31 . ^ \"Intro to Disciplined Agile\" . ^ Ambler, Scott ; Lines, Mark (2017). An Executive's Guide to Disciplined Agile . ISBN 978-1-5398-5296-4 . ^ \"PMI Announces Acquisition of DA\" . ^ Lines, Mark; Ambler, Scott (2019). Choose Your WoW! A Disciplined Agile Delivery Handbook for Optimizing Your Way of Working . p.\u00a041. ISBN 978-1-7904-4784-8 . ^ Ambler, Scott. \"Agility@Scale: Strategies for Scaling Agile Software Development\" . IBM developerWorks . IBM Software. ^ \"Disciplined Agile Delivery: An introduction (white paper), pg 7\" (PDF) . IBM Software. Archived from the original (PDF) on 2013-05-29 . Retrieved 2014-01-31 . ^ Scott Ambler; Mark Lines (2019). \"Choose Your WoW!\" . p.\u00a046. ^ Ambler, Scott. \"Roles on DAD Teams\" . disciplinedagiledelivery.com . ^ Ambler, Scott. \"Roles on DAD Teams\" . disciplinedagiledelivery.com . ^ \"Generalizing Specialists: Improving Your IT Career Skills\" . Agile Modeling. Further reading [ edit ] Brown, Alan (2012). Enterprise Software Delivery: Bringing Agility and Efficiency to the Global Software Supply Chain . ISBN 978-0-321-80301-6 . Royce, Walker (2013). Agility at Scale: Economic Governance, Measured Improvement and Disciplined Agile Delivery . pp. 873\u2013 881. ISBN 978-1-4673-3076-3 . Supporting Governance in Disciplined Agile Delivery Using Noninvasive Measurement and Process Mining, (November 2013 Cutter IT Journal , Astromiskis, Janes, Sillitti, Succi) 10 Principles for Success in Distributed Agile Delivery (November 2013 Cutter IT Journal , Bavani) v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Disciplined_agile_delivery&oldid=1259224612 \" Category : Agile software development Hidden categories: Articles with short description Short description is different from Wikidata Articles lacking reliable references from November 2019 All articles lacking reliable references All articles with unsourced statements Articles with unsourced statements from July 2019 This page was last edited on 24 November 2024, at 01:27 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Disciplined agile delivery 2 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Model-driven_development",
    "title": "Model-driven engineering - Wikipedia",
    "content": "Model-driven engineering - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Overview 2 History 3 Advantages 4 Tools 5 See also 6 References 7 Further reading 8 External links Toggle the table of contents Model-driven engineering 12 languages Catal\u00e0 \u010ce\u0161tina Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Italiano \u65e5\u672c\u8a9e Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia (Redirected from Model-driven development ) Software development methodology This article includes a list of general references , but it lacks sufficient corresponding inline citations . Please help to improve this article by introducing more precise citations. ( August 2014 ) ( Learn how and when to remove this message ) Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Model-driven engineering ( MDE ) is a software development methodology that focuses on creating and exploiting domain models , which are conceptual models of all the topics related to a specific problem. Hence, it highlights and aims at abstract representations of the knowledge and activities that govern a particular application domain , rather than the computing (i.e. algorithmic) concepts. MDE is a subfield of a software design approach referred as round-trip engineering . The scope of the MDE is much wider than that of the Model-Driven Architecture . [ 1 ] Overview [ edit ] The MDE approach is meant to increase productivity by maximizing compatibility between systems (via reuse of standardized models), simplifying the process of design (via models of recurring design patterns in the application domain), and promoting communication between individuals and teams working on the system (via a standardization of the terminology and the best practices used in the application domain). For instance, in model-driven development, technical artifacts such as source code, documentation, tests, and more are generated algorithmically from a domain model. [ 2 ] A modeling paradigm for MDE is considered effective if its models make sense from the point of view of a user that is familiar with the domain, and if they can serve as a basis for implementing systems. The models are developed through extensive communication among product managers, designers, developers and users of the application domain. As the models approach completion, they enable the development of software and systems. Some of the better known MDE initiatives are: The Object Management Group (OMG) initiative Model-Driven Architecture (MDA) which is leveraged by several of their standards such as Meta-Object Facility , XMI , CWM , CORBA , Unified Modeling Language (to be more precise, the OMG currently promotes the use of a subset of UML called fUML together with its action language, ALF , for model-driven architecture; a former approach relied on Executable UML and OCL , instead), and QVT . [ 3 ] The Eclipse \"eco-system\" of programming and modelling tools represented in general terms by the ( Eclipse Modeling Framework ). This framework allows the creation of tools implementing the MDA standards of the OMG; but, it is also possible to use it to implement other modeling-related tools. History [ edit ] A chart showing the instantiations and representation links between a metamodel, a model and an original (in French). The first tools to support MDE were the Computer-Aided Software Engineering ( CASE ) tools developed in the 1980s. Companies like Integrated Development Environments (IDE \u2013 StP), Higher Order Software (now Hamilton Technologies, Inc., HTI), Cadre Technologies, Bachman Information Systems , and Logic Works (BP-Win and ER-Win) were pioneers in the field. The US government got involved in the modeling definitions creating the IDEF specifications. With several variations of the modeling definitions (see Booch , Rumbaugh , Jacobson , Gane and Sarson, Harel , Shlaer and Mellor , and others) they were eventually joined creating the Unified Modeling Language (UML). Rational Rose , a product for UML implementation, was done by Rational Corporation (Booch) responding automation yield higher levels of abstraction in software development. This abstraction promotes simpler models with a greater focus on problem space. Combined with executable semantics this elevates the total level of automation possible. The Object Management Group (OMG) has developed a set of standards called Model-Driven Architecture (MDA), building a foundation for this advanced architecture-focused approach. Advantages [ edit ] According to Douglas C. Schmidt , model-driven engineering technologies offer a promising approach to address the inability of third-generation languages to alleviate the complexity of platforms and express domain concepts effectively. [ 4 ] Tools [ edit ] Notable software tools for model-driven engineering include: AADL from Carnegie-Mellon Software Engineering Institute Acceleo an open source code generator from Obeo Actifsource AgileUML an open source MDE toolset from AgileMDE Ltd Ash Framework an open source Elixir-based declarative application framework ATLAS Transformation Language or ATL, a model transformation language from Obeo DUALLy , an MDE framework to create interoperability Eclipse Modeling Framework (EMF) Enterprise Architect from Sparx Systems eTrice an open source implementation of the Real-Time Object-Oriented Modeling standard Generic Eclipse Modeling System (GEMS) GeneXus a knowledge -based, declarative , multi-platform, multi-language development solution Graphical Modeling Framework (GMF) JetBrains MPS , a metaprogramming system from JetBrains MagicDraw from No Magic Inc MDriven \u2013 a UML-based, model-driven development platform that generates .NET and web applications from executable models. MERODE JMermaid from KU Leuven (educational) MetaEdit+ from MetaCase ModelCenter from Phoenix Integration Open ModelSphere OptimalJ from Compuware PREEvision from Vector Informatik Rhapsody from IBM PowerDesigner from SAP Simulink from MathWorks Software Ideas Modeler from Dusan Rodina Sirius an Eclipse open source project to create custom graphical modeling workbenches Together Architect from Borland Umbrello by KDE Umple from the University of Ottawa Uniface from Compuware YAKINDU Statechart Tools open source tool build on top of Eclipse See also [ edit ] Application lifecycle management (ALM) Business Process Model and Notation (BPMN) Business-driven development (BDD) Domain-driven design (DDD) Domain-specific language (DSL) Domain-specific modeling (DSM) Domain-specific multimodeling Language-oriented programming (LOP) List of Unified Modeling Language tools Model transformation (e.g. using QVT ) Model-based testing (MBT) Modeling Maturity Level (MML) Model-based systems engineering (MBSE) Service-oriented modeling Framework (SOMF) Software factory (SF) Story-driven modeling (SDM) Open API , open source specification for description of models and operations for HTTP interoperation and REST APIc References [ edit ] ^ \"8 Reasons Why Model-Driven Approaches (will) Fail\" . InfoQ . Retrieved 2023-07-26 . ^ Flatt, Amelie; Langner, Arne; Leps, Olof (2022). Model-Driven Development of Akoma Ntoso Application Profiles - A Conceptual Framework for Model-Based Generation of XML Subschemas (1st\u00a0ed.). Heidelberg: Sprinter Nature. ISBN 978-3-031-14131-7 . ^ Object Management Group (2006-05-24). \"OMG Trademarks\" . Retrieved 2008-02-26 . ^ Schmidt, D.C. (February 2006). \"Model-Driven Engineering\" (PDF) . IEEE Computer . 39 (2). doi : 10.1109/MC.2006.58 . S2CID 10006139 . Archived from the original (PDF) on 2006-09-09 . Retrieved 2006-05-16 . , \"A promising approach to address platform complexity\u2014and the inability of third-generation languages to alleviate this complexity and express domain concepts effectively\u2014is to develop Model-Driven Engineering (MDE) technologies...\" Further reading [ edit ] David S. Frankel , Model Driven Architecture: Applying MDA to Enterprise Computing , John Wiley & Sons, ISBN 0-471-31920-1 Marco Brambilla, Jordi Cabot, Manuel Wimmer, Model Driven Software Engineering in Practice , foreword by Richard Soley ( OMG Chairman), Morgan & Claypool, USA, 2012, Synthesis Lectures on Software Engineering #1. 182 pages. ISBN 9781608458820 (paperback), ISBN 9781608458837 (ebook). https://www.mdse-book.com da Silva, Alberto Rodrigues (2015). \"Model-Driven Engineering: A Survey Supported by a Unified Conceptual Model\" . Computer Languages, Systems & Structures . 43 (43): 139\u2013 155. doi : 10.1016/j.cl.2015.06.001 . External links [ edit ] Model-Driven Architecture: Vision, Standards And Emerging Technologies at omg.org v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Model-driven_engineering&oldid=1310539156 \" Categories : Systems engineering Unified Modeling Language Hidden categories: Articles with short description Short description is different from Wikidata Articles lacking in-text citations from August 2014 All articles lacking in-text citations This page was last edited on 10 September 2025, at 05:29 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Model-driven engineering 12 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Kanban_(development)",
    "title": "Kanban (development) - Wikipedia",
    "content": "Kanban (development) - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Kanban boards 2 Kanban practices 3 Managing workflow 4 Evolution and documentation of method 5 See also 6 References 7 Further reading Toggle the table of contents Kanban (development) 17 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 \u0540\u0561\u0575\u0565\u0580\u0565\u0576 Magyar \u65e5\u672c\u8a9e Polski \u0420\u0443\u0441\u0441\u043a\u0438\u0439 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia A major contributor to this article appears to have a close connection with its subject. It may require cleanup to comply with Wikipedia's content policies, particularly neutral point of view . Please discuss further on the talk page . ( August 2022 ) ( Learn how and when to remove this message ) Workflow management method This article is about the process-management and improvement method. For the lean-manufacturing process, see Kanban . A Kanban board Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Kanban ( Japanese : \u770b\u677f , meaning signboard or billboard ) is a lean method to manage and improve work across human systems . This approach aims to manage work by balancing demands with available capacity, and by improving the handling of system-level bottlenecks . Work items are visualized to give participants a view of progress and process, from start to finish\u2014usually via a kanban board . Work is pulled as capacity permits, rather than work being pushed into the process when requested. In knowledge work and in software development , the aim is to provide a visual process management system which aids decision-making about what, when, and how much to produce. The underlying kanban method originated in lean manufacturing , [ 1 ] which was inspired by the Toyota Production System . [ 2 ] It has its origin in the late 1940s when the Toyota automotive company implemented a production system called just-in-time, which had the objective of producing according to customer demand and identifying possible material shortages within the production line. But it was a team at Corbis that realized how this method devised by Toyota could become a process applicable to any type of organizational process. Kanban is commonly used in software development in combination with methods and frameworks such as Scrum . [ 3 ] Kanban boards [ edit ] Main article: Kanban board The diagram here shows a software development workflow on a kanban board. [ 4 ] Kanban boards, designed for the context in which they are used, vary considerably and may show work item types (\"features\" and \" user stories \" here), columns delineating workflow activities, explicit policies, and swimlanes (rows crossing several columns, used for grouping user stories by feature here). The aim is to make the general workflow and the progress of individual items clear to participants and stakeholders. A Kanban Board represents the system's Definition of Workflow [ 5 ] and requires the following minimum elements: A definition of the individual units of value that are moving through the workflow. These units of value are referred to as work items (or items ). A definition for when work items are started and finished within the workflow. Your workflow may have more than one started or finished points depending on the work item. One or more defined states that the work items flow through from started to finished. Any work items between a started point and a finished point are considered work in progress (WIP). A definition of how WIP will be controlled from started to finished. Explicit policies about how work items can flow through each state from started to finished. A service level expectation (SLE), which is a forecast of how long it should take a work item to flow from started to finished. Kanban practices [ edit ] The Practices of Kanban as described in the Kanban Guide [ 6 ] are Defining and visualizing a workflow Actively managing items in a workflow Improving a workflow Kanban is a strategy that aims to follow these in order to create systems that are efficient, effective, and predictable. The Kanban Method is a specialized and detailed extrapolation of Kanban. As described in books on The Kanban Method for software development, [ 7 ] [ 3 ] the two primary practices of The Kanban Method are to visualize work and to limit work in progress (WIP). Four additional general practices of The Kanban Method listed in Essential Kanban Condensed are to make policies explicit, manage flow, implement feedback loops, and improve collaboratively. [ 8 ] The kanban board in the diagram above highlights the first three general practices of The Kanban Method. It visualizes the work of the development team (the features and user stories). It captures WIP limits for development steps: the circled values below the column headings that limit the number of work items under that step. It documents policies, also known as done rules, [ 9 ] inside blue rectangles under some of the development steps. It also shows some kanban flow management for the \"user story preparation\", \"user story development\", and \"feature acceptance\" steps, which have \"in progress\" and \"ready\" sub-columns. Each step's WIP limit applies to both sub-columns, preventing work items from overwhelming the flow into or out of those steps. Managing workflow [ edit ] Kanban manages workflow directly on the kanban board. The WIP limits for development steps provide development teams immediate feedback on common workflow issues. [ 7 ] [ 9 ] For example, on the kanban board shown above, the \"deployment\" step has a WIP limit of five and there are currently five epics [ 10 ] shown in that step. No more work items can move into deployment until one or more epics complete that step (moving to \"delivered\"). This prevents the \"deployment\" step from being overwhelmed. Team members working on \"feature acceptance\" (the previous step) might get stuck because they can't deploy new epics. They can see why immediately on the board and help with the current epic deployments. Once the five epics in the \"deployment\" step are delivered, the two epics from the \"ready\" sub-column of \"feature acceptance\" (the previous step) can be moved to the \"deployment\" column. When those two epics are delivered, no other epics can be deployed (assuming no new epics are ready). Now, team members working on deployment are stuck. They can see why immediately and help with feature acceptance. In a Kanban board setup, swimlanes are used to visually organize work into different stages of a process, ensuring clarity and focus. For efficient workflow management, it is crucial to maintain distinct swimlanes for key phases such as requirements, development, testing, and closed/completed tasks. Specifically, testing stories should always be placed within the designated \"Testing\" swimlane. This separation ensures that testing activities are easily trackable and not intermingled with other stories in development or other stages. By keeping testing tasks within their own swimlane, teams can quickly identify bottlenecks, prioritize issues, and maintain the integrity of the testing process without cross-contamination from development or requirement phases. This structure leads to clearer workflows and enhances team collaboration. This workflow control works similarly for every step. Problems are visual and evident immediately, and re-planning can be done continuously. The work management is made possible by limiting work in progress in a way team members can see and track at all times. Evolution and documentation of method [ edit ] David Anderson's 2010 book, Kanban , [ 7 ] describes an evolution of the approach from a 2004 project at Microsoft [ 11 ] using a theory-of-constraints approach and incorporating a drum-buffer-rope (comparable to the kanban pull system ), to a 2006\u20132007 project at Corbis (a separate company, also founded by Bill Gates) in which the kanban method was [ by whom? ] identified. In 2009, Don Reinertsen published a book on second-generation lean product-development [ 12 ] which describes the adoption of the kanban system and the use of data collection and an economic model for management decision-making. Another early contribution came from Corey Ladas, whose 2008 book Scrumban [ 3 ] suggested that kanban could improve scrum for software development. Ladas saw scrumban as the transition from scrum to kanban. Jim Benson and Tonianne DeMaria Barry published Personal Kanban , [ 13 ] applying kanban to individuals and small teams, in 2011. In Kanban from the Inside (2014), [ 14 ] Mike Burrows explained kanban's principles, practices and underlying values and related them to earlier theories and models. In Agile Project Management with Kanban (2015), [ 9 ] Eric Brechner provides an overview of kanban in practice at Microsoft and Xbox . Kanban Change Leadership (2015), by Klaus Leopold and Siegfried Kaltenecker, [ 15 ] explained the method from the perspective of change management and provided guidance to change-initiatives. In 2016 Lean Kanban University Press published a condensed guide to the method, incorporating improvements and extensions from the early kanban projects. [ 8 ] In 2020 John Coleman and Daniel Vacanti published The Kanban Guide [ 6 ] to describe the minimal conditions needed to operate a Kanban system. Colleen Johnson, Daniel Vacanti, and Prateek Singh published The Kanban Pocket Guide [ 16 ] in 2022, which helps practitioners navigate the Kanban practices. Will Seele and Daniel Vacanti also published the Flow Metrics for Scrum Teams [ 17 ] book in 2022 to bring the benefits of metrics commonly used in Kanban to Scrum teams. See also [ edit ] Kanban (development) at Wikipedia's sister projects : Media from Commons Data from Wikidata Agile management List of software development philosophies References [ edit ] ^ Womack, James P. (2007). The Machine That Changed the World . Simon & Schuster. ISBN 978-1847370556 . ^ Ohno, Taiichi (1988). Toyota Production System: Beyond Large-Scale Production . ISBN 978-0915299140 . ^ a b c Corey, Ladas (2008). Scrumban and other essays on Kanban System for Lean Software development . Seattle, Washington: Modus Cooperandi Press. ISBN 9780578002149 . OCLC 654393465 . ^ Boeg, Jasper (February 2012). \"Priming Kanban\" . InfoQ . Retrieved 17 February 2014 . ^ Coleman, John; Vacanti, Daniel. \"Kanban Guide - Definition of Workflow\" . Kanban Guides . Retrieved 17 August 2023 . ^ a b Coleman, John; Vacanti, Daniel. \"Kanban Guide\" . Kanban Guides . Retrieved 17 August 2023 . ^ a b c Anderson, David J. (April 2010). Kanban: Successful Evolutionary Change for Your Technology Business . Blue Hole Press. ISBN 978-0-9845214-0-1 . ^ a b Anderson, David J.; Carmichael, Andy (2016). Essential Kanban Condensed . Seattle, WA: Lean Kanban University Press. ISBN 978-0-9845214-2-5 . ^ a b c Brechner, Eric (2015). Agile Project Management with Kanban . Microsoft Press. p.\u00a0160. ISBN 978-0735698956 . ^ \" \"Mist\" \" . Mist . Mist Technologies. ^ Anderson, David J.; Dumitriu, Dragos (November 2005). From Worst to Best in 9 Months: Implementing a Drum-Buffer-Rope Solution at Microsoft's IT Department (PDF) . TOC ICO World Conference November 2005. USA: Microsoft Corporation . Retrieved 24 September 2020 . ^ Reinertsen, Donald (May 2009). The Principles of Product Development Flow: Second Generation Lean Product Development . Celeritas Publishing. ISBN 978-1935401001 . ^ Benson, Jim; DeMaria Barry, Tonianne (January 2011). Personal Kanban: Mapping Work, Navigating Life . Modus Cooperandi Press. ISBN 978-1453802267 . ^ Burrows, Mike (2014). Kanban From The Inside . Seattle, WA: Blue Hole Press. ISBN 978-0-9853051-9-2 . ^ Leopold, Klaus; Siegfried, Kaltenecker (2015). Kanban Change Leadership . Hoboken, NJ: John Wiley & Sons. ISBN 978-1-119-01970-1 . ^ Johnson, Colleen; Vacanti, Daniel; Singh, Prateek. \"The Kanban Pocket Guide\" . ProKanban.org . Retrieved 17 August 2023 . ^ Seele, Wilbert; Vacanti, Daniel. \"Flow Metrics for Scrum Teams\" . ProKanban.org . Retrieved 17 August 2023 . Further reading [ edit ] Anderson, David J. (2010). Kanban: Successful Evolutionary Change for Your Technology Business . United States: Blue Hole Press. ISBN 978-0984521401 . Ladas, Corey (2009). Scrumban: Essays on Kanban Systems for Lean Software Development . United States: Modus Cooperandi Press. ISBN 9780578002149 . Brechner, Eric (2015). Agile Project Management with Kanban . Developer Best Practices. United States: Microsoft Press. ISBN 978-0735698956 . Hammarberg, Marcus ; Sunden, Joakim (2014). Kanban in Action . Shelter Island, NY: Manning Publications. ISBN 978-1-617291-05-0 . Kniberg, Henrik (2012). Lean from the Trenches: Managing Large-Scale Projects with Kanban . Dallas, TX: The Pragmatic Programmers. ISBN 978-1-93435-685-2 . Roock, Arne ; Leschik, Claudia (2012). Stop Starting, Start Finishing! . USA: Lean-Kanban University. ISBN 978-0985305161 . Skarin, Mattias (2015). Real-World Kanban: Do Less, Accomplish More with Lean Thinking . United States: Pragmatic Bookshelf. ISBN 978-1680500776 . Authority control databases GND Retrieved from \" https://en.wikipedia.org/w/index.php?title=Kanban_(development)&oldid=1328346909 \" Categories : Agile software development Japanese business terms Software development philosophies Toyota Production System Hidden categories: Wikipedia articles with possible conflicts of interest from August 2022 Articles with short description Short description is different from Wikidata Use dmy dates from January 2021 Articles containing Japanese-language text Articles with specifically marked weasel-worded phrases from June 2020 This page was last edited on 19 December 2025, at 09:08 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Kanban (development) 17 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Lean_software_development",
    "title": "Lean software development - Wikipedia",
    "content": "Lean software development - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Origin 2 Lean principles Toggle Lean principles subsection 2.1 Eliminate waste 2.2 Amplify learning 2.3 Decide as late as possible 2.4 Deliver as fast as possible 2.5 Empower the team 2.6 Build integrity in 2.7 Optimize the whole 3 Lean software practices 4 See also 5 References 6 Further reading Toggle the table of contents Lean software development 11 languages \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u010ce\u0161tina Espa\u00f1ol Fran\u00e7ais Italiano Nederlands Polski \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Use of lean manufacturing principles in software development Not to be confused with Lean (proof assistant) . This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Lean software development\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( July 2014 ) ( Learn how and when to remove this message ) This article may be too technical for most readers to understand . Please help improve it to make it understandable to non-experts , without removing the technical details. ( July 2025 ) ( Learn how and when to remove this message ) Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Lean software development is a translation of lean manufacturing principles and practices to the software development domain. Adapted from the Toyota Production System , [ 1 ] it is emerging with the support of a pro-lean subculture within the agile community. Lean offers a solid conceptual framework , values and principles, as well as good practices, derived from experience, that support agile organizations. Origin [ edit ] The expression \"lean software development\" originated in a book by the same name, written by Mary Poppendieck and Tom Poppendieck in 2003. [ 2 ] The book restates traditional lean principles , as well as a set of 22 tools and compares the tools to corresponding agile practices. The Poppendiecks' involvement in the agile software development community, including talks at several Agile conferences [ 3 ] has resulted in such concepts being more widely accepted within the agile community. Lean principles [ edit ] Lean development can be summarized by seven principles, very close in concept to lean manufacturing principles: [ 4 ] Eliminate waste Amplify learning Decide as late as possible Deliver as fast as possible Empower the team Build integrity in Optimize the whole Eliminate waste [ edit ] Lean philosophy regards everything not adding value to the customer as waste ( muda ). The seven wastes mapped from manufacturing to software as described in the book Lean Software Development: An Agile Toolkit, Table 1.1: [ 5 ] The Seven Wastes The Seven Wastes of Manufacturing The Seven Wastes of Software Development Inventory Partially done work Extra Processing Extra Processes Overproduction Extra features Transportation Task switching Waiting Waiting Motion Motion (hand offs) Defects Defects In order to eliminate waste, one should be able to recognize it. If some activity could be bypassed or the result could be achieved without it, it is waste. Partially done coding eventually abandoned during the development process is waste. Extra features like paperwork and features not often used by customers are waste. Switching people between tasks is waste (because of time spent, and often lost, by people involved in context-switching). Waiting for other activities, teams, processes is waste. Relearning requirements to complete work is waste. Defects and lower quality are waste. Managerial overhead not producing real value is waste. A value stream mapping technique is used to identify waste. The second step is to point out sources of waste and to eliminate them. Waste-removal should take place iteratively until even seemingly essential processes and procedures are liquidated. Amplify learning [ edit ] Software development is a continuous learning process based on iterations when writing code. Software design is a problem-solving process involving the developers writing the code and what they have learned. Software value is measured in fitness for use and not in conformance to requirements. Instead of adding more documentation or detailed planning, different ideas could be tried by writing code and building. The process of user requirements gathering could be simplified by presenting screens to the end-users and getting their input. The accumulation of defects should be prevented by running tests as soon as the code is written. The learning process is sped up by usage of short iteration cycles \u2013 each one coupled with refactoring and integration testing . Increasing feedback via short feedback sessions with customers helps when determining the current phase of development and adjusting efforts for future improvements. During those short sessions, both customer representatives and the development team learn more about the domain problem and figure out possible solutions for further development. Thus the customers better understand their needs, based on the existing result of development efforts, and the developers learn how to better satisfy those needs. Another idea in the communication and learning process with a customer is set-based development \u2013 this concentrates on communicating the constraints of the future solution and not the possible solutions, thus promoting the birth of the solution via dialogue with the customer. [ jargon ] Decide as late as possible [ edit ] As software development is always associated with some uncertainty, better results should be achieved with a set-based or options-based approach, delaying decisions as much as possible until they can be made based on facts and not on uncertain assumptions and predictions. The more complex a system is, the more capacity for change should be built into it, thus enabling the delay of important and crucial commitments. The iterative approach promotes this principle \u2013 the ability to adapt to changes and correct mistakes, which might be very costly if discovered after the release of the system. With set-based development: If a new brake system is needed for a car, for example, three teams may design solutions to the same problem. Each team learns about the problem space and designs a potential solution. As a solution is deemed unreasonable, it is cut. At the end of a period, the surviving designs are compared and one is chosen, perhaps with some modifications based on learning from the others - a great example of deferring commitment until the last possible moment. Software decisions could also benefit from this practice to minimize the risk brought on by big up-front design. Additionally, there would then be multiple implementations that work correctly, yet are different (implementation-wise, internally). These could be used to implement fault-tolerant systems which check all inputs and outputs for correctness, across the multiple implementations, simultaneously. An agile software development approach can move the building of options earlier for customers, thus delaying certain crucial decisions until customers have realized their needs better. This also allows later adaptation to changes and the prevention of costly earlier technology-bounded decisions. This does not mean that no planning should be involved \u2013 on the contrary, planning activities should be concentrated on the different options and adapting to the current situation, as well as clarifying confusing situations by establishing patterns for rapid action. Evaluating different options is effective as soon as it is realized that they are not free, but provide the needed flexibility for late decision making. Deliver as fast as possible [ edit ] In the era of rapid technology evolution, it is not the biggest that survives, but the fastest. The sooner the end product is delivered without major defects, the sooner feedback can be received, and incorporated into the next iteration . The shorter the iterations, the better the learning and communication within the team. With speed, decisions can be delayed. Speed assures the fulfilling of the customer's present needs and not what they required yesterday. This gives them the opportunity to delay making up their minds about what they really require until they gain better knowledge. Customers value rapid delivery of a quality product. The just-in-time production ideology could be applied to software development , recognizing its specific requirements and environment. This is achieved by presenting the needed result and letting the team organize itself and divide the tasks for accomplishing the needed result for a specific iteration . At the beginning, the customer provides the needed input. This could be simply presented in small cards or stories \u2013 the developers estimate the time needed for the implementation of each card. Thus the work organization changes into self-pulling system \u2013 each morning during a stand-up meeting , each member of the team reviews what has been done yesterday, what is to be done today and tomorrow, and prompts for any inputs needed from colleagues or the customer. This requires transparency of the process, which is also beneficial for team communication. The myth underlying this principle is haste makes waste . However, lean implementation has shown that it is a good practice to deliver fast in order to see and analyze the output as early as possible. Empower the team [ edit ] There has been a traditional belief in most businesses about the decision-making in the organization \u2013 the managers tell the workers how to do their own job. In a work-out technique , the roles are turned \u2013 the managers are taught how to listen to the developers , so they can explain better what actions might be taken, as well as provide suggestions for improvements. The lean approach follows the agile principle [ 6 ] \"build projects around motivated individuals [...] and trust them to get the job done\", [ 7 ] encouraging progress, catching errors, and removing impediments, but not micro-managing . Another mistaken belief has been the consideration of people as resources . People might be resources from the point of view of a statistical data sheet, but in software development , as well as any organizational business, people do need something more than just the list of tasks and the assurance that they will not be disturbed during the completion of the tasks. People need motivation and a higher purpose to work for \u2013 purpose within the reachable reality, with the assurance that the team might choose its own commitments. The developers should be given access to the customer; the team leader should provide support and help in difficult situations, as well as ensure that skepticism does not ruin the team's spirit. Respecting people and acknowledging their work is one way to empower the team. Build integrity in [ edit ] The customer needs to have an overall experience of the system. This is the so-called perceived integrity: how it is being advertised, delivered, deployed, accessed, how intuitive its use is, its price and how well it solves problems. Conceptual integrity means that the system's separate components work well together as a whole with balance between flexibility, maintainability , efficiency, and responsiveness. This could be achieved by understanding the problem domain and solving it at the same time, not sequentially. The needed information is received in small batch pieces \u2013 not in one vast chunk - preferably by face-to-face communication and not any written documentation. The information flow should be constant in both directions \u2013 from customer to developers and back, thus avoiding the large stressful amount of information after long development in isolation. One of the healthy ways towards integral architecture is refactoring . As more features are added to the original code base, the harder it becomes to add further improvements. Refactoring is about keeping simplicity, clarity, minimum number of features in the code. Repetitions in the code are signs of bad code designs and should be avoided (i.e. by applying the DRY rule ). The complete and automated building process should be accompanied by a complete and automated suite of developer and customer tests, having the same versioning, synchronization and semantics as the current state of the system. At the end the integrity should be verified with thorough testing, thus ensuring the System does what the customer expects it to. Automated tests are also considered part of the production process, and therefore if they do not add value they should be considered waste. Automated testing should not be a goal, but rather a means to an end, specifically the reduction of defects. Optimize the whole [ edit ] Modern software systems are not simply the sum of their parts, but also the product of their interactions. Defects in software tend to accumulate during the development process \u2013 by decomposing the big tasks into smaller tasks, and by standardizing different stages of development, the root causes of defects should be found and eliminated. The larger the system, the more organizations that are involved in its development and the more parts are developed by different teams, the greater the importance of having well defined relationships between different vendors, in order to produce a system with smoothly interacting components. During a longer period of development, a stronger subcontractor network is far more beneficial than short-term profit optimizing, which does not enable win-win relationships . Lean thinking has to be understood well by all members of a project, before implementing in a concrete, real-life situation. \"Think big, act small, fail fast; learn rapidly\" [ 8 ] \u2013 these slogans summarize the importance of understanding the field and the suitability of implementing lean principles along the whole software development process. Only when all of the lean principles are implemented together, combined with strong \"common sense\" with respect to the working environment, is there a basis for success in software development . Lean software practices [ edit ] Lean software development practices, or what the Poppendiecks call \"tools\" are restated slightly from the original equivalents in agile software development . Examples of such practices include: Seeing waste Value stream mapping Set-based development Pull systems Queueing theory Motivation Measurements Test-driven development Since agile software development is an umbrella term for a set of methods and practices based on the values and principles expressed in the Agile Manifesto, lean software development is considered an agile software development method. [ 9 ] See also [ edit ] Extreme programming DevOps Kanban Kanban board Lean integration Lean services Scrum (development) References [ edit ] ^ Yasuhiro Monden (1998), Toyota Production System, An Integrated Approach to Just-In-Time , Third edition, Norcross, GA: Engineering & Management Press, ISBN 0-412-83930-X . ^ Mary Poppendieck; Tom Poppendieck (2003). Lean Software Development: An Agile Toolkit . Addison-Wesley Professional. ISBN 978-0-321-15078-3 . ^ Mary Poppendieck: \"The role of leadership in software development\" https://www.youtube.com/watch?v=ypEMdjslEOI ^ Mary Poppendieck; Tom Poppendieck (2003). Lean Software Development: An Agile Toolkit . Addison-Wesley Professional. pp. 13\u2013 15. ISBN 978-0-321-15078-3 . ^ Mary Poppendieck; Tom Poppendieck (2003). Lean Software Development: An Agile Toolkit . Addison-Wesley Professional. p.\u00a04. ISBN 978-0-321-15078-3 . ^ \"12 Principles Behind the Agile Manifesto - Agile Alliance\" . agilealliance.org . 4 November 2015. ^ Mark Lines; Scott W. Ambler (2012). Disciplined Agile Delivery: A Practitioner's Guide to Agile Software Delivery in the Enterprise . IBM Press. pp.\u00a054\u2013. ISBN 978-0-13-281013-5 . ^ Mary Poppendieck; Tom Poppendieck (2003). Lean Software Development: An Agile Toolkit . Addison-Wesley Professional. pp.\u00a0182\u2013. ISBN 978-0-321-15078-3 . ^ \"What is Agile Software Development?\" . agilealliance.org . 29 June 2015. Further reading [ edit ] Ladas, Corey (January 2008). Scrumban: Essays on Kanban Systems for Lean Software Development . Modus Cooperandi Press. ISBN 978-0-578-00214-9 . Ries, Eric (September 2011). The Lean Startup : How Today's Entrepreneurs Use Continuous Innovation to Create Radically Successful Businesses . Crown Business. ISBN 978-0307887894 . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Lean_software_development&oldid=1313483120 \" Categories : Software development philosophies Agile software development Lean manufacturing Hidden categories: Articles with short description Short description is different from Wikidata Articles needing additional references from July 2014 All articles needing additional references Wikipedia articles that are too technical from July 2025 All articles that are too technical Wikipedia articles that are too technical from June 2018 All articles needing expert attention Articles needing expert attention from June 2018 This page was last edited on 26 September 2025, at 13:50 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Lean software development 11 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Microsoft_Solutions_Framework",
    "title": "Microsoft Solutions Framework - Wikipedia",
    "content": "Microsoft Solutions Framework - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Components 3 References 4 External links Toggle the table of contents Microsoft Solutions Framework 4 languages \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia This article relies excessively on references to primary sources . Please improve this article by adding secondary or tertiary sources . Find sources: \"Microsoft Solutions Framework\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( December 2010 ) ( Learn how and when to remove this message ) Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Microsoft Solutions Framework ( MSF ) is a set of principles, models, disciplines, concepts, and guidelines for delivering information technology services from Microsoft . MSF is not limited to developing applications only; it is also applicable to other IT projects like deployment, networking or infrastructure projects. MSF does not force the developer to use a specific methodology (such as the waterfall model or agile software development ). History [ edit ] MSF was first introduced by Microsoft as version 1.0 in 1993, and a version 2.0 was released in 1997. In 2002, MSF version 3.0 was released. It modified version 2.0 in the following ways: Combined previously separate models into unified Team and Process models designed for application across a variety of project types including deployment, enterprise software integration, and development projects. Folded the Application Development and Infrastructure Deployment models into a single Process Model consisting of five phases. Added Project Management and Readiness Management Disciplines. Made changes to the Risk Management Discipline. Added links between MSF and the Microsoft Operations Framework (MOF). Added an MSF Practitioner Program designed to train individuals to lead or participate in MSF projects. [ 1 ] MSF version 4.0 was released in 2005. The release was a major refresh of the Process Model (now called the Governance Model) and the Team Model. [ 2 ] MSF 4.0 included techniques for two separate methodologies: MSF for Agile Software Development (MSF Agile) and MSF for CMMI Process Improvement (MSF4CMMI). [ 3 ] Components [ edit ] MSF 4.0 is a combination of a metamodel which can be used as a base for prescriptive software engineering processes, and two customizable and scalable software engineering processes.  The MSF metamodel consists of foundational principles, a team model and cycles and iterations. MSF 4.0 provides a higher-level framework of guidance and principles which can be mapped to a variety of prescriptive process templates. It is structured in both descriptive and prescriptive methodologies . The descriptive component is called the MSF 4.0 metamodel , which is a theoretical description of the SDLC best practices for creating SDLC methodologies. Microsoft is of the opinion that organizations have diverging dynamics and contrary priorities during their software development ; some organizations need a responsive and adaptable software development environment, while others need a standardized, repeatable and more controlled environment. To fulfill these needs, Microsoft represents the metamodel of MSF 4.0 in two prescriptive methodology templates that provide specific process guidance, for agile software development (MSF4ASD) and  for the Capability Maturity Model (MSF4CMMI). These software engineering processes can be modified and customized to the preferences of organization, customer and project team. The MSF philosophy holds that there is no single structure or process that optimally applies to the requirements and environments for all sorts of projects. Therefore, MSF supports multiple process approaches, so it can be adapted to support any project, regardless of size or complexity. This flexibility means that it can support a wide degree of variation in the implementation of software engineering processes while retaining a set of core principles and mindsets. The MSF process model consists of series of short development cycles and iterations. This model embraces rapid iterative development with continuous learning and refinement, due to progressive understanding of the business and project of the stakeholders . Identifying requirements, product development, and testing occur in overlapping iterations resulting in incremental completion to ensure a flow of value of the project. Each iteration has a different focus and result in a stable portion of the overall system. References [ edit ] ^ Keeton, Marlys (April 2006). Microsoft Solutions Framework (MSF): A Pocket Guide . Van Haren Publishing. p.\u00a015. ISBN 90-77212-16-7 . [1] ^ Turner, Michael S. V. (2006-08-30). Microsoft Solutions Framework Essentials: Building Successful Technology Solutions . Microsoft Press. ISBN 0-7356-2353-8 . ^ MSF 4.0 and Microsoft Team Services External links [ edit ] Microsoft Solution Framework home page Microsoft Solution Framework in Visual Studio 2005 Team System MSF Essentials book Retrieved from \" https://en.wikipedia.org/w/index.php?title=Microsoft_Solutions_Framework&oldid=1285918560 \" Category : Microsoft development tools Hidden categories: Articles lacking reliable references from December 2010 All articles lacking reliable references This page was last edited on 16 April 2025, at 15:42 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Microsoft Solutions Framework 4 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Scrum_(software_development)#Large-scale_Scrum",
    "title": "Scrum (project management) - Wikipedia",
    "content": "Scrum (project management) - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Scrum team Toggle Scrum team subsection 2.1 Product owner 2.2 Developers 2.3 Scrum master 3 Workflow Toggle Workflow subsection 3.1 Sprint 3.2 Daily scrum 3.3 Post-sprint events 3.4 Backlog Refinement 4 Artifacts Toggle Artifacts subsection 4.1 Product backlog 4.2 Sprint backlog 4.3 Increment 4.4 Other artifacts 4.4.1 Burndown chart 4.4.2 Burnup chart 4.4.3 Velocity 5 Limitations 6 Adaptations Toggle Adaptations subsection 6.1 Scrumban 6.2 Scrum of scrums 6.3 Large-scale scrum 7 Criticism 8 See also 9 Citations 10 General and cited references 11 External links Toggle the table of contents Scrum (project management) 38 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u09ac\u09be\u0982\u09b2\u09be \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u010ce\u0161tina Dansk Deutsch Eesti \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac Espa\u00f1ol Esperanto \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Bahasa Indonesia Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Lietuvi\u0173 Magyar \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas Rom\u00e2n\u0103 \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Srpskohrvatski / \u0441\u0440\u043f\u0441\u043a\u043e\u0445\u0440\u0432\u0430\u0442\u0441\u043a\u0438 Suomi Svenska \u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia (Redirected from Scrum (software development) ) Management framework This article is about software development framework. For other uses, see Scrum . Some of this article's listed sources may not be reliable . Please help improve this article by looking for better, more reliable sources. Unreliable citations may be challenged and removed. ( May 2020 ) ( Learn how and when to remove this message ) Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Scrum Agile events, based on The 2020 Scrum Guide [ 1 ] Scrum is an agile team collaboration framework commonly used in software development and other industries. Scrum prescribes for teams to break work into goals to be completed within time-boxed iterations, called sprints . Each sprint is no longer than one month and commonly lasts two weeks. The scrum team assesses progress in time-boxed, stand-up meetings of up to 15 minutes, called daily scrums . At the end of the sprint, the team holds two further meetings: one sprint review to demonstrate the work for stakeholders and solicit feedback, and one internal sprint retrospective . A person in charge of a scrum team is typically called a scrum master . [ 2 ] Scrum teams should be cross-functional and self-managing . Unlike sequential approaches, scrum is an iterative and incremental framework for product development. [ 3 ] Scrum allows for continuous feedback and flexibility, requiring teams to self-organize by encouraging physical co-location or close online collaboration, and mandating frequent communication among all team members. The flexible approach of scrum is based in part on the notion of requirement volatility, that stakeholders will change their requirements as the project evolves. [ 4 ] History [ edit ] The use of the term scrum in software development came from a 1986 Harvard Business Review paper titled \"The New New Product Development Game\" by Hirotaka Takeuchi and Ikujiro Nonaka . Based on case studies from manufacturing firms in the automotive, photocopier, and printer industries , the authors outlined a new approach to product development for increased speed and flexibility. They called this the rugby approach, as the process involves a single cross-functional team operating across multiple overlapping phases in which the team \"tries to go the distance as a unit, passing the ball back and forth\". [ 5 ] The authors later developed scrum in their book, The Knowledge Creating Company . [ 6 ] In the early 1990s, Ken Schwaber used what would become scrum at his company, Advanced Development Methods. Jeff Sutherland , John Scumniotales, and Jeff McKenna developed a similar approach at Easel Corporation, referring to the approach with the term scrum . [ 7 ] Sutherland and Schwaber later worked together to integrate their ideas into a single framework, formally known as scrum. Schwaber and Sutherland tested scrum and continually improved it, leading to the publication of a research paper in 1995, [ 8 ] and the Manifesto for Agile Software Development in 2001. [ 9 ] Schwaber also collaborated with Babatunde Ogunnaike at DuPont Research Station and the University of Delaware to develop Scrum. Ogunnaike believed that software development projects could often fail when initial conditions change if product management was not rooted in empirical practice. [ 10 ] In 2002, Schwaber with others founded the Scrum Alliance and set up the Certified Scrum accreditation series. [ 11 ] Schwaber left the Scrum Alliance in late 2009 and subsequently founded Scrum.org, which oversees the parallel Professional Scrum accreditation series. [ 12 ] Since 2009, a public document called The Scrum Guide [ 13 ] has been published and updated by Schwaber and Sutherland. It has been revised six times, with the most recent version having been published in November 2020. Scrum team [ edit ] A scrum team is organized into at least three categories of individuals: the product owner, developers, and the scrum master. The product owner liaises with stakeholders, those who have an interest in the project's outcome, to communicate tasks and expectations with developers. [ 14 ] Developers in a scrum team organize work by themselves, with the facilitation of a scrum master. [ 15 ] Product owner [ edit ] Each scrum team has one product owner. [ 16 ] The product owner focuses on the business side of product development and spends the majority of time liaising with stakeholders and the team. The role is intended to primarily represent the product's stakeholders , the voice of the customer , or the desires of a committee , and bears responsibility for the delivery of business results. [ 17 ] [ 18 ] [ 19 ] [ 20 ] Product owners manage the product backlog and are responsible for maximizing the value that a team delivers. [ 18 ] They do not dictate the technical solutions of a team but may instead attempt to seek consensus among team members. [ 21 ] [ 22 ] Developers [ edit ] In scrum, the term developer or team member refers to anyone who plays a role in the development and support of the product and can include researchers, architects , designers, programmers, etc. [ 13 ] [ 23 ] Scrum master [ edit ] Scrum is facilitated by a scrum master, whose role is to educate and coach teams about scrum theory and practice. [ 1 ] Scrum masters have differing roles and responsibilities from traditional team leads or project managers . Some scrum master responsibilities include coaching, objective setting, problem solving, oversight, planning, backlog management, and communication facilitation. [ 1 ] On the other hand, traditional project managers often have people management responsibilities, which a scrum master does not. Scrum teams do not involve project managers, so as to maximize self-organisation among developers. [ 3 ] Workflow [ edit ] Sprint [ edit ] Not to be confused with Hackathon \u00a7\u00a0Code sprints . The scrum framework (PBI in the figure refers to product backlog item) The scrum process A sprint (also known as a design sprint , iteration , or timebox ) is a fixed period of time wherein team members work on a specific goal. Each sprint is normally between one week and one month, with two weeks being the most common. [ 10 ] The outcome of the sprint is a functional deliverable, or a product which has received some development in increments . When a sprint is abnormally terminated, the next step is to conduct new sprint planning, where the reason for the termination is reviewed. Each sprint starts with a sprint planning event in which a sprint goal is defined. Priorities for planned sprints are chosen out of the backlog. Each sprint ends with two events: [ 7 ] A sprint review (progress shown to stakeholders to elicit their feedback) A sprint retrospective (identifying lessons and improvements for the next sprints) The suggested maximum duration of sprint planning is eight hours for a four-week sprint. [ 13 ] Daily scrum [ edit ] Main article: Daily scrum meeting A daily scrum in the computing room Each day during a sprint, the developers hold a daily scrum (often conducted standing up ) with specific guidelines, and which may be facilitated by a scrum master. [ 10 ] [ 24 ] Daily scrum meetings are intended to be less than 15 minutes in length, taking place at the same time and location daily. The purpose of the meeting is to announce progress made towards the sprint goal and issues that may be hindering the goal, without going into any detailed discussion. Once over, individual members can go into a 'breakout session' or an 'after party' for extended discussion and collaboration. [ 25 ] Scrum masters are responsible for ensuring that team members use daily scrums effectively or, if team members are unable to use them, providing alternatives to achieve similar outcomes. [ 26 ] [ 27 ] Post-sprint events [ edit ] Conducted at the end of a sprint, a sprint review is a meeting that has a team share the work they've completed with stakeholders and liaise with them on feedback, expectations, and upcoming plans. At a sprint review completed deliverables are demonstrated to stakeholders. The recommended duration for a sprint review is one hour per week of sprint. [ 13 ] A sprint retrospective is a separate meeting that allows team members to internally analyze the strengths and weaknesses of the sprint, future areas of improvement, and continuous process improvement actions. [ 28 ] Backlog Refinement [ edit ] Backlog refinement (formerly known as \"grooming\") is a process by which team members revise and prioritize a backlog for future sprints. [ 29 ] It can be done as a separate stage done before the beginning of a new sprint or as a continuous process that team members work on by themselves. Backlog refinement can include the breaking down of large tasks into smaller and clearer ones, the clarification of success criteria, and the revision of changing priorities and returns. [ 30 ] Artifacts [ edit ] Artifacts are a means by which scrum teams manage product development by documenting work done towards the project. There are many kinds of scrum artifacts, with three of them being the most common: product backlog, sprint backlog, and increment. [ 31 ] Product backlog [ edit ] Main article: Product backlog The product backlog is a breakdown of work to be done and contains an ordered list of product requirements (such as features , bug fixes and non-functional requirements ) that the team maintains for a product . The order of a product backlog corresponds to the urgency of the task. Common formats for backlog items include user stories and use cases . [ 3 ] The product backlog may also contain the product owner's assessment of business value and the team's assessment of the product's effort or complexity, which can be stated in story points using the rounded Fibonacci scale . These estimates try to help the product owner gauge the timeline and may influence the ordering of product backlog items. [ 32 ] The product owner maintains and prioritizes product backlog items based on considerations such as risk, business value, dependencies, size, and timing. High-priority items at the top of the backlog are broken down into more detail for developers to work on, while tasks further down the backlog may be more vague. [ 10 ] Sprint backlog [ edit ] The sprint backlog is the subset of items from the product backlog intended for developers to address in a particular sprint. [ 33 ] Developers fill this backlog with tasks they deem appropriate to fill the sprint, using past performance to assess their capacity for each sprint. The scrum approach has tasks on the sprint backlog not assigned to developers by any particular individual or leader. Team members self organize by pulling work as needed according to the backlog priority and their own capabilities and capacity. [ 34 ] Increment [ edit ] An increment is a potentially releasable output of a sprint, which meets the sprint goal and the definition of done. It is formed from all the completed sprint backlog items, integrated with the work of all previous sprints. [ 3 ] Other artifacts [ edit ] Burndown chart [ edit ] A sample burndown chart for a completed sprint, showing remaining effort at the end of each day Main article: Burndown chart Often used in scrum, a burndown chart is a publicly displayed chart showing remaining work. [ 35 ] It provides quick visualizations for reference. The horizontal axis of the burndown chart shows the days remaining, while the vertical axis shows the amount of work remaining each day. During sprint planning, the ideal burndown chart is plotted. [ 36 ] Then, during the sprint, developers update the chart with the remaining work. Burnup chart [ edit ] A sample burnup chart for a release, showing scope completed each sprint (MVP = minimum viable product ) Main article: Burnup chart Updated at the end of each sprint, the release burn-up chart shows progress towards delivering a forecast scope. The horizontal axis of the release burnup chart shows the sprints in a release, while the vertical axis shows the amount of work completed at the end of each sprint. [ 37 ] [ 38 ] Velocity [ edit ] Main article: Velocity (software development) A team's total capability effort for a single sprint can be estimated by evaluating work completed in the last sprint. The collection of historical \" velocity \" data is a guideline for assisting the team in understanding their capacity. [ 39 ] Limitations [ edit ] Some have argued that scrum events, such as daily scrums and scrum reviews, hurt productivity and waste time that could be better spent on actual productive tasks. [ 40 ] [ 41 ] Scrum has also been observed to pose difficulties for part-time or geographically distant teams; those that have highly specialized members who would be better off working by themselves or in working cliques; and those that are unsuitable for incremental and development testing . [ 42 ] [ 43 ] Adaptations [ edit ] Scrum is frequently tailored or adapted in different contexts to achieve varying aims. [ 44 ] A common approach to adapting scrum is the combination of scrum with other software development methodologies, as scrum does not cover the whole product development lifecycle . [ 45 ] Various scrum practitioners have also suggested more detailed techniques for how to apply or adapt scrum to particular problems or organizations. Many refer to these techniques as 'patterns', an analogous use to design patterns in architecture and software. [ 46 ] [ 47 ] Scrumban [ edit ] Main article: Scrumban Scrumban is a software production model based on scrum and kanban . To illustrate each stage of work, teams working in the same space often use post-it notes or a large whiteboard. [ 48 ] Kanban models allow a team to visualize work stages and limitations. [ 49 ] Scrum of scrums [ edit ] Scrum of scrums is a technique to operate scrum at scale for multiple teams coordinating on the same product. Scrum-of-scrums daily scrum meetings involve ambassadors selected from each individual team, who may be either a developer or scrum master. As a tool for coordination, scrum of scrums allows teams to collectively work on team-wide risks, impediments, dependencies, and assumptions (RIDAs), which may be tracked in a backlog of their own. [ 50 ] [ 51 ] Large-scale scrum [ edit ] Large-scale scrum is an organizational system for product development that scales scrum with varied rules and guidelines, developed by Bas Vodde and Craig Larman . [ 52 ] [ 53 ] There are two levels to the framework: the first level, designed for up to eight teams; and the second level, known as 'LeSS Huge', which can accommodate development involving hundreds of developers. [ 54 ] Criticism [ edit ] A systematic review found \"that Distributed Scrum has no impact, positive or negative on overall project success\" in distributed software development. [ 55 ] Martin Fowler , one of the authors of the Manifesto for Agile Software Development , has criticized what he calls \"faux-agile\" practices that are \"disregarding Agile's values and principles\", [ 56 ] and \"the Agile Industrial Complex imposing methods upon people\" contrary to the Agile principle of valuing \"individuals and interactions over processes and tools\" [ 9 ] and allowing the individuals doing the work to decide how the work is done, changing processes to suit their needs. In September 2016, Ron Jeffries, a signatory to the Agile Manifesto , [ 9 ] described what he called \"Dark Scrum\", saying that \"Scrum can be very unsafe for programmers.\" [ 57 ] See also [ edit ] Agile software development Agile testing Agile learning Disciplined agile delivery Comparison of scrum software High-performance teams Lean software development Project management Unified process Citations [ edit ] ^ a b c Ken Schwaber ; Jeff Sutherland . \"The Scrum Guide\" (PDF) . Scrum.org . Retrieved June 15, 2023 . ^ \"What Is A Scrum Master? Everything You Need To Know \u2013 Forbes Advisor\" . www.forbes.com . December 27, 2021 . Retrieved November 16, 2023 . ^ a b c d Pete Deemer; Gabrielle Benefield; Craig Larman; Bas Vodde (December 17, 2012). \"The Scrum Primer: A Lightweight Guide to the Theory and Practice of Scrum (Version 2.0)\" . InfoQ. ^ J. Henry and S. Henry. Quantitative assessment of the software maintenance process and requirements volatility. In Proc. of the ACM Conference on Computer Science, pages 346\u2013351, 1993. ^ Takeuchi, Hirotaka; Nonaka, Ikujiro (January 1, 1986). \"The New New Product Development Game\" . Harvard Business Review . Retrieved June 9, 2010 . Moving the Scrum Downfield ^ The Knowledge Creating Company . Oxford University Press. 1995. p.\u00a03. ISBN 978-0-19-976233-0 . Retrieved March 12, 2013 . ^ a b Sutherland, Jeff (October 2004). \"Agile Development: Lessons learned from the first Scrum\" . Archived from the original (PDF) on June 30, 2014 . Retrieved September 26, 2008 . ^ Sutherland, Jeffrey Victor ; Schwaber, Ken (1995). Business object design and implementation: OOPSLA '95 workshop proceedings . The University of Michigan . p.\u00a0118. ISBN 978-3-540-76096-2 . ^ a b c \"Manifesto for Agile Software Development\" . Retrieved October 17, 2019 . ^ a b c d Schwaber, Ken (February 1, 2004). Agile Project Management with Scrum . Microsoft Press . ISBN 978-0-7356-1993-7 . ^ Maximini, Dominik (January 8, 2015). The Scrum Culture: Introducing Agile Methods in Organizations . Management for Professionals. Cham: Springer (published 2015). p.\u00a026. ISBN 978-3-319-11827-7 . Retrieved August 25, 2016 . Ken Schwaber and Jeff Sutherland presented Scrum for the first time at the OOPSLA conference in Austin, Texas, in 1995. [...] In 2001, the first book about Scrum was published. [...] One year later (2002), Ken founded the Scrum Alliance, aiming at providing worldwide Scrum training and certification. ^ \"Home\" . Scrum.org . Retrieved January 6, 2020 . ^ a b c d Sutherland, Jeff ; Schwaber, Ken (2013). \"Scrum Guides\" . ScrumGuides.org . Retrieved June 15, 2023 . ^ Morris, David (2017). Scrum: an ideal framework for agile projects . In Easy Steps. pp. 178\u2013 179. ISBN 978-1-84078-731-3 . OCLC 951453155 . ^ Cobb, Charles G. (2015). The Project Manager's Guide to Mastering Agile: Principles and Practices for an Adaptive Approach . Hoboken, NJ: John Wiley & Sons. p.\u00a037. ISBN 978-1-118-99104-6 . ^ Cohn, Mike (2010). Succeeding with Agile: Software Development Using Scrum . Upper Saddle River, NJ: Addison-Wesley. ISBN 978-0-321-57936-2 . ^ Rubin, Kenneth (2013), Essential Scrum. A Practical Guide to the Most Popular Agile Process , Addison-Wesley, p.\u00a0173, ISBN 978-0-13-704329-3 ^ a b McGreal, Don; Jocham, Ralph (June 4, 2018). The Professional Product Owner: Leveraging Scrum as a Competitive Advantage . Addison-Wesley Professional. ISBN 978-0-13-468665-3 . ^ Pichler, Roman (March 11, 2010). Agile Product Management with Scrum: Creating Products that Customers Love . Addison-Wesley Professional. ISBN 978-0-321-68413-4 . ^ Ambler, Scott. \"The Product Owner Role: A Stakeholder Proxy for Agile Teams\" . agilemodeling.com . Retrieved July 22, 2016 . [...] in practice there proves to be two critical aspects to this role: first as a stakeholder proxy within the development team and second as a project team representative to the overall stakeholder community as a whole. ^ \"The Scrum Guide\" (PDF) . Scrum.org. p.\u00a06 . Retrieved June 15, 2023 . ^ \"The Role of the Product Owner\" . Scrum Alliance . Retrieved May 26, 2018 . ^ Rad, Nader K.; Turley, Frank (2018). Agile Scrum Foundation Courseware, Second Edition . 's-Hertogenbosch, Netherlands: Van Haren. p.\u00a026. ISBN 978-94-018-0279-6 . ^ \"What is a Daily Scrum?\" . Scrum.org . Retrieved January 6, 2020 . ^ Flewelling, Paul (2018). The Agile Developer's Handbook: Get more value from your software development: get the best out of the Agile methodology . Birmingham, UK: Packt Publishing Ltd. p.\u00a091. ISBN 978-1-78728-020-5 . ^ McKenna, Dave (2016). The Art of Scrum: How Scrum Masters Bind Dev Teams and Unleash Agility . Aliquippa, PA: CA Press. p.\u00a0126. ISBN 978-1-4842-2276-8 . ^ Drongelen, Mike van; Dennis, Adam; Garabedian, Richard; Gonzalez, Alberto; Krishnaswamy, Aravind (2017). Lean Mobile App Development: Apply Lean startup methodologies to develop successful iOS and Android apps . Birmingham, UK: Packt Publishing Ltd. p.\u00a043. ISBN 978-1-78646-704-1 . ^ Rubin, Kenneth (2012), Essential Scrum. A Practical Guide to the Most Popular Agile Process , Addison-Wesley (published 2013), p.\u00a0375, ISBN 978-0-13-704329-3 ^ Project Management Institute 2021 , Glossary \u00a73 Definitions. ^ Scrum.org. \"Product Backlog Refinement\" . scrum.org . Scrum.org . Retrieved December 17, 2025 . The activity of continually improving PBIs until they are ready to be worked on is called \"refinement.\" ^ \"What are Scrum Artifacts? | The Ultimate Guide | Miro\" . miro.com/ . Retrieved November 29, 2024 . ^ Higgins, Tony (March 31, 2009). \"Authoring Requirements in an Agile World\" . BA Times. ^ Russ J. Martinelli; Dragan Z. Milosevic (January 5, 2016). Project Management ToolBox: Tools and Techniques for the Practicing Project Manager . Wiley. p.\u00a0304. ISBN 978-1-118-97320-2 . ^ Ken Schwaber ; Jeff Sutherland . \"The Scrum Guide\" (PDF) . Scrum.org . Retrieved May 25, 2018 . ^ Charles G. Cobb (January 27, 2015). The Project Manager's Guide to Mastering Agile: Principles and Practices for an Adaptive Approach . John Wiley & Sons. p.\u00a0378. ISBN 978-1-118-99104-6 . ^ \"Agile 101 \u2013 Sprint Planning\" . Somar Digital . Retrieved July 9, 2025 . ^ Arafeen, Junaid; Bose, Saugata (September 2009). \"Improving Software Development Using Scrum Model by Analyzing Up and Down Movements on The Sprint Burn Down Chart: Proposition for Better Alternatives\" . International Journal of Digital Content Technology and its Applications . 3 (3) \u2013 via CiteSeerX. ^ \"What is a burn up chart and how to create one\" . Atlassian . Retrieved December 17, 2025 . ^ \"Sprint Velocity in Scrum: How to Measure and Improve Performance\" . Atlassian . Retrieved December 17, 2025 . ^ Jenson, John (March 8, 2019). \"Meetings: The productivity killer for developers\" . TandemSeven \u2013 The Experience Innovation Company . Archived from the original on June 5, 2020 . Retrieved June 5, 2020 . ^ \"Not all developers like agile, and here are 5 reasons why\" . Business Matters . December 4, 2019 . Retrieved June 5, 2020 . ^ Turk, Dan; France, Robert; Rumpe, Bernhard (2014) [2002]. \"Limitations of Agile Software Processes\". Proceedings of the Third International Conference on Extreme Programming and Flexible Processes in Software Engineering : 43\u2013 46. arXiv : 1409.6600 . ^ \"Issues and Challenges in Scrum Implementation\" (PDF) . International Journal of Scientific & Engineering Research . 3 (8). August 2012 . Retrieved December 10, 2015 . ^ Hron, Michal; Obwegeser, Nikolaus (January 1, 2022). \"Why and how is Scrum being adapted in practice: A systematic review\" . Journal of Systems and Software . 183 111110. doi : 10.1016/j.jss.2021.111110 . ISSN 0164-1212 . S2CID 240950847 . ^ Hron, M.; Obwegeser, N. (January 2018). \"Scrum in practice: an overview of Scrum adaptations\" (PDF) . Proceedings of the 2018 51st Hawaii International Conference on System Sciences (HICSS), January 3\u20136, 2018 . [ dead link ] ^ Bj\u00f8rnvig, Gertrud; Coplien, Jim (June 21, 2008). \"Scrum as Organizational Patterns\" . Gertrude & Cope. ^ \"Scrum Pattern Community\" . ScrumPLoP.org . Retrieved July 22, 2016 . ^ Ladas, Corey (October 27, 2007). \"scrum-ban\" . Lean Software Engineering. Archived from the original on August 23, 2018 . Retrieved September 13, 2012 . ^ Kniberg, Henrik; Skarin, Mattias (December 21, 2009). \"Kanban and Scrum \u2013 Making the most of both\" (PDF) . InfoQ . Retrieved July 22, 2016 . ^ \"Risk Management \u2013 How to Stop Risks from Screwing Up Your Projects!\" . Kelly Waters. Archived from the original on January 6, 2015 . Retrieved January 6, 2015 . ^ \"Scrum of Scrums\" . Agile Alliance. December 17, 2015. Archived from the original on February 9, 2014 . Retrieved December 17, 2013 . ^ \"Large-Scale Scrum (LeSS)\" . 2014. ^ Grgic (2015). \"Descaling organisation with LeSS (Blog)\" . ^ Larman, Craig; Bas Vodde (May\u2013June 2013). \"Scaling Agile Development\" (PDF) . Crosstalk . ^ Santos, Ronnie de Souza; Ralph, Paul; Arshad, Arham; Stol, Klaas-Jan (October 5, 2023). \"Distributed Scrum: A Case Meta-Analysis\" . ACM Computing Surveys . 56 (4): 1\u2013 37. doi : 10.1145/3626519 . S2CID 263672588 . ^ Fowler, Martin (August 25, 2018). \"The State of Agile Software in 2018\" . martinfowler.com . Archived from the original on September 14, 2023 . Retrieved September 14, 2023 . ^ Jeffries, Ron (September 8, 2016). \"Dark Scrum\" . ronjeffries.com . Retrieved May 6, 2024 . General and cited references [ edit ] Deemer, Pete; Benefield, Gabrielle; Larman, Craig; Vodde, Bas (2009). \"The Scrum Primer\" . Retrieved June 1, 2009 . Janoff, N. S.; Rising, L. (2000). \"The Scrum Software Development Process for Small Teams\" (PDF) . Archived from the original (PDF) on November 6, 2015 . Retrieved February 26, 2015 . M\u00fcnch, J\u00fcrgen; Armbrust, Ove; Soto, Mart\u00edn; Kowalczyk, Martin (2012). Software Process Definition and Management . Springer. ISBN 978-3-642-24291-5 . A guide to the project management body of knowledge (PMBOK guide) (7th\u00a0ed.). Newtown Square, PA: Project Management Institute. 2021. ISBN 978-1-62825-664-2 . Rubin, Kenneth (2013). Essential Scrum: A Practical Guide to the Most Popular Agile Process . Addison-Wesley. p.\u00a0173. ISBN 978-0-13-704329-3 . Vacaniti, Daniel (February 2018). \"The Kanban Guide for Scrum Teams\" (PDF) . scrum.org . Retrieved March 12, 2018 . Verheyen, Gunther (2013). Scrum \u2013 A Pocket Guide (A Smart Travel Companion) . ISBN 978-90-8753-720-3 . External links [ edit ] Wikimedia Commons has media related to Scrum (development) . English Wikisource has original text related to this article: The Scrum Guide Agile Alliance's Scrum library A scrum process description by the Eclipse process framework (EPF) project v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Authority control databases National United States Israel Other Yale LUX Retrieved from \" https://en.wikipedia.org/w/index.php?title=Scrum_(project_management)&oldid=1328084768 \" Categories : Agile software development Software development Software development philosophies Software project management Hidden categories: All articles with dead external links Articles with dead external links from November 2025 Articles with short description Short description is different from Wikidata Articles lacking reliable references from May 2020 All articles lacking reliable references Use American English from July 2023 All Wikipedia articles written in American English Use mdy dates from February 2022 Commons category link is on Wikidata Wikisource templates with missing id Articles prone to spam from May 2015 This page was last edited on 17 December 2025, at 19:57 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Scrum (project management) 38 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Rational_unified_process",
    "title": "Rational unified process - Wikipedia",
    "content": "Rational unified process - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Rational unified process topics Toggle Rational unified process topics subsection 2.1 RUP building blocks 2.2 Four project life-cycle phases 2.2.1 Inception phase 2.2.2 Elaboration phase 2.2.3 Construction phase 2.2.4 Transition phase 2.3 The IBM Rational Method Composer product 2.4 Certification 2.5 Six best practices 3 See also 4 References 5 Further reading 6 External links Toggle the table of contents Rational unified process 24 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 \u010ce\u0161tina Deutsch Espa\u00f1ol Esperanto \u0641\u0627\u0631\u0633\u06cc \ud55c\uad6d\uc5b4 Bahasa Indonesia Italiano Lietuvi\u0173 Magyar Bahasa Melayu Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Sloven\u010dina Suomi Svenska \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Process by which software is developed Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e The Rational Unified Process ( RUP ) is an iterative software development process framework created by the Rational Software Corporation, a division of IBM since 2003. [ 1 ] RUP is not a single concrete prescriptive process, but rather an adaptable process framework , intended to be tailored by the development organizations and software project teams that will select the elements of the process that are appropriate for their needs. RUP is a specific implementation of the Unified Process . History [ edit ] Rational Software originally developed the RUP as a software process product. The product includes a hyperlinked knowledge-base with sample artifacts and detailed descriptions for many different types of activities. RUP is included in the Rational Method Composer (RMC) product which allows customization of the process. Philippe Kruchten , an experienced Rational technical representative was tasked with heading up the original RUP team. These initial versions combined the Rational Software organisation's extensive field experience building object-oriented systems (referred to by Rational field staff as the Rational Approach) with Objectory's guidance on practices such as use cases, and incorporated extensive content from Jim Rumbaugh's Object Modeling Technology (OMT) approach to modeling, Grady Booch's Booch method , and the newly released UML 0.8. [ 2 ] [ 3 ] To help make this growing knowledge base more accessible, Philippe Kruchten was tasked with the assembly of an explicit process framework for modern software engineering. This effort employed the HTML -based process delivery mechanism developed by Objectory. The resulting \"Rational Unified Process\" (RUP) completed a strategic tripod for Rational: a tailorable process that guided development tools that automated the application of that process services that accelerated adoption of both the process and the tools. This guidance was augmented in subsequent versions with knowledge based on the experience of companies that Rational had acquired. In 1997, a requirements and test discipline were added to the approach, much of the additional material sourced from the Requirements College method developed by Dean Leffingwell et al. at Requisite, Inc., and the SQA Process method developed at SQA Inc., both companies having been acquired by Rational Software. In 1998 Rational Software added two new disciplines: business modeling, much of this content had already been in the Objectory Process a Configuration and Change Management discipline, sourced through the acquisition of Pure Atria  Corporation. These additions lead to an overarching set of principles that were defined by Rational and articulated within RUP as the six best practices for modern software engineering: Develop iteratively, with risk as the primary iteration driver [ 4 ] Manage requirements Employ a component-based architecture Model software visually Continuously verify quality Control changes These best practices were tightly aligned with Rational's product line, and both drove the ongoing development of Rational's products, as well as being used by Rational's field teams to help customers improve the quality and predictability of their software development efforts. Additional techniques including performance testing, UI Design, data engineering were included, and an update to reflect changes in UML 1.1. In 1999, a project management discipline was introduced, as well as techniques to support real-time software development and updates to reflect UML 1.3. Besides, the first book to describe the process, The Unified Software Development Process ( ISBN 0-201-57169-2 ) by Ivar Jacobson , Grady Booch and James Rumbaugh ., was published in the same year. Between 2000 and 2003, a number of changes introduced guidance from ongoing Rational field experience with iterative development, in addition to tool support for enacting RUP instances and for customization of the RUP framework. These changes included: the introduction of concepts and techniques from approaches such as eXtreme Programming (XP), that would later come to be known collectively as agile methods. This included techniques such as pair programming, test-first design, and papers that explained how RUP enabled XP to scale for use on larger projects. a complete overhaul of the testing discipline to better reflect how testing work was conducted in different iterative development contexts. the introduction of supporting guidance - known as \"tool mentors\" - for enacting the RUP practices in various tools. These essentially provided step-by-step method support to Rational tool users. automating the customization of RUP in a way that would allow customers to select parts from the RUP process framework, customize their selection with their own additions, and still incorporate improvements in subsequent releases from Rational. IBM acquired Rational Software in February 2003. In 2006, IBM created a subset of RUP tailored for the delivery of Agile projects - released as an OpenSource method called OpenUP through the Eclipse web-site. [ 5 ] Rational unified process topics [ edit ] RUP building blocks [ edit ] RUP is based on a set of building blocks and content elements, describing what is to be produced, the necessary skills required and the step-by-step explanation describing how specific development goals are to be achieved. The main building blocks, or content elements, are the following: Roles (who) \u2013 A role defines a set of related skills, competencies and responsibilities. Work products (what) \u2013 A work product represents something resulting from a task, including all the documents and models produced while working through the process. Tasks (how) \u2013 A task describes a unit of work assigned to a Role that provides a meaningful result. Within each iteration, the tasks are categorized into nine disciplines: Six \"engineering disciplines\" Business modelling Requirements Analysis and design Implementation Test Deployment Three supporting disciplines Configuration and change management Project management Environment Four project life-cycle phases [ edit ] RUP phases and disciplines. The RUP has determined a project life-cycle consisting of four phases. These phases allow the process to be presented at a high level in a similar way to how a 'waterfall'-styled project might be presented, although in essence the key to the process lies in the iterations of development that lie within all of the phases. Also, each phase has one key objective and milestone at the end that denotes the objective being accomplished. The visualization of RUP phases and disciplines over time is referred to as the RUP hump chart. Inception phase [ edit ] The primary objective is to scope the system adequately as a basis for validating initial costing and budgets.\nIn this phase the business case which includes business context, success factors (expected revenue, market recognition, etc.), and financial forecast is established. To complement the business case, a basic use case model, project plan, initial risk assessment and project description (the core project requirements, constraints and key features) are generated.\nAfter these are completed, the project is checked against the following criteria: Stakeholder concurrence on scope definition and cost/schedule estimates. Requirements understanding as evidenced by the fidelity of the primary use cases. Credibility of the cost/schedule estimates, priorities, risks, and development process. Depth and breadth of any architectural prototype that was developed. Establishing a baseline by which to compare actual expenditures versus planned expenditures. If the project does not pass this milestone, called the life cycle objective milestone, it either can be cancelled or repeated after being redesigned to better meet the criteria. Elaboration phase [ edit ] The primary objective is to mitigate the key risk items identified by analysis up to the end of this phase.\nThe elaboration phase is where the project starts to take shape. In this phase the problem domain analysis is made and the architecture of the project gets its basic form. The outcome of the elaboration phase is: A use-case model in which the use-cases and the actors have been identified and most of the use-case descriptions are developed. The use-case model should be 80% complete. A description of the software architecture in a software system development process. An executable architecture that realizes architecturally significant use cases. Business case and risk list which are revised. A development plan for the overall project. Prototypes that demonstrably mitigate each identified technical risk. A preliminary user manual (optional) This phase must pass the lifecycle architecture milestone criteria answering the following questions: Is the vision of the product stable? Is the architecture stable? Does the executable demonstration indicate that major risk elements are addressed and resolved? Is the construction phase plan sufficiently detailed and accurate? Do all stakeholders agree that the current vision can be achieved using current plan in the context of the current architecture? Is the actual vs. planned resource expenditure acceptable? If the project cannot pass this milestone, there is still time for it to be canceled or redesigned. However, after leaving this phase, the project transitions into a high-risk operation where changes are much more difficult and detrimental when made. The key domain analysis for the elaboration is the system architecture. Construction phase [ edit ] The primary objective is to build the software system.\nIn this phase, the main focus is on the development of components and other features of the system. This is the phase when the bulk of the coding takes place. In larger projects, several construction iterations may be developed in an effort to divide the use cases into manageable segments to produce demonstrable prototypes. Transition phase [ edit ] The primary objective is to 'transit' the system from development into production, making it available to and understood by the end user.\nThe activities of this phase include training the end users and maintainers and beta testing the system to validate it against the end users' expectations. The system also goes through an evaluation phase, any developer which is not producing the required work is replaced or removed. The product is also checked against the quality level set in the Inception phase. If all objectives are met, the product release milestone is reached and the development cycle is finished. The IBM Rational Method Composer product [ edit ] The IBM Rational Method Composer product is a tool for authoring, configuring, viewing, and publishing processes. See IBM Rational Method Composer and an open source version Eclipse process framework (EPF) project for more details. Certification [ edit ] In January 2007 the new RUP certification examination for IBM Certified Solution Designer - Rational Unified Process 7.0 was released which replaces the previous version of the course called IBM Rational Certified Specialist - Rational Unified Process . [ 6 ] The new examination will not only test knowledge related to the RUP content but also to the process structure elements. [ 7 ] To pass the new RUP certification examination, a person must take IBM's Test 839: Rational Unified Process v7.0 . You are given 75 minutes to take the 52 question exam. The passing score is 62%. [ 8 ] Six best practices [ edit ] Six best software engineering practices are defined for software projects to minimize faults and increase productivity. These are: [ 9 ] [ 10 ] Develop iteratively It is best to know all requirements in advance; however, often this is not the case. Several software development processes exist that deal with providing solutions to minimize cost in terms of development phases. Manage requirements Always keep in mind the requirements set by users. Use components Breaking down an advanced project is not only suggested but in fact unavoidable. This promotes ability to test individual components before they are integrated into a larger system. Also, code reuse is a big plus and can be accomplished more easily through the use of object-oriented programming . Model visually Use diagrams to represent all major components, users, and their interaction. \"UML\", short for Unified Modeling Language , is one tool that can be used to make this task more feasible. Verify quality Always make testing a major part of the project at any point of time. Testing becomes heavier as the project progresses but should be a constant factor in any software product creation. Control changes Many projects are created by many teams, sometimes in various locations, different platforms may be used, etc. As a result, it is essential to make sure that changes made to a system are synchronized and verified constantly. (See Continuous integration ). See also [ edit ] Agile modeling Agile unified process Disciplined agile delivery Dynamic systems development method Computer programming Feature-driven development Macroscope (methodology suite) Project life cycle Quality assurance Quality control Scaled agile framework Software architecture Software component Software development process Software engineering Software testing Test-driven development Unified Process for Education References [ edit ] ^ IBM Acquires Rational ^ Jacobson, Sten (2002-07-19). \"The Rational Objectory Process - A UML-based Software Engineering Process\" . Rational Software Scandinavia AB . Archived from the original on 2019-05-27 . Retrieved 2014-12-17 . ^ Kruchten, Philippe (2004-05-01). The Rational Unified Process: An Introduction . Addison-Wesley . p.\u00a033. ISBN 9780321197702 . Retrieved 2014-12-17 . ^ Aked, Mark (2003-11-25). \"RUP in brief\" . IBM . Retrieved 2011-07-12 . ^ \"OpenUP\" . Archived from the original on 2014-01-06 . Retrieved 2013-08-03 . ^ Krebs, Jochen (2007-01-15). \"The value of RUP certification\" . IBM . Retrieved 2014-05-05 . ^ \"Spacer IBM Certified Solution Designer - IBM Rational Unified Process V7.0\" . IBM . Archived from the original on January 8, 2007 . Retrieved 2008-05-13 . ^ \"Test 839: Rational Unified Process v7.0\" . IBM . Retrieved 2008-05-13 . [ permanent dead link ] ^ Stephen Schach (2004). Classical and Object-Oriented Software Engineering . 6/e, WCB McGraw Hill, New York, 2004. ^ Rational Unified Process white paper Archived 2009-05-01 at the Wayback Machine Further reading [ edit ] Ivar Jacobson , Grady Booch , and James Rumbaugh (1999). The Unified Software Development Process Gary Pollice, Liz Augustine, Chris Lowe, and Jas Madhur (2003). Software Development for Small Teams: A RUP-Centric Approach Per Kroll, Philippe Kruchten (2003). Rational Unified Process Made Easy, The: A Practitioner's Guide to the RUP Per Kroll, Bruce Mac Isaac (2006). Agility and Discipline Made Easy: Practices from OpenUP and RUP Philippe Kruchten (1998). The Rational Unified Process: An Introduction Ahmad Shuja, Jochen Krebs (2007). RUP Reference and Certification Guide Walker Royce, Software Project Management, A Unified Framework Paul Szymkowiak, Philippe Kruchten (2003). Testing: The RUP Philosophy [ 1 ] External links [ edit ] IBM Rational Unified Process Web Site v t e Unified Modeling Language Actors Organizations Object Management Group UML Partners Persons Grady Booch Ivar Jacobson James Rumbaugh Concepts Object oriented Object-oriented programming Object-oriented analysis and design Object-oriented modeling Structure Actor Attribute Artifact Class Component Interface Object Package Profile diagram Behavior Activity Event Message Method State Use case Relationships Association Composition Dependency Generalization (or Inheritance ) Extensibility Profile Stereotype Other Multiplicity Diagrams Structure Class Component Composite structure Deployment Object Package Behaviour Activity State Machine Use case Interaction Communications Sequence Interaction overview Timing Derived languages Systems Modeling Language (SysML) UML eXchange Format (UXF) XML Metadata Interchange (XMI) Executable UML (xUML) Other topics Glossary of UML terms Rational Unified Process List of Unified Modeling Language tools Object Modeling in Color Authority control databases GND ^ Szymkowiak, Paul; Kruchten, Philippe (February 2003). \"Testing: The RUP Philosophy\" . Academia.Edu . Rational Software (Rational Edge e-zine). p.\u00a011 . Retrieved 2022-10-13 . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Rational_unified_process&oldid=1303088770 \" Categories : Formal methods Rational Software software Software project management Hidden categories: All articles with dead external links Articles with dead external links from July 2022 Articles with permanently dead external links Webarchive template wayback links Articles with short description Short description matches Wikidata This page was last edited on 29 July 2025, at 01:55 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Rational unified process 24 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Scaled_agile_framework",
    "title": "Scaled agile framework - Wikipedia",
    "content": "Scaled agile framework - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Challenges of scaling agile principles and practices Toggle Challenges of scaling agile principles and practices subsection 1.1 Coping with longer planning horizons 1.2 Keeping agile at abstract levels of responsibility 1.3 Dealing with delegated authority 1.4 Synchronizing deliverables 1.5 Allowing time for innovation and planning 2 Implementation Toggle Implementation subsection 2.1 Underlying principles of SAFe 2.2 The SAFe framework 2.3 Certifications 3 See also 4 References 5 Further reading 6 External links Toggle the table of contents Scaled agile framework 4 languages Deutsch Fran\u00e7ais \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Set of workflow practices The scaled agile framework ( SAFe ) is a set of organization and workflow patterns intended to guide enterprises in scaling lean and agile practices. [ 1 ] [ 2 ] Along with disciplined agile delivery (DAD) and S@S (Scrum@Scale), SAFe is one of a growing number of frameworks that seek to address the problems encountered when scaling beyond a single team. [ 3 ] [ 4 ] SAFe promotes alignment, collaboration, and delivery across large numbers of agile teams. It was developed by and for practitioners, by leveraging three primary bodies of knowledge: agile software development , lean product development , and systems thinking . [ 5 ] The primary reference for the scaled agile framework was originally the development of a big picture view of how work flowed from product management (or other stakeholders ), through governance , program , and development teams , out to customers . [ 6 ] [ 7 ] With the collaboration of others in the agile community, this was progressively refined and then first formally described in a 2007 book. [ 8 ] The framework continues to be developed and shared publicly; with an academy and an accreditation scheme supporting those who seek to implement, support, or train others in the adoption of SAFe. Starting at its first release in 2011, six major versions have been released [ 9 ] while the latest edition, version 6.0, was released in March 2023. [ 10 ] While SAFe continues to be recognised as the most common approach to scaling agile practices (at 30 percent and growing), [ 11 ] [ 12 ] [ page\u00a0needed ] , [ 13 ] it also has received criticism for being too hierarchical and inflexible. [ 14 ] It also receives criticism for giving organizations the illusion of adopting Agile , while keeping familiar processes intact. [ 15 ] Challenges of scaling agile principles and practices [ edit ] Coping with longer planning horizons [ edit ] Development teams typically refine their backlog up to two to three iterations ahead, but in larger organizations the product marketing team needs to plan further ahead for their commitments to market and discussions with customers. [ 16 ] They will often work with a very high level, 12 to 18-month roadmap, then plan collaboratively with the teams for three months of work. [ citation needed ] The development teams will still get into detailed refinement 2\u20133 iterations ahead, only getting into detailed task plans for the next iteration. [ citation needed ] Keeping agile at abstract levels of responsibility [ edit ] While development teams have a number of frameworks that define how they should be agile, there is very little that describes this for management. SAFe delivers many of the same principles, such as cross-functional teams, to the groups that handle the more abstract levels of responsibility and planning (product and portfolio). [ citation needed ] Dealing with delegated authority [ edit ] In Scrum , the product owner is expected  to assume responsibility for the full product life-cycle , including the return on investment of development decisions, as well as performance in market. On large-scale developments, the organization wants a view across multiple team backlogs, such as provided by a product manager . [ 17 ] Although SAFe assumes the product owner role sits with product management, it has nonetheless been criticized for separating product owners into the development organization. [ 18 ] Synchronizing deliverables [ edit ] Agile frameworks are designed to enable the development team to be autonomous and free to design how they work. SAFe acknowledges that, at the scale of many tens or hundreds of development teams, it becomes increasingly chaotic for teams to fully self-organize. [ 19 ] It therefore puts some constraints on this, so that where teams are working on the same product, their deliverables can be better synchronized for releasing together, although this has been one area in which SAFe has been criticized. [ 17 ] [ 18 ] Allowing time for innovation and planning [ edit ] This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Scaled agile framework\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( September 2022 ) ( Learn how and when to remove this message ) The SAFe planning cycle recommends including an additional iteration after a release, allowing teams to improve their practices and are ready for the next planning increment. Earlier editions of SAFe also designed this to be a hardening iteration, namely to stabilize or harden the product before releasing it. This was predicated on the complications of working with large integration environments where dependencies prevented several matters from being tested until the very end. SAFe was criticized for this because it represented an anti-agile or waterfall element, but was in line with lean 90-day increments which make 13 weeks, and if doing two-week sprints you need six of them plus a one-week planning or hardening cycle. [ 20 ] This is not included in recent editions of SAFe. Implementation [ edit ] This section may rely excessively on sources too closely associated with the subject , potentially preventing the article from being verifiable and neutral . Please help improve it by replacing them with more appropriate citations to reliable, independent sources . ( July 2018 ) ( Learn how and when to remove this message ) Underlying principles of SAFe [ edit ] According to its authors, SAFe is based upon ten underlying concepts, which are derived from existing lean and agile principles, as well as observation: [ 21 ] Take an economic view Apply systems thinking Assume variability; preserve options Build incrementally with fast integrated learning cycles Base milestones on objective evaluation of working systems Visualize and limit work-in-progress, reduce batch sizes, and manage queue lengths Apply cadence (timing), synchronize with cross-domain planning Unlock the intrinsic motivation of knowledge workers Decentralize decision-making Organize around value SAFe has been criticized for aggregating too many disparate practices. [ 22 ] The SAFe framework [ edit ] In SAFe version 5.1, there are four configurations: essential, portfolio, large solution and full: [ 23 ] Essential SAFe is the most basic configuration. It describes the most critical elements needed and is intended to provide the majority of the framework's benefits. It includes the team and program level (which it calls agile release trains or ARTs). Large Solution SAFe allows for coordination and synchronization across multiple programs, but without the portfolio considerations. In earlier versions of SAFe, this level was referred to as value stream . Portfolio SAFe includes concerns for strategic direction, investment funding, and lean governance. Full SAFe combines the other three levels. Certifications [ edit ] Scaled Agile provides certifications that cover different areas and knowledge levels. [ 24 ] See also [ edit ] Scrum of scrums References [ edit ] ^ Hayes, Will; Lapham, Mary Ann; Miller, Suzanne; Wrubel, Eileen; Capell, Peter (2016). Scaling Agile Methods for Department of Defense Programs . Software Engineering Institute. CMU/SEI-2016-TN-005. ^ Athrow, Desiree (29 January 2015). \"Why Continuous Delivery is key to speeding up software development\" . TechRadar . Retrieved 2017-11-27 . ^ Linders, Ben (January 22, 2015). \"Scaling Agile with the Disciplined Agile Delivery Framework\" . InfoQ . Retrieved 2017-11-27 . ^ van Haaster, K (2014). Agile in-the-large: Getting from Paradox to Paradigm . Unpublished paper from Charles Sturt University. ^ King, Michael (2017). \"Serving Federal Customers with SAFe Concepts\" (PDF) . Capability Counts Conference Proceedings . Archived from the original (PDF) on October 3, 2017. ^ Bridgwater, Adrian (August 7, 2013). \"Real Agile Means Everybody Is Agile\" . Dr. Dobb's . Retrieved 2017-11-27 . ^ Linders, Ben (August 28, 2014). \"Death by Planning in Agile Adoption\" . InfoQ . Retrieved 2017-11-27 . ^ Leffingwell, Dean (2007). Scaling Software Agility: Best Practices for Large Enterprises . Addison-Wesley. ISBN 978-0321458193 . ^ \"About Scaled Agile Framework - A Brief History of SAFe\" . Scaled Agile Inc . Retrieved 12 August 2020 . ^ \"Say Hello to SAFE 6.0\" . Scaled Agile Inc. 15 March 2023 . Retrieved 2023-03-16 . ^ \"13th Annual State of Agile Report\" . State of Agile Survey . CollabNet VersionOne. 2019 . Retrieved 2019-08-27 . ^ Link, P; Lewrick, M (29 September 2014). \"Agile Methods in a New Area of Innovation Management\" (PDF) . Science to Business Marketing Conference . ^ Baptista, Roberto (28 January 2015). \"Profissionais brasileiros e o interesse por treinamentos de especializa\u00e7\u00e3o\" . Computerworld Brazil . Retrieved 28 January 2015 . ^ Schwaber, Ken (2013-08-06). \"unSAFe at any speed\" . Telling It Like It Is . Retrieved 2017-11-11 . ^ Gothelf, Jeff (2021-10-05). \"SAFe is not Agile\" . Retrieved 2023-05-21 . ^ Eklund, U; Olsson, H; Str\u00f8m, N (2014). Industrial challenges of scaling agile in mass-produced embedded systems . Springer International Publishing. ISBN 9783319143583 . {{ cite book }} : |work= ignored ( help ) ^ a b Vaidya, A (2014). Does DAD Know Best, Is it Better to do LeSS or Just be SAFe? Adapting Scaling Agile Practices into the Enterprise . Excerpt from PNSQC 2014 Proceedings. pp. 8\u2013 9. ^ a b Maximini, Dominik (11 September 2013). \"A critical view on SAFe - Scrumorakel - Blog\" . Scrum Oracle . Retrieved 2017-11-27 . ^ Stafford, Jan (December 9, 2013). \"Scaling Agile development calls for defined practices, consultant says\" . SearchSoftwareQuality . Retrieved 2017-11-27 . ^ Killick, Neil (21 March 2012). \"The Horror Of The Scaled Agile Framework\" . Agile, Scrum, Kanban, Lean, and everything that's in between . Retrieved 2017-11-27 . ^ \"SAFe Lean-Agile Principles\" . Retrieved 19 February 2016 . ^ Elssamadisy, Amr. \"Has SAFe Cracked the Large Agile Adoption Nut?\" . InfoQ . Retrieved 2017-11-11 . ^ Rose, Doug (2018). Enterprise Agility For Dummies . John Wiley & Sons. pp. 87\u2013 89. ISBN 9781119446095 . ^ \"Certification\" . Scaled Agile . Retrieved 19 February 2016 . Further reading [ edit ] Dings\u00f8yr, Torgeir; Falessi, David; Power, Ken (February 2019), \"Agile Development at Scale: The Next Frontier\", IEEE Software , 36 (2): 30\u2013 38, arXiv : 1901.00324 , doi : 10.1109/MS.2018.2884884 , S2CID 57373760 Heusser, Matthew (17 June 2015), Introducing the scaled agile framework , CIO , pp. 1\u2013 2 \u2014 contains a review of the pros and cons of the methodology and concludes it is a half-way-house to a fully agile system. Leffingwell, Dean (2011), Lean Requirements Practices for Teams, Programs, and the Enterprise , Addison-Wesley Professional, ISBN 978-0321635846 Linders, Ben (15 January 2015), Lean and Agile Leadership with the Scaled Agile Framework (SAFe) , InfoQ External links [ edit ] Official website Retrieved from \" https://en.wikipedia.org/w/index.php?title=Scaled_agile_framework&oldid=1291774960 \" Categories : Agile software development Software project management Software development philosophies Management frameworks Hidden categories: CS1 errors: periodical ignored Articles with short description Short description is different from Wikidata Wikipedia articles needing page number citations from April 2019 All articles with unsourced statements Articles with unsourced statements from September 2022 Articles needing additional references from September 2022 All articles needing additional references Articles lacking reliable references from July 2018 All articles lacking reliable references Official website different in Wikidata and Wikipedia This page was last edited on 23 May 2025, at 09:43 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Scaled agile framework 4 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Rapid_application_development",
    "title": "Rapid application development - Wikipedia",
    "content": "Rapid application development - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 James Martin approach 3 Advantages 4 Disadvantages 5 See also 6 References 7 Further reading 8 External links Toggle the table of contents Rapid application development 22 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 \u010ce\u0161tina Deutsch Espa\u00f1ol Euskara \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Bahasa Indonesia Italiano Magyar Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Suomi \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Concept of software development \"RAD tool\" and \"Rapid Application Development Tool\" redirect here. For development focused on making graphical user interfaces, see graphical user interface builder . Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Rapid application development ( RAD ), also called rapid application building ( RAB ), is both a general term for adaptive software development approaches, and the name for James Martin 's method of rapid development. In general, RAD approaches to software development put less emphasis on planning and more emphasis on an adaptive process. Prototypes are often used in addition to or sometimes even instead of design specifications. RAD is especially well suited for (although not limited to) developing software that is driven by user interface requirements . Graphical user interface builders are often called rapid application development tools. Other approaches to rapid development include the adaptive , agile , spiral , and unified models. History [ edit ] Rapid application development was a response to plan-driven waterfall processes, developed in the 1970s and 1980s, such as the Structured Systems Analysis and Design Method (SSADM). One of the problems with these methods is that they were based on a traditional engineering model used to design and build things like bridges and buildings. Software is an inherently different kind of artifact. Software can radically change the entire process used to solve a problem. As a result, knowledge gained from the development process itself can feed back to the requirements and design of the solution. [ 1 ] Plan-driven approaches attempt to rigidly define the requirements, the solution, and the plan to implement it, and have a process that discourages changes. RAD approaches, on the other hand, recognize that software development is a knowledge intensive process and provide flexible processes that help take advantage of knowledge gained during the project to improve or adapt the solution. The first such RAD alternative was developed by Barry Boehm and was known as the spiral model . Boehm and other subsequent RAD approaches emphasized developing prototypes as well as or instead of rigorous design specifications. Prototypes had several advantages over traditional specifications: Risk reduction. A prototype could test some of the most difficult potential parts of the system early on in the life-cycle . This can provide valuable information as to the feasibility of a design and can prevent the team from pursuing solutions that turn out to be too complex or time-consuming to implement. This benefit of finding problems earlier in the life-cycle rather than later was a key benefit of the RAD approach. The earlier a problem can be found the cheaper it is to address. Users are better at using and reacting than at creating specifications. In the waterfall model it was common for a user to sign off on a set of requirements but then when presented with an implemented system to suddenly realize that a given design lacked some critical features or was too complex. In general most users give much more useful feedback when they can experience a prototype of the running system rather than abstractly define what that system should be. Prototypes can be usable and can evolve into the completed product. One approach used in some RAD methods was to build the system as a series of prototypes that evolve from minimal functionality to moderately useful to the final completed system. The advantage of this besides the two advantages above was that the users could get useful business functionality much earlier in the process. [ 2 ] Starting with the ideas of Barry Boehm and others, James Martin developed the rapid application development approach during the 1980s at IBM and finally formalized it by publishing a book in 1991, Rapid Application Development . This has resulted in some confusion over the term RAD even among IT professionals. It is important to distinguish between RAD as a general alternative to the waterfall model and RAD as the specific method created by Martin. The Martin method was tailored toward knowledge intensive and UI intensive business systems. These ideas were further developed and improved upon by RAD pioneers like James Kerr and Richard Hunter, who together wrote the seminal book on the subject, Inside RAD, [ 3 ] which followed the journey of a RAD project manager as he drove and refined the RAD Methodology in real-time on an actual RAD project.  These practitioners, and those like them, helped RAD gain popularity as an alternative to traditional systems project life cycle approaches. The RAD approach also matured during the period of peak interest in business re-engineering . The idea of business process re-engineering was to radically rethink core business processes such as sales and customer support with the new capabilities of Information Technology in mind. RAD was often an essential part of larger business re engineering programs. The rapid prototyping approach of RAD was a key tool to help users and analysts \"think out of the box\" about innovative ways that technology might radically reinvent a core business process. [ 4 ] [ 5 ] Much of James Martin's comfort with RAD stemmed from Dupont 's Information Engineering division and its leader Scott Schultz and their respective relationships with John Underwood who headed up a bespoke RAD development company that pioneered many successful RAD projects in Australia and Hong Kong. Successful projects that included ANZ Bank , Lendlease , BHP , Coca-Cola Amatil , Alcan , Hong Kong Jockey Club and numerous others. Success that led to both Scott Shultz and James Martin both spending time in Australia with John Underwood to understand the methods and details of why Australia was disproportionately successful in implementing significant mission critical RAD projects. James Martin approach [ edit ] Phases in the James Martin approach to RAD The James Martin approach to RAD divides the process into four distinct phases: Requirements planning phase \u2013 combines elements of the system planning and systems analysis phases of the systems development life cycle (SDLC). Users, managers, and IT staff members discuss and agree on business needs , project scope , constraints, and system requirements. It ends when the team agrees on the key issues and obtains management authorization to continue. User design phase \u2013 during this phase, users interact with systems analysts and develop models and prototypes that represent all system processes, inputs , and outputs . The RAD groups or subgroups typically use a combination of joint application design (JAD) techniques and CASE tools to translate user needs into working models. User design is a continuous interactive process that allows users to understand, modify, and eventually approve a working model of the system that meets their needs. Construction phase \u2013 focuses on program and application development task similar to the SDLC. In RAD, however, users continue to participate and can still suggest changes or improvements as actual screens or reports are developed. Its tasks are programming and application development, coding , unit-integration and system testing . Cutover phase \u2013 resembles the final tasks in the SDLC implementation phase, including data conversion, testing, changeover to the new system, and user training. Compared with traditional methods, the entire process is compressed. As a result, the new system is built, delivered, and placed in operation much sooner. [ 6 ] Advantages [ edit ] In modern Information Technology environments, many systems are now built using some degree of Rapid Application Development [ 7 ] (not necessarily the James Martin approach). In addition to Martin's method, agile methods and the Rational Unified Process are often used for RAD development. The purported advantages of RAD include: Better quality. By having users interact with evolving prototypes the business functionality from a RAD project can often be much higher than that achieved via a waterfall model. The software can be more usable and has a better chance to focus on business problems that are critical to end users rather than technical problems of interest to developers.  However, this excludes other categories of what are usually known as Non-functional requirements (AKA constraints or quality attributes) including security and portability . Risk control. Although much of the literature on RAD focuses on speed and user involvement a critical feature of RAD done correctly is risk mitigation. It's worth remembering that Boehm initially characterized the spiral model as a risk based approach. A RAD approach can focus in early on the key risk factors and adjust to them based on empirical evidence collected in the early part of the process. E.g., the complexity of prototyping some of the most complex parts of the system. More projects completed on time and within budget. By focusing on the development of incremental units the chances for catastrophic failures that have dogged large waterfall projects is reduced. In the Waterfall model it was common to come to a realization after six months or more of analysis and development that required a radical rethinking of the entire system. With RAD this kind of information can be discovered and acted upon earlier in the process. [ 2 ] [ 8 ] Disadvantages [ edit ] The purported disadvantages of RAD include: The risk of a new approach. For most IT shops RAD was a new approach that required experienced professionals to rethink the way they worked. Humans are virtually always averse to change and any project undertaken with new tools or methods will be more likely to fail the first time simply due to the requirement for the team to learn. Lack of emphasis on Non-functional requirements , which are often not visible to the end user in normal operation. Requires time of scarce resources. One thing virtually all approaches to RAD have in common is that there is much more interaction throughout the entire life-cycle between users and developers. In the waterfall model, users would define requirements and then mostly go away as developers created the system. In RAD users are involved from the beginning and through virtually the entire project. This requires that the business is willing to invest the time of application domain experts. The paradox is that the better the expert, the more they are familiar with their domain, the more they are required to actually run the business and it may be difficult to convince their supervisors to invest their time. Without such commitments RAD projects will not succeed. Less control. One of the advantages of RAD is that it provides a flexible adaptable process. The ideal is to be able to adapt quickly to both problems and opportunities. There is an inevitable trade-off between flexibility and control, more of one means less of the other. If a project (e.g. life-critical software ) values control more than agility RAD is not appropriate. Poor design. The focus on prototypes can be taken too far in some cases resulting in a \"hack and test\" methodology where developers are constantly making minor changes to individual components and ignoring system architecture issues that could result in a better overall design. This can especially be an issue for methodologies such as Martin's that focus so heavily on the user interface of the system. [ 9 ] Lack of scalability. RAD typically focuses on small to medium-sized project teams. The other issues cited above (less design and control) present special challenges when using a RAD approach for very large scale systems. [ 10 ] [ 11 ] [ 12 ] See also [ edit ] Practical concepts to implement RAD: Graphical user interface builder , where main software tools for RAD are represented Fourth-generation programming language , e.g. FileMaker , 4th Dimension , dBase and Visual FoxPro Other similar concepts: Flow-based programming Lean software development Platform as a service Low-code development platforms No-code development platform References [ edit ] ^ Brooks, Fred (1986). Kugler, H.J. (ed.). No Silver Bullet Essence and Accidents of Software Engineering (PDF) . Information Processing '86. Elsevier Science Publishers B.V (North-Holland). ISBN 0-444-70077-3 . Retrieved 2 July 2014 . ^ a b Boehm, Barry (May 1988). \"A Spiral Model of Software Development\" (PDF) . IEEE Computer . doi : 10.1109/2.59 . S2CID 1781829 . Archived from the original (PDF) on 29 March 2018 . Retrieved 1 July 2014 . ^ Kerr, James M.; Hunter, Richard (1993). Inside RAD: How to Build a Fully Functional System in 90 Days or Less. McGraw-Hill. ISBN 0-07-034223-7 . ^ Drucker, Peter (3 November 2009). Post-Capitalist Society . Harper Collins e-books. ISBN 978-0887306204 . ^ Martin, James (1991). Rapid Application Development . Macmillan. ISBN 0-02-376775-8 . ^ Martin, James (1991). Rapid Application Development . Macmillan. pp. 81\u201390 . ISBN 0-02-376775-8 . ^ \"The Disintegration of AD: Putting it Back Together Again\" (PDF) . gartner.com.br. Archived from the original (PDF) on 14 July 2014 . Retrieved 13 April 2010 . ^ Beck, Kent (2000). Extreme Programming Explained . Addison Wesley. pp. 3\u20137 . ISBN 0201616416 . ^ Gerber, Aurona; Van Der Merwe, Alta; Alberts, Ronell (16\u201318 November 2007). \"Practical Implications of Rapid Development Methodologies\". Proceedings of the Computer Science and Information technology Education Conference, CSITEd-2007 . Computer Science and IT Education Conference . Mauritius. pp. 233\u2013 245. CiteSeerX 10.1.1.100.645 . ISBN 978-99903-87-47-6 . ^ Andrew Begel, Nachiappan Nagappan (September 2007). \"Usage and Perceptions of Agile Software Development in an Industrial Context: An Exploratory Study\" (PDF) . First International Symposium on Empirical Software Engineering and Measurement (ESEM 2007) . pp. 255\u2013 264. doi : 10.1109/esem.2007.12 . ISBN 978-0-7695-2886-1 . S2CID 1941370 . ^ Maximilien, E.M.; Williams, L. (2003). \"Assessing test-driven development at IBM\". 25th International Conference on Software Engineering, 2003. Proceedings . pp. 564\u2013 569. doi : 10.1109/icse.2003.1201238 . ISBN 0-7695-1877-X . S2CID 16919353 . ^ Stephens, Matt; Rosenberg, Doug (2003). Extreme Programming Refactored: The Case Against XP . doi : 10.1007/978-1-4302-0810-5 . ISBN 978-1-59059-096-6 . S2CID 29042153 . Further reading [ edit ] Steve McConnell (1996). Rapid Development: Taming Wild Software Schedules , Microsoft Press Books, ISBN 978-1-55615-900-8 Kerr, James M.; Hunter, Richard (1993). Inside RAD: How to Build a Fully Functional System in 90 Days or Less . McGraw-Hill. ISBN 0-07-034223-7 . Ellen Gottesdiener (1995). \" RAD Realities: Beyond the Hype to How RAD Really Works \" Application Development Trends Ken Schwaber (1996). Agile Project Management with Scrum , Microsoft Press Books, ISBN 978-0-7356-1993-7 Steve McConnell (2003). Professional Software Development: Shorter Schedules, Higher Quality Products, More Successful Projects, Enhanced Careers , Addison-Wesley, ISBN 978-0-321-19367-4 Dean Leffingwell (2007). Scaling Software Agility: Best Practices for Large Enterprises , Addison-Wesley Professional, ISBN 978-0-321-45819-3 Scott Stiner (2016). Forbes List: \"Rapid Application Development (RAD): A Smart, Quick And Valuable Process For Software Developers\" External links [ edit ] Challenges of Working With The RAD Model What projects are suitable for rapid application development Real-Life Examples of RAD Implementation v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control flow Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Computational problem Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human-centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human\u2013computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Specialized Platform\nDevelopment Thermodynamic computing Category Outline Glossaries Retrieved from \" https://en.wikipedia.org/w/index.php?title=Rapid_application_development&oldid=1324650071 \" Categories : Software project management Software development process Programming tools Hidden categories: Articles with short description Short description matches Wikidata Use dmy dates from June 2020 This page was last edited on 28 November 2025, at 22:03 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Rapid application development 22 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Personal_software_process",
    "title": "Personal software process - Wikipedia",
    "content": "Personal software process - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Objectives 2 PSP structure 3 The importance of data 4 Planning and tracking 5 Using the PSP Toggle Using the PSP subsection 5.1 PSP and the TSP 5.2 PSP and other methodologies 5.3 Quality 6 Certification 7 See also 8 References 9 Further reading 10 External links Toggle the table of contents Personal software process 11 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Bahasa Indonesia Italiano Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Suomi Svenska \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Process to improve programming quality This article includes a list of general references , but it lacks sufficient corresponding inline citations . Please help to improve this article by introducing more precise citations. ( August 2023 ) ( Learn how and when to remove this message ) Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Image of a PSP Task Overview form. The Personal Software Process ( PSP ) is a structured software development process that is designed to help software engineers better understand and improve their performance by bringing discipline to the way they develop software and tracking their predicted and actual development of the code. It clearly shows developers how to manage the quality of their products, how to make a sound plan, and how to make commitments. It also offers them the data to justify their plans. They can evaluate their work and suggest improvement direction by analyzing and reviewing development time, defects, and size data. The PSP was created by Watts Humphrey to apply the underlying principles of the Software Engineering Institute 's (SEI) Capability Maturity Model (CMM) to the software development practices of a single developer. It claims to give software engineers the process skills necessary to work on a team software process (TSP) team. \"Personal Software Process\" and \" PSP \" are registered service marks of the Carnegie Mellon University . [ 1 ] [ 2 ] Objectives [ edit ] The PSP aims to provide software engineers with disciplined methods for improving personal software development processes. The PSP helps software engineers to: Improve their estimating and planning skills. Make commitments they can keep. Manage the quality of their projects. Reduce the number of defects in their work. PSP structure [ edit ] PSP training follows an evolutionary improvement approach: an engineer learning to integrate the PSP into his or her process begins at the first level \u2013 PSP0 \u2013 and progresses in process maturity to the final level \u2013 PSP2.1.  Each Level has detailed scripts, checklists and templates to guide the engineer through required steps and helps the engineer improve their own personal software process. Humphrey encourages proficient engineers to customize these scripts and templates as they gain an understanding of their own strengths and weaknesses. Process The input to PSP is the requirements; requirements document is completed and delivered to the engineer. PSP0, PSP0.1 (Introduces process discipline and measurement) PSP0 has 3 phases: planning, development (design, code, compile, test) and a post mortem. \nA baseline is established for current process measuring: time spent on programming, faults injected/removed and size of a program.\nIn a post mortem, the engineer ensures all data for the projects has been properly recorded and analysed.  \nPSP0.1 advances the process by adding a coding standard, a size measurement and the development of a personal process improvement plan (PIP). In the PIP, the engineer records ideas for improving his own process. PSP1, PSP1.1 (Introduces estimating and planning) Based upon the baseline data collected in PSP0 and PSP0.1, the engineer estimates how large a new program will be and prepares a test report (PSP1).\nAccumulated data from previous projects is used to estimate the total time.\nEach new project will record the actual time spent.\nThis information is used for task and schedule planning and estimation (PSP1.1). PSP2, PSP2.1 (Introduces quality management and design) PSP2 adds two new phases: design review and code review.  Defect prevention and removal of them are the focus at the PSP2. Engineers learn to evaluate and improve their process by measuring how long tasks take and the number of defects they inject and remove in each phase of development.\nEngineers construct and use checklists for design and code reviews.\nPSP2.1 introduces design specification and analysis techniques (PSP3 is a legacy level that has been superseded by TSP.) The importance of data [ edit ] One of the core aspects of the PSP is using historical data to analyze and improve process performance. PSP data collection is supported by four main elements: Scripts Measures Standards Forms The PSP scripts provide expert-level guidance to following the process steps and they provide a framework for applying the PSP measures. The PSP has four core measures: Size \u2013 the size measure for a product part, such as lines of code (LOC). Effort \u2013 the time required to complete a task, usually recorded in minutes. Quality \u2013 the number of defects in the product. Schedule \u2013 a measure of project progression, tracked against planned and actual completion dates. Applying standards to the process can ensure the data is precise and consistent.\nData is logged in forms, normally using a PSP software tool. The SEI has developed a PSP tool and there are also open source options available, such as Process Dashboard. The key data collected in the PSP tool are time, defect, and size data \u2013 the time spent in each phase; when and where defects were injected, found, and fixed; and the size of the product parts.  Software developers use many other measures that are derived from these three basic measures to understand and improve their performance. Derived measures include: estimation accuracy (size/time) prediction intervals (size/time) time in phase distribution defect injection distribution defect removal distribution productivity reuse percentage cost performance index planned value earned value predicted earned value defect density defect density by phase defect removal rate by phase defect removal leverage review rates process yield phase yield failure cost of quality (COQ) appraisal COQ appraisal/failure COQ ratio Planning and tracking [ edit ] Logging time, defect, and size data is an essential part of planning and tracking PSP projects, as historical data is used to improve estimating accuracy. The PSP uses the PROxy-Based Estimation (PROBE) method to improve a developer's estimating skills for more accurate project planning. For project tracking, the PSP uses the earned value method. The PSP also uses statistical techniques, such as correlation, linear regression, and standard deviation, to translate data into useful information for improving estimating, planning and quality. These statistical formulas are calculated by the PSP tool. Using the PSP [ edit ] The PSP is intended to help a developer improve their personal process; therefore PSP developers are expected to continue adapting the process to ensure it meets their personal needs. PSP and the TSP [ edit ] In practice, PSP skills are used in a TSP team environment. TSP teams consist of PSP-trained developers who volunteer for areas of project responsibility, so the project is managed by the team itself. Using personal data gathered using their PSP skills; the team makes the plans, the estimates, and controls the quality. Using PSP process methods can help TSP teams to meet their schedule commitments and produce high quality software. For example, according to research by Watts Humphrey, a third of all software projects fail, [ 3 ] but an SEI study on 20 TSP projects in 13 different organizations found that TSP teams missed their target schedules by an average of only six percent. [ 4 ] Successfully meeting schedule commitments can be attributed to using historical data to make more accurate estimates, so projects are based on realistic plans \u2013 and by using PSP quality methods, they produce low-defect software, which reduces time spent on removing defects in later phases, such as integration and acceptance testing. PSP and other methodologies [ edit ] The PSP is a personal process that can be adapted to suit the needs of the individual developer. It is not specific to any programming or design methodology; therefore it can be used with different methodologies, including Agile software development . Software engineering methods can be considered to vary from predictive through adaptive. The PSP is a predictive methodology, and Agile is considered adaptive, but despite their differences, the TSP/PSP and Agile share several concepts and approaches \u2013 particularly in regard to team organization. They both enable the team to: Define their goals and standards. Estimate and schedule the work. Determine realistic and attainable schedules. Make plans and process improvements. Both Agile and the TSP/PSP share the idea of team members taking responsibility for their own work and working together to agree on a realistic plan, creating an environment of trust and accountability. However, the TSP/PSP differs from Agile in its emphasis on documenting the process and its use of data for predicting and defining project schedules. Quality [ edit ] High-quality software is the goal of the PSP, and quality is measured in terms of defects. For the PSP, a quality process should produce low-defect software that meets the user needs. The PSP phase structure enables PSP developers to catch defects early. By catching defects early, the PSP can reduce the amount of time spent in later phases, such as Test. The PSP theory is that it is more economical and effective to remove defects as close as possible to where and when they were injected, so software engineers are encouraged to conduct personal reviews for each phase of development. Therefore, the PSP phase structure includes two review phases: Design Review Code Review To do an effective review, you need to follow a structured review process. The PSP recommends using checklists to help developers to consistently follow an orderly procedure. The PSP follows the premise that when people make mistakes, their errors are usually predictable, so PSP developers can personalize their checklists to target their own common errors. Software engineers are also expected to complete process improvement proposals, to identify areas of weakness in their current performance that they should target for improvement. Historical project data, which exposes where time is spent and defects introduced, help developers to identify areas to improve. PSP developers are also expected to conduct personal reviews before their work undergoes a peer or team review. Certification [ edit ] A certification covering PSP is offered by the SEI at Carnegie Mellon University.  The steps to becoming an SEI-Certified PSP Developer are: learn the PSP; take the certification exam; maintain credentials.   \nThe PSP Developer examination is based on concepts found in the PSP Body of Knowledge. [ 5 ] The SEI maintains an FAQ [ 1 ] on certification. See also [ edit ] Agile software development Capability Maturity Model Integration (CMMI) Carnegie Mellon University Proxy-based estimating (PROBE) Software Engineering Institute (SEI) Team software process (TSP) Watts Humphrey References [ edit ] ^ a b \"SEI-Certified PSP Developer: Frequently Asked Questions\" . www.sei.cmu.edu . Pittsburgh, Pennsylvania: Software Engineering Institute , Carnegie Mellon University . Archived from the original on 29 November 2014 . Retrieved 17 November 2014 . ^ \"Terms of Use\" . USA: Software Engineering Institute , Carnegie Mellon University . Retrieved 14 January 2013 . ^ Humphrey, Watts S. \"Why Big Software Projects Fail: The 12 Key Questions.\" CrossTalk Mar. 2005 http://www.crosstalkonline.org/storage/issue-archives/2005/200503/200503-Humphrey.pdf Archived 2019-11-05 at the Wayback Machine ^ Davis, Noopur, and Julia Mullaney. The Team Software Process SM (TSP SM) in Practice: A Summary of Recent Results. Pittsburgh, PA: Software Engineering Institute, Sept. 2003. ^ Pomeroy-Huff, Marsha; Cannon, Robert; Chick, Timothy A.; Mullaney, Julia; Nichols, William (2009). The Personal Software Process (PSP) Body of Knowledge, Version 2.0 (PDF) . Pittsburgh, Pennsylvania: Software Engineering Institute , Carnegie Mellon University . Retrieved 17 November 2014 . Freely downloadable Special Report CMU/SEI-2009-SR-018, 2009 Further reading [ edit ] \"Using a defined and measured Personal Software Process\" by Watts S. Humphrey , published in IEEE Software , May 1996, pages 77\u201388. PSP: A Self-Improvement Process for Software Engineers , 2005. Delivering Successful Projects with TSP(SM) and Six Sigma: A Practical Guide to Implementing Team Software Process , Mukesh Jain, 2008. \"Delivering Successful Projects With Challenges of New Teams\" by Mukesh Jain ( http://www.sei.cmu.edu/tspsymposium/2009/2006/deliver.pdf ), September 2006. Software Engineering: A Practitioner's Approach 7th Edition. Roger S Pressman. McGraw-Hill Higher Education. 2009. ISBN 0-07-337597-7 , ISBN 978-0-07-337597-7 , pages 57\u201358. \"The Personal Software Process (PSP) Body of Knowledge\" article from the Software Engineering Institute at Carnegie Mellon . \"Personal Quality Management with the Personal Software Process\" article. External links [ edit ] Software Process Dashboard , Open-source ( GPL3 ) PSP and TSP tool; offered both without and with proprietary SEI scripts, latter requiring free SEI registration. Retrieved from \" https://en.wikipedia.org/w/index.php?title=Personal_software_process&oldid=1274068102 \" Categories : Software development process Carnegie Mellon University Hidden categories: Webarchive template wayback links Articles with short description Short description matches Wikidata Articles lacking in-text citations from August 2023 All articles lacking in-text citations This page was last edited on 5 February 2025, at 09:25 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Personal software process 11 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Scrum_(software_development)",
    "title": "Scrum (project management) - Wikipedia",
    "content": "Scrum (project management) - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Scrum team Toggle Scrum team subsection 2.1 Product owner 2.2 Developers 2.3 Scrum master 3 Workflow Toggle Workflow subsection 3.1 Sprint 3.2 Daily scrum 3.3 Post-sprint events 3.4 Backlog Refinement 4 Artifacts Toggle Artifacts subsection 4.1 Product backlog 4.2 Sprint backlog 4.3 Increment 4.4 Other artifacts 4.4.1 Burndown chart 4.4.2 Burnup chart 4.4.3 Velocity 5 Limitations 6 Adaptations Toggle Adaptations subsection 6.1 Scrumban 6.2 Scrum of scrums 6.3 Large-scale scrum 7 Criticism 8 See also 9 Citations 10 General and cited references 11 External links Toggle the table of contents Scrum (project management) 38 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u09ac\u09be\u0982\u09b2\u09be \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u010ce\u0161tina Dansk Deutsch Eesti \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac Espa\u00f1ol Esperanto \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Bahasa Indonesia Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Lietuvi\u0173 Magyar \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas Rom\u00e2n\u0103 \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Srpskohrvatski / \u0441\u0440\u043f\u0441\u043a\u043e\u0445\u0440\u0432\u0430\u0442\u0441\u043a\u0438 Suomi Svenska \u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia (Redirected from Scrum (software development) ) Management framework This article is about software development framework. For other uses, see Scrum . Some of this article's listed sources may not be reliable . Please help improve this article by looking for better, more reliable sources. Unreliable citations may be challenged and removed. ( May 2020 ) ( Learn how and when to remove this message ) Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Scrum Agile events, based on The 2020 Scrum Guide [ 1 ] Scrum is an agile team collaboration framework commonly used in software development and other industries. Scrum prescribes for teams to break work into goals to be completed within time-boxed iterations, called sprints . Each sprint is no longer than one month and commonly lasts two weeks. The scrum team assesses progress in time-boxed, stand-up meetings of up to 15 minutes, called daily scrums . At the end of the sprint, the team holds two further meetings: one sprint review to demonstrate the work for stakeholders and solicit feedback, and one internal sprint retrospective . A person in charge of a scrum team is typically called a scrum master . [ 2 ] Scrum teams should be cross-functional and self-managing . Unlike sequential approaches, scrum is an iterative and incremental framework for product development. [ 3 ] Scrum allows for continuous feedback and flexibility, requiring teams to self-organize by encouraging physical co-location or close online collaboration, and mandating frequent communication among all team members. The flexible approach of scrum is based in part on the notion of requirement volatility, that stakeholders will change their requirements as the project evolves. [ 4 ] History [ edit ] The use of the term scrum in software development came from a 1986 Harvard Business Review paper titled \"The New New Product Development Game\" by Hirotaka Takeuchi and Ikujiro Nonaka . Based on case studies from manufacturing firms in the automotive, photocopier, and printer industries , the authors outlined a new approach to product development for increased speed and flexibility. They called this the rugby approach, as the process involves a single cross-functional team operating across multiple overlapping phases in which the team \"tries to go the distance as a unit, passing the ball back and forth\". [ 5 ] The authors later developed scrum in their book, The Knowledge Creating Company . [ 6 ] In the early 1990s, Ken Schwaber used what would become scrum at his company, Advanced Development Methods. Jeff Sutherland , John Scumniotales, and Jeff McKenna developed a similar approach at Easel Corporation, referring to the approach with the term scrum . [ 7 ] Sutherland and Schwaber later worked together to integrate their ideas into a single framework, formally known as scrum. Schwaber and Sutherland tested scrum and continually improved it, leading to the publication of a research paper in 1995, [ 8 ] and the Manifesto for Agile Software Development in 2001. [ 9 ] Schwaber also collaborated with Babatunde Ogunnaike at DuPont Research Station and the University of Delaware to develop Scrum. Ogunnaike believed that software development projects could often fail when initial conditions change if product management was not rooted in empirical practice. [ 10 ] In 2002, Schwaber with others founded the Scrum Alliance and set up the Certified Scrum accreditation series. [ 11 ] Schwaber left the Scrum Alliance in late 2009 and subsequently founded Scrum.org, which oversees the parallel Professional Scrum accreditation series. [ 12 ] Since 2009, a public document called The Scrum Guide [ 13 ] has been published and updated by Schwaber and Sutherland. It has been revised six times, with the most recent version having been published in November 2020. Scrum team [ edit ] A scrum team is organized into at least three categories of individuals: the product owner, developers, and the scrum master. The product owner liaises with stakeholders, those who have an interest in the project's outcome, to communicate tasks and expectations with developers. [ 14 ] Developers in a scrum team organize work by themselves, with the facilitation of a scrum master. [ 15 ] Product owner [ edit ] Each scrum team has one product owner. [ 16 ] The product owner focuses on the business side of product development and spends the majority of time liaising with stakeholders and the team. The role is intended to primarily represent the product's stakeholders , the voice of the customer , or the desires of a committee , and bears responsibility for the delivery of business results. [ 17 ] [ 18 ] [ 19 ] [ 20 ] Product owners manage the product backlog and are responsible for maximizing the value that a team delivers. [ 18 ] They do not dictate the technical solutions of a team but may instead attempt to seek consensus among team members. [ 21 ] [ 22 ] Developers [ edit ] In scrum, the term developer or team member refers to anyone who plays a role in the development and support of the product and can include researchers, architects , designers, programmers, etc. [ 13 ] [ 23 ] Scrum master [ edit ] Scrum is facilitated by a scrum master, whose role is to educate and coach teams about scrum theory and practice. [ 1 ] Scrum masters have differing roles and responsibilities from traditional team leads or project managers . Some scrum master responsibilities include coaching, objective setting, problem solving, oversight, planning, backlog management, and communication facilitation. [ 1 ] On the other hand, traditional project managers often have people management responsibilities, which a scrum master does not. Scrum teams do not involve project managers, so as to maximize self-organisation among developers. [ 3 ] Workflow [ edit ] Sprint [ edit ] Not to be confused with Hackathon \u00a7\u00a0Code sprints . The scrum framework (PBI in the figure refers to product backlog item) The scrum process A sprint (also known as a design sprint , iteration , or timebox ) is a fixed period of time wherein team members work on a specific goal. Each sprint is normally between one week and one month, with two weeks being the most common. [ 10 ] The outcome of the sprint is a functional deliverable, or a product which has received some development in increments . When a sprint is abnormally terminated, the next step is to conduct new sprint planning, where the reason for the termination is reviewed. Each sprint starts with a sprint planning event in which a sprint goal is defined. Priorities for planned sprints are chosen out of the backlog. Each sprint ends with two events: [ 7 ] A sprint review (progress shown to stakeholders to elicit their feedback) A sprint retrospective (identifying lessons and improvements for the next sprints) The suggested maximum duration of sprint planning is eight hours for a four-week sprint. [ 13 ] Daily scrum [ edit ] Main article: Daily scrum meeting A daily scrum in the computing room Each day during a sprint, the developers hold a daily scrum (often conducted standing up ) with specific guidelines, and which may be facilitated by a scrum master. [ 10 ] [ 24 ] Daily scrum meetings are intended to be less than 15 minutes in length, taking place at the same time and location daily. The purpose of the meeting is to announce progress made towards the sprint goal and issues that may be hindering the goal, without going into any detailed discussion. Once over, individual members can go into a 'breakout session' or an 'after party' for extended discussion and collaboration. [ 25 ] Scrum masters are responsible for ensuring that team members use daily scrums effectively or, if team members are unable to use them, providing alternatives to achieve similar outcomes. [ 26 ] [ 27 ] Post-sprint events [ edit ] Conducted at the end of a sprint, a sprint review is a meeting that has a team share the work they've completed with stakeholders and liaise with them on feedback, expectations, and upcoming plans. At a sprint review completed deliverables are demonstrated to stakeholders. The recommended duration for a sprint review is one hour per week of sprint. [ 13 ] A sprint retrospective is a separate meeting that allows team members to internally analyze the strengths and weaknesses of the sprint, future areas of improvement, and continuous process improvement actions. [ 28 ] Backlog Refinement [ edit ] Backlog refinement (formerly known as \"grooming\") is a process by which team members revise and prioritize a backlog for future sprints. [ 29 ] It can be done as a separate stage done before the beginning of a new sprint or as a continuous process that team members work on by themselves. Backlog refinement can include the breaking down of large tasks into smaller and clearer ones, the clarification of success criteria, and the revision of changing priorities and returns. [ 30 ] Artifacts [ edit ] Artifacts are a means by which scrum teams manage product development by documenting work done towards the project. There are many kinds of scrum artifacts, with three of them being the most common: product backlog, sprint backlog, and increment. [ 31 ] Product backlog [ edit ] Main article: Product backlog The product backlog is a breakdown of work to be done and contains an ordered list of product requirements (such as features , bug fixes and non-functional requirements ) that the team maintains for a product . The order of a product backlog corresponds to the urgency of the task. Common formats for backlog items include user stories and use cases . [ 3 ] The product backlog may also contain the product owner's assessment of business value and the team's assessment of the product's effort or complexity, which can be stated in story points using the rounded Fibonacci scale . These estimates try to help the product owner gauge the timeline and may influence the ordering of product backlog items. [ 32 ] The product owner maintains and prioritizes product backlog items based on considerations such as risk, business value, dependencies, size, and timing. High-priority items at the top of the backlog are broken down into more detail for developers to work on, while tasks further down the backlog may be more vague. [ 10 ] Sprint backlog [ edit ] The sprint backlog is the subset of items from the product backlog intended for developers to address in a particular sprint. [ 33 ] Developers fill this backlog with tasks they deem appropriate to fill the sprint, using past performance to assess their capacity for each sprint. The scrum approach has tasks on the sprint backlog not assigned to developers by any particular individual or leader. Team members self organize by pulling work as needed according to the backlog priority and their own capabilities and capacity. [ 34 ] Increment [ edit ] An increment is a potentially releasable output of a sprint, which meets the sprint goal and the definition of done. It is formed from all the completed sprint backlog items, integrated with the work of all previous sprints. [ 3 ] Other artifacts [ edit ] Burndown chart [ edit ] A sample burndown chart for a completed sprint, showing remaining effort at the end of each day Main article: Burndown chart Often used in scrum, a burndown chart is a publicly displayed chart showing remaining work. [ 35 ] It provides quick visualizations for reference. The horizontal axis of the burndown chart shows the days remaining, while the vertical axis shows the amount of work remaining each day. During sprint planning, the ideal burndown chart is plotted. [ 36 ] Then, during the sprint, developers update the chart with the remaining work. Burnup chart [ edit ] A sample burnup chart for a release, showing scope completed each sprint (MVP = minimum viable product ) Main article: Burnup chart Updated at the end of each sprint, the release burn-up chart shows progress towards delivering a forecast scope. The horizontal axis of the release burnup chart shows the sprints in a release, while the vertical axis shows the amount of work completed at the end of each sprint. [ 37 ] [ 38 ] Velocity [ edit ] Main article: Velocity (software development) A team's total capability effort for a single sprint can be estimated by evaluating work completed in the last sprint. The collection of historical \" velocity \" data is a guideline for assisting the team in understanding their capacity. [ 39 ] Limitations [ edit ] Some have argued that scrum events, such as daily scrums and scrum reviews, hurt productivity and waste time that could be better spent on actual productive tasks. [ 40 ] [ 41 ] Scrum has also been observed to pose difficulties for part-time or geographically distant teams; those that have highly specialized members who would be better off working by themselves or in working cliques; and those that are unsuitable for incremental and development testing . [ 42 ] [ 43 ] Adaptations [ edit ] Scrum is frequently tailored or adapted in different contexts to achieve varying aims. [ 44 ] A common approach to adapting scrum is the combination of scrum with other software development methodologies, as scrum does not cover the whole product development lifecycle . [ 45 ] Various scrum practitioners have also suggested more detailed techniques for how to apply or adapt scrum to particular problems or organizations. Many refer to these techniques as 'patterns', an analogous use to design patterns in architecture and software. [ 46 ] [ 47 ] Scrumban [ edit ] Main article: Scrumban Scrumban is a software production model based on scrum and kanban . To illustrate each stage of work, teams working in the same space often use post-it notes or a large whiteboard. [ 48 ] Kanban models allow a team to visualize work stages and limitations. [ 49 ] Scrum of scrums [ edit ] Scrum of scrums is a technique to operate scrum at scale for multiple teams coordinating on the same product. Scrum-of-scrums daily scrum meetings involve ambassadors selected from each individual team, who may be either a developer or scrum master. As a tool for coordination, scrum of scrums allows teams to collectively work on team-wide risks, impediments, dependencies, and assumptions (RIDAs), which may be tracked in a backlog of their own. [ 50 ] [ 51 ] Large-scale scrum [ edit ] Large-scale scrum is an organizational system for product development that scales scrum with varied rules and guidelines, developed by Bas Vodde and Craig Larman . [ 52 ] [ 53 ] There are two levels to the framework: the first level, designed for up to eight teams; and the second level, known as 'LeSS Huge', which can accommodate development involving hundreds of developers. [ 54 ] Criticism [ edit ] A systematic review found \"that Distributed Scrum has no impact, positive or negative on overall project success\" in distributed software development. [ 55 ] Martin Fowler , one of the authors of the Manifesto for Agile Software Development , has criticized what he calls \"faux-agile\" practices that are \"disregarding Agile's values and principles\", [ 56 ] and \"the Agile Industrial Complex imposing methods upon people\" contrary to the Agile principle of valuing \"individuals and interactions over processes and tools\" [ 9 ] and allowing the individuals doing the work to decide how the work is done, changing processes to suit their needs. In September 2016, Ron Jeffries, a signatory to the Agile Manifesto , [ 9 ] described what he called \"Dark Scrum\", saying that \"Scrum can be very unsafe for programmers.\" [ 57 ] See also [ edit ] Agile software development Agile testing Agile learning Disciplined agile delivery Comparison of scrum software High-performance teams Lean software development Project management Unified process Citations [ edit ] ^ a b c Ken Schwaber ; Jeff Sutherland . \"The Scrum Guide\" (PDF) . Scrum.org . Retrieved June 15, 2023 . ^ \"What Is A Scrum Master? Everything You Need To Know \u2013 Forbes Advisor\" . www.forbes.com . December 27, 2021 . Retrieved November 16, 2023 . ^ a b c d Pete Deemer; Gabrielle Benefield; Craig Larman; Bas Vodde (December 17, 2012). \"The Scrum Primer: A Lightweight Guide to the Theory and Practice of Scrum (Version 2.0)\" . InfoQ. ^ J. Henry and S. Henry. Quantitative assessment of the software maintenance process and requirements volatility. In Proc. of the ACM Conference on Computer Science, pages 346\u2013351, 1993. ^ Takeuchi, Hirotaka; Nonaka, Ikujiro (January 1, 1986). \"The New New Product Development Game\" . Harvard Business Review . Retrieved June 9, 2010 . Moving the Scrum Downfield ^ The Knowledge Creating Company . Oxford University Press. 1995. p.\u00a03. ISBN 978-0-19-976233-0 . Retrieved March 12, 2013 . ^ a b Sutherland, Jeff (October 2004). \"Agile Development: Lessons learned from the first Scrum\" . Archived from the original (PDF) on June 30, 2014 . Retrieved September 26, 2008 . ^ Sutherland, Jeffrey Victor ; Schwaber, Ken (1995). Business object design and implementation: OOPSLA '95 workshop proceedings . The University of Michigan . p.\u00a0118. ISBN 978-3-540-76096-2 . ^ a b c \"Manifesto for Agile Software Development\" . Retrieved October 17, 2019 . ^ a b c d Schwaber, Ken (February 1, 2004). Agile Project Management with Scrum . Microsoft Press . ISBN 978-0-7356-1993-7 . ^ Maximini, Dominik (January 8, 2015). The Scrum Culture: Introducing Agile Methods in Organizations . Management for Professionals. Cham: Springer (published 2015). p.\u00a026. ISBN 978-3-319-11827-7 . Retrieved August 25, 2016 . Ken Schwaber and Jeff Sutherland presented Scrum for the first time at the OOPSLA conference in Austin, Texas, in 1995. [...] In 2001, the first book about Scrum was published. [...] One year later (2002), Ken founded the Scrum Alliance, aiming at providing worldwide Scrum training and certification. ^ \"Home\" . Scrum.org . Retrieved January 6, 2020 . ^ a b c d Sutherland, Jeff ; Schwaber, Ken (2013). \"Scrum Guides\" . ScrumGuides.org . Retrieved June 15, 2023 . ^ Morris, David (2017). Scrum: an ideal framework for agile projects . In Easy Steps. pp. 178\u2013 179. ISBN 978-1-84078-731-3 . OCLC 951453155 . ^ Cobb, Charles G. (2015). The Project Manager's Guide to Mastering Agile: Principles and Practices for an Adaptive Approach . Hoboken, NJ: John Wiley & Sons. p.\u00a037. ISBN 978-1-118-99104-6 . ^ Cohn, Mike (2010). Succeeding with Agile: Software Development Using Scrum . Upper Saddle River, NJ: Addison-Wesley. ISBN 978-0-321-57936-2 . ^ Rubin, Kenneth (2013), Essential Scrum. A Practical Guide to the Most Popular Agile Process , Addison-Wesley, p.\u00a0173, ISBN 978-0-13-704329-3 ^ a b McGreal, Don; Jocham, Ralph (June 4, 2018). The Professional Product Owner: Leveraging Scrum as a Competitive Advantage . Addison-Wesley Professional. ISBN 978-0-13-468665-3 . ^ Pichler, Roman (March 11, 2010). Agile Product Management with Scrum: Creating Products that Customers Love . Addison-Wesley Professional. ISBN 978-0-321-68413-4 . ^ Ambler, Scott. \"The Product Owner Role: A Stakeholder Proxy for Agile Teams\" . agilemodeling.com . Retrieved July 22, 2016 . [...] in practice there proves to be two critical aspects to this role: first as a stakeholder proxy within the development team and second as a project team representative to the overall stakeholder community as a whole. ^ \"The Scrum Guide\" (PDF) . Scrum.org. p.\u00a06 . Retrieved June 15, 2023 . ^ \"The Role of the Product Owner\" . Scrum Alliance . Retrieved May 26, 2018 . ^ Rad, Nader K.; Turley, Frank (2018). Agile Scrum Foundation Courseware, Second Edition . 's-Hertogenbosch, Netherlands: Van Haren. p.\u00a026. ISBN 978-94-018-0279-6 . ^ \"What is a Daily Scrum?\" . Scrum.org . Retrieved January 6, 2020 . ^ Flewelling, Paul (2018). The Agile Developer's Handbook: Get more value from your software development: get the best out of the Agile methodology . Birmingham, UK: Packt Publishing Ltd. p.\u00a091. ISBN 978-1-78728-020-5 . ^ McKenna, Dave (2016). The Art of Scrum: How Scrum Masters Bind Dev Teams and Unleash Agility . Aliquippa, PA: CA Press. p.\u00a0126. ISBN 978-1-4842-2276-8 . ^ Drongelen, Mike van; Dennis, Adam; Garabedian, Richard; Gonzalez, Alberto; Krishnaswamy, Aravind (2017). Lean Mobile App Development: Apply Lean startup methodologies to develop successful iOS and Android apps . Birmingham, UK: Packt Publishing Ltd. p.\u00a043. ISBN 978-1-78646-704-1 . ^ Rubin, Kenneth (2012), Essential Scrum. A Practical Guide to the Most Popular Agile Process , Addison-Wesley (published 2013), p.\u00a0375, ISBN 978-0-13-704329-3 ^ Project Management Institute 2021 , Glossary \u00a73 Definitions. ^ Scrum.org. \"Product Backlog Refinement\" . scrum.org . Scrum.org . Retrieved December 17, 2025 . The activity of continually improving PBIs until they are ready to be worked on is called \"refinement.\" ^ \"What are Scrum Artifacts? | The Ultimate Guide | Miro\" . miro.com/ . Retrieved November 29, 2024 . ^ Higgins, Tony (March 31, 2009). \"Authoring Requirements in an Agile World\" . BA Times. ^ Russ J. Martinelli; Dragan Z. Milosevic (January 5, 2016). Project Management ToolBox: Tools and Techniques for the Practicing Project Manager . Wiley. p.\u00a0304. ISBN 978-1-118-97320-2 . ^ Ken Schwaber ; Jeff Sutherland . \"The Scrum Guide\" (PDF) . Scrum.org . Retrieved May 25, 2018 . ^ Charles G. Cobb (January 27, 2015). The Project Manager's Guide to Mastering Agile: Principles and Practices for an Adaptive Approach . John Wiley & Sons. p.\u00a0378. ISBN 978-1-118-99104-6 . ^ \"Agile 101 \u2013 Sprint Planning\" . Somar Digital . Retrieved July 9, 2025 . ^ Arafeen, Junaid; Bose, Saugata (September 2009). \"Improving Software Development Using Scrum Model by Analyzing Up and Down Movements on The Sprint Burn Down Chart: Proposition for Better Alternatives\" . International Journal of Digital Content Technology and its Applications . 3 (3) \u2013 via CiteSeerX. ^ \"What is a burn up chart and how to create one\" . Atlassian . Retrieved December 17, 2025 . ^ \"Sprint Velocity in Scrum: How to Measure and Improve Performance\" . Atlassian . Retrieved December 17, 2025 . ^ Jenson, John (March 8, 2019). \"Meetings: The productivity killer for developers\" . TandemSeven \u2013 The Experience Innovation Company . Archived from the original on June 5, 2020 . Retrieved June 5, 2020 . ^ \"Not all developers like agile, and here are 5 reasons why\" . Business Matters . December 4, 2019 . Retrieved June 5, 2020 . ^ Turk, Dan; France, Robert; Rumpe, Bernhard (2014) [2002]. \"Limitations of Agile Software Processes\". Proceedings of the Third International Conference on Extreme Programming and Flexible Processes in Software Engineering : 43\u2013 46. arXiv : 1409.6600 . ^ \"Issues and Challenges in Scrum Implementation\" (PDF) . International Journal of Scientific & Engineering Research . 3 (8). August 2012 . Retrieved December 10, 2015 . ^ Hron, Michal; Obwegeser, Nikolaus (January 1, 2022). \"Why and how is Scrum being adapted in practice: A systematic review\" . Journal of Systems and Software . 183 111110. doi : 10.1016/j.jss.2021.111110 . ISSN 0164-1212 . S2CID 240950847 . ^ Hron, M.; Obwegeser, N. (January 2018). \"Scrum in practice: an overview of Scrum adaptations\" (PDF) . Proceedings of the 2018 51st Hawaii International Conference on System Sciences (HICSS), January 3\u20136, 2018 . [ dead link ] ^ Bj\u00f8rnvig, Gertrud; Coplien, Jim (June 21, 2008). \"Scrum as Organizational Patterns\" . Gertrude & Cope. ^ \"Scrum Pattern Community\" . ScrumPLoP.org . Retrieved July 22, 2016 . ^ Ladas, Corey (October 27, 2007). \"scrum-ban\" . Lean Software Engineering. Archived from the original on August 23, 2018 . Retrieved September 13, 2012 . ^ Kniberg, Henrik; Skarin, Mattias (December 21, 2009). \"Kanban and Scrum \u2013 Making the most of both\" (PDF) . InfoQ . Retrieved July 22, 2016 . ^ \"Risk Management \u2013 How to Stop Risks from Screwing Up Your Projects!\" . Kelly Waters. Archived from the original on January 6, 2015 . Retrieved January 6, 2015 . ^ \"Scrum of Scrums\" . Agile Alliance. December 17, 2015. Archived from the original on February 9, 2014 . Retrieved December 17, 2013 . ^ \"Large-Scale Scrum (LeSS)\" . 2014. ^ Grgic (2015). \"Descaling organisation with LeSS (Blog)\" . ^ Larman, Craig; Bas Vodde (May\u2013June 2013). \"Scaling Agile Development\" (PDF) . Crosstalk . ^ Santos, Ronnie de Souza; Ralph, Paul; Arshad, Arham; Stol, Klaas-Jan (October 5, 2023). \"Distributed Scrum: A Case Meta-Analysis\" . ACM Computing Surveys . 56 (4): 1\u2013 37. doi : 10.1145/3626519 . S2CID 263672588 . ^ Fowler, Martin (August 25, 2018). \"The State of Agile Software in 2018\" . martinfowler.com . Archived from the original on September 14, 2023 . Retrieved September 14, 2023 . ^ Jeffries, Ron (September 8, 2016). \"Dark Scrum\" . ronjeffries.com . Retrieved May 6, 2024 . General and cited references [ edit ] Deemer, Pete; Benefield, Gabrielle; Larman, Craig; Vodde, Bas (2009). \"The Scrum Primer\" . Retrieved June 1, 2009 . Janoff, N. S.; Rising, L. (2000). \"The Scrum Software Development Process for Small Teams\" (PDF) . Archived from the original (PDF) on November 6, 2015 . Retrieved February 26, 2015 . M\u00fcnch, J\u00fcrgen; Armbrust, Ove; Soto, Mart\u00edn; Kowalczyk, Martin (2012). Software Process Definition and Management . Springer. ISBN 978-3-642-24291-5 . A guide to the project management body of knowledge (PMBOK guide) (7th\u00a0ed.). Newtown Square, PA: Project Management Institute. 2021. ISBN 978-1-62825-664-2 . Rubin, Kenneth (2013). Essential Scrum: A Practical Guide to the Most Popular Agile Process . Addison-Wesley. p.\u00a0173. ISBN 978-0-13-704329-3 . Vacaniti, Daniel (February 2018). \"The Kanban Guide for Scrum Teams\" (PDF) . scrum.org . Retrieved March 12, 2018 . Verheyen, Gunther (2013). Scrum \u2013 A Pocket Guide (A Smart Travel Companion) . ISBN 978-90-8753-720-3 . External links [ edit ] Wikimedia Commons has media related to Scrum (development) . English Wikisource has original text related to this article: The Scrum Guide Agile Alliance's Scrum library A scrum process description by the Eclipse process framework (EPF) project v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Authority control databases National United States Israel Other Yale LUX Retrieved from \" https://en.wikipedia.org/w/index.php?title=Scrum_(project_management)&oldid=1328084768 \" Categories : Agile software development Software development Software development philosophies Software project management Hidden categories: All articles with dead external links Articles with dead external links from November 2025 Articles with short description Short description is different from Wikidata Articles lacking reliable references from May 2020 All articles lacking reliable references Use American English from July 2023 All Wikipedia articles written in American English Use mdy dates from February 2022 Commons category link is on Wikidata Wikisource templates with missing id Articles prone to spam from May 2015 This page was last edited on 17 December 2025, at 19:57 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Scrum (project management) 38 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Team_software_process",
    "title": "Team software process - Wikipedia",
    "content": "Team software process - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Introduction to TSP 2 How TSP works 3 Latest developments 4 Publications 5 See also 6 References 7 External links Toggle the table of contents Team software process 7 languages Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Bahasa Indonesia Italiano Portugu\u00eas Svenska Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Self-optimization method for development teams Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e In combination with the personal software process (PSP), the team software process ( TSP ) provides a defined operational process framework that is designed to help teams of managers and engineers organize projects and produce software for \nproducts that range in size from small projects of several thousand lines of code (KLOC) to very large projects greater than half a million lines of code. The TSP is intended to improve the levels of quality and productivity of a team's software development project, in order to help them better meet the cost and schedule commitments of developing a software system. [ 1 ] [ 2 ] [ 3 ] [ 4 ] The initial version of the TSP was developed and piloted by Watts Humphrey in the late 1990s [ 5 ] and the Technical Report [ 6 ] for TSP  sponsored by the U.S. Department of Defense was published in November 2000. The book by Watts Humphrey, [ 7 ] Introduction to the Team Software Process , presents a view of the TSP intended for use in academic settings, that focuses on the process of building a software production team, establishing team goals, distributing team roles, and other teamwork-related activities. Introduction to TSP [ edit ] The primary goal of TSP is to create a team environment for establishing and maintaining a self-directed\nteam, and supporting disciplined individual work as a base of PSP framework. Self-directed team means that the team manages itself, plans and tracks their work, manages the quality of their work, and works proactively to meet team goals. TSP has two principal components: team-building and team-working. Team-building is a process that defines roles for each team member and sets up teamwork through TSP launch and periodical relaunch.\nTeam-working is a process that deals with engineering processes and practices utilized by the team.\nTSP, in short, provides engineers and managers with a way that establishes and manages their team to produce the high-quality software on schedule and budget. How TSP works [ edit ] Before engineers can participate in the TSP, it is required that they have already learned about the PSP, so that the TSP can work effectively. Training is also required for other team members, the team lead and management. The TSP software development cycle begins with a planning process called the launch, led by a coach who has been specially trained, and is either certified or provisional. [ 8 ] [ 9 ] The launch is designed to begin the team building process, and during this time teams and managers establish goals, define team roles, assess risks, estimate effort, allocate tasks, and produce a team plan. During an execution phase, developers track planned and actual effort, schedule, and defects meeting regularly (usually weekly) to report status and revise plans. A development cycle ends with a Post Mortem to assess performance, revise planning parameters, and capture lessons learned for process improvement. The coach role focuses on supporting the team and the individuals on the team as the process expert while being independent of direct project management responsibility. [ 10 ] [ 11 ] The team leader role is different from the coach role in that, team leaders are responsible to management for products and project outcomes while the coach is responsible for developing individual and  team performance. [ 12 ] [ 13 ] Latest developments [ edit ] TSP has been adapted to work with other types of knowledge work , including systems engineering [ 14 ] and services. [ 15 ] [ 16 ] Mapping TSP to Capability Maturity Model Integrated (CMMI) practices was documented in 2010, [ 17 ] and piloted as an alternative path to implement CMMI process improvement. [ 18 ] [ 19 ] A body of knowledge (BOK) was issued in 2010. [ 20 ] The coach mentor program guidebook was released in 2010. [ 21 ] According to a study by Capers Jones TSP is one of the most successful development methodologies regarding schedule, quality and budget (TCO) [ 22 ] Publications [ edit ] TSP: Leading a Development Team 2005 TSP: Coaching Development Teams 2005 See also [ edit ] Personal software process (PSP) Watts Humphrey References [ edit ] ^ Jones, Capers (2009). Software Engineering Best Practices . McGraw-Hill. p.\u00a011. ISBN 9780071621618 . ^ Kindler, Nosh B; Krishnakanthan, Vasantha; Tinaikar, Ranjit. Applying Lean to Application Development Archived 2012-06-17 at the Wayback Machine . McKinsey Quarterly, May 2007 ^ \"Agile Capital Consulting\" . Archived from the original on February 3, 2018 . Retrieved July 3, 2017 . ^ Ker, J. I., Wang, Y., Hajli, M. N., Song, J., & Ker, C. W. (2014). \"Deploying lean in healthcare: Evaluating information technology effectiveness in US hospital pharmacies\". International Journal of Information Management , 34(4), 556\u2013560. ^ McAndrews, Donald (1998). \"The Team Software ProcessSM (TSPSM): An Overview and Preliminary Results of Using Disciplined Practices\" . Archived from the original on 2012-10-26 . Retrieved 2011-07-25 . {{ cite journal }} : Cite journal requires |journal= ( help ) ^ Humphrey, Watts. \"The Team Software Process\" (PDF) . Software Engineering Institute. ^ Humphrey, Watts (1999). Introduction to the Team Software Process . Addison Wesley. ^ Humphrey, Watts (2018). \"The Team Software Process Body of Knowledge\" . Software Engineering Institute. doi : 10.1184/R1/6584825.v1 . {{ cite journal }} : Cite journal requires |journal= ( help ) ^ Chick, Timothy (2010). \"Team Software Process (TSP) Coach Mentoring Program Guidebook Version 1.1\" . Software Engineering Institute. doi : 10.1184/R1/6584810.v1 . {{ cite journal }} : Cite journal requires |journal= ( help ) ^ Humphrey, Watts (2018). \"The Team Software Process Body of Knowledge\" . Software Engineering Institute. doi : 10.1184/R1/6584825.v1 . {{ cite journal }} : Cite journal requires |journal= ( help ) ^ Humphrey, Watts (2005). TSP: Coaching Development Teams . Addison Wesley. ^ Humphrey, Watts (2018). \"The Team Software Process Body of Knowledge\" . Software Engineering Institute. doi : 10.1184/R1/6584825.v1 . {{ cite journal }} : Cite journal requires |journal= ( help ) ^ Humphrey, Watts (2005). TSP: Coaching Development Teams . Addison Wesley. ^ Carleton, Anita . \"Extending Team Software Process (TSP) to Systems Engineering: A NAVAIR Experience Report\" (PDF) . Software Engineering Institute. ^ Battle, Ed. \"Leading & Learning \u2013 Using TSP at the MSG Level\" (PDF) . Naval Oceanographic Office. ^ \"Software consulting: How to make sure the software consulting company you are looking for is reliable\" . Retrieved 23 April 2019 . ^ James McHale; Timothy A. Chick; Eugene Miluk (December 2010). \"Implementation Guidance for the Accelerated Improvement Method (AIM)\" (PDF) . Software Engineering Institute . Retrieved October 11, 2016 . ^ Webb, David (April 2007). \"CMMI Level 5 and the Team Software Process\" (PDF) . Cross Talk . Archived from the original on October 9, 2012. ^ Mondragon, Oscar. \"AIM Case Study\" (PDF) . Software Engineering Excellence Center. ^ Humphrey, Watts (2018). \"The Team Software Process Body of Knowledge\" . Software Engineering Institute. doi : 10.1184/R1/6584825.v1 . {{ cite journal }} : Cite journal requires |journal= ( help ) ^ Chick, Timothy (2010). \"Team Software Process (TSP) Coach Mentoring Program Guidebook Version 1.1\" . Software Engineering Institute. doi : 10.1184/R1/6584810.v1 . {{ cite journal }} : Cite journal requires |journal= ( help ) ^ Jones, Capers (2013). \"Evaluating ten software development methodologies\" . Archived from the original on 29 June 2013. External links [ edit ] TSP homepage Retrieved from \" https://en.wikipedia.org/w/index.php?title=Team_software_process&oldid=1324392589 \" Category : Software development process Hidden categories: Webarchive template wayback links CS1 errors: missing periodical Articles with short description Short description is different from Wikidata This page was last edited on 27 November 2025, at 09:15 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Team software process 7 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Test-driven_development",
    "title": "Test-driven development - Wikipedia",
    "content": "Test-driven development - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Coding cycle 3 Test-driven work 4 Development style Toggle Development style subsection 4.1 Code visibility 4.2 Test isolation 4.3 Keep the unit small 5 Best practices Toggle Best practices subsection 5.1 Test structure 5.2 Individual best practices 5.3 Practices to avoid, or \"anti-patterns\" 6 Comparison and demarcation Toggle Comparison and demarcation subsection 6.1 TDD and ATDD 6.2 TDD and BDD 7 Software for TDD Toggle Software for TDD subsection 7.1 xUnit frameworks 7.2 TAP results 8 TDD for complex systems Toggle TDD for complex systems subsection 8.1 Designing for testability 8.2 Managing tests for large teams 9 Advantages and Disadvantages Toggle Advantages and Disadvantages subsection 9.1 Advantages 9.2 Disadvantages 9.3 Benefits 9.4 Psychological benefits to programmer 9.5 Limitations 10 Conference 11 See also 12 References 13 External links Toggle the table of contents Test-driven development 29 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u010ce\u0161tina Deutsch Eesti \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Bahasa Indonesia Italiano \u05e2\u05d1\u05e8\u05d9\u05ea La .lojban. Magyar Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Sloven\u0161\u010dina Suomi Svenska T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Method of writing code Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Test-driven development ( TDD ) is a way of writing code that involves writing an automated unit-level test case that fails, then writing just enough code to make the test pass, then refactoring both the test code and the production code, then repeating with another new test case. Alternative approaches to writing automated tests is to write all of the production code before starting on the test code or to write all of the test code before starting on the production code. With TDD, both are written together, therefore shortening debugging time necessities. [ 1 ] TDD is related to the test-first programming concepts of extreme programming , begun in 1999, [ 2 ] but more recently has created more general interest in its own right. [ 3 ] Programmers also apply the concept to improving and debugging legacy code developed with older techniques. [ 4 ] History [ edit ] Software engineer Kent Beck , who is credited with having developed or \"rediscovered\" [ 5 ] the technique, stated in 2003 that TDD encourages simple designs and inspires confidence. [ 6 ] The original description of TDD was in an ancient book about programming. It said you take the input tape, manually type in the output tape you expect, then program until the actual output tape matches the expected output. After I'd written the first xUnit framework in Smalltalk I remembered reading this and tried it out. That was the origin of TDD for me. When describing TDD to older programmers, I often hear, \"Of course. How else could you program?\" Therefore I refer to my role as \"rediscovering\" TDD. \u2014 Kent Beck , \"Why does Kent Beck refer to the 'rediscovery' of test-driven development? What's the history of test-driven development before Kent Beck's rediscovery?\" [ 7 ] Coding cycle [ edit ] A graphical representation of the test-driven development lifecycle The TDD steps vary somewhat by author in count and description, but are generally as follows. These are based on the book Test-Driven Development by Example , [ 6 ] and Kent Beck's Canon TDD article. [ 8 ] 1. List scenarios for the new feature List the expected variants in the new behavior. \"There's the basic case & then what-if this service times out & what-if the key isn't in the database yet &\u2026\" The developer can discover these specifications by asking about use cases and user stories . A key benefit of TDD is that it makes the developer focus on requirements before writing code. This is in contrast with the usual practice, where unit tests are only written after code. 2. Write a test for an item on the list Write an automated test that would pass if the variant in the new behavior is met. 3. Run all tests. The new test should fail \u2013 for expected reasons This shows that new code is actually needed for the desired feature. It validates that the test harness is working correctly. It rules out the possibility that the new test is flawed and will always pass. 4. Write the simplest code that passes the new test Inelegant code and hard coding is acceptable. The code will be honed in Step 6. No code should be added beyond the tested functionality. 5. All tests should now pass If any fail, fix failing tests with minimal changes until all pass. 6. Refactor as needed while ensuring all tests continue to pass Code is refactored for readability and maintainability. In particular, hard-coded test data should be removed from the production code. Running the test suite after each refactor ensures that no existing functionality is broken. Examples of refactoring: moving code to where it most logically belongs removing duplicate code making names self-documenting splitting methods into smaller pieces re-arranging inheritance hierarchies Repeat Repeat the process, starting at step 2, with each test on the list until all tests are implemented and passing. Each tests should be small and commits made often. If new code fails some tests, the programmer can undo or revert rather than debug excessively. When using external libraries , it is important not to write tests that are so small as to effectively test merely the library itself, [ 3 ] unless there is some reason to believe that the library is buggy or not feature-rich enough to serve all the needs of the software under development. Test-driven work [ edit ] TDD has been adopted outside of software development, in both product and service teams, as test-driven work . [ 9 ] For testing to be successful, it needs to be practiced at the micro and macro levels. Every method in a class, every input data value, log message, and error code, amongst other data points, need to be tested. [ 10 ] Similar to TDD, non-software teams develop quality control (QC) checks (usually manual tests rather than automated tests) for each aspect of the work prior to commencing. These QC checks are then used to inform the design and validate the associated outcomes. The six steps of the TDD sequence are applied with minor semantic changes: \"Add a check\" replaces \"Add a test\" \"Run all checks\" replaces \"Run all tests\" \"Do the work\" replaces \"Write some code\" \"Run all checks\" replaces \"Run tests\" \"Clean up the work\" replaces \"Refactor code\" \"Repeat\" Development style [ edit ] There are various aspects to using test-driven development, for example the principles of \"keep it simple, stupid\" ( KISS ) and \" You aren't gonna need it \" (YAGNI). By focusing on writing only the code necessary to pass tests, designs can often be cleaner and clearer than is achieved by other methods. [ 6 ] In Test-Driven Development by Example , Kent Beck also suggests the principle \" Fake it till you make it \". To achieve some advanced design concept such as a design pattern , tests are written that generate that design. The code may remain simpler than the target pattern, but still pass all required tests. This can be unsettling at first but it allows the developer to focus only on what is important. Writing the tests first: The tests should be written before the functionality that is to be tested. This has been claimed to have many benefits. It helps ensure that the application is written for testability, as the developers must consider how to test the application from the outset rather than adding it later. It also ensures that tests for every feature gets written. Additionally, writing the tests first leads to a deeper and earlier understanding of the product requirements, ensures the effectiveness of the test code, and maintains a continual focus on software quality . [ 11 ] When writing feature-first code, there is a tendency by developers and organizations to push the developer on to the next feature, even neglecting testing entirely. The first TDD test might not even compile at first, because the classes and methods it requires may not yet exist. Nevertheless, that first test functions as the beginning of an executable specification. [ 12 ] Each test case fails initially: This ensures that the test really works and can catch an error. Once this is shown, the underlying functionality can be implemented. This has led to the \"test-driven development mantra\", which is \"red/green/refactor\", where red means fail and green means pass . Test-driven development constantly repeats the steps of adding test cases that fail, passing them, and refactoring. Receiving the expected test results at each stage reinforces the developer's mental model of the code, boosts confidence and increases productivity. Code visibility [ edit ] Main article: Unit_testing \u00a7\u00a0Code_Visibility In test-driven development, writing tests before implementation raises questions about testing private methods versus testing only through public interfaces . This choice affects the design of both test code and production code. Test isolation [ edit ] Test-driven development relies primarily on unit tests for its rapid red-green-refactor cycle. These tests execute quickly by avoiding process boundaries, network connections, or external dependencies. While TDD practitioners also write integration tests to verify component interactions, these slower tests are kept separate from the more frequent unit test runs. Testing multiple integrated modules together also makes it more difficult to identify the source of failures. When code under development relies on external dependencies, TDD encourages the use of test doubles to maintain fast, isolated unit tests. [ 13 ] The typical approach involves using interfaces to separate external dependencies and implementing test doubles for testing purposes. Since test doubles don't prove the connection to real external components, TDD practitioners supplement unit tests with integration testing at appropriate levels. To keep execution faster and more reliable, testing is maximized at the unit level while minimizing slower tests at higher levels. Keep the unit small [ edit ] For TDD, a unit is most commonly defined as a class, or a group of related functions often called a module. Keeping units relatively small is claimed to provide critical benefits, including: Reduced debugging effort \u2013 When test failures are detected, having smaller units aids in tracking down errors. Self-documenting tests \u2013 Small test cases are easier to read and to understand. [ 11 ] Advanced practices of test-driven development can lead to acceptance test\u2013driven development (ATDD) and specification by example where the criteria specified by the customer are automated into acceptance tests, which then drive the traditional unit test-driven development (UTDD) process. [ 14 ] This process ensures the customer has an automated mechanism to decide whether the software meets their requirements. With ATDD, the development team now has a specific target to satisfy \u2013 the acceptance tests \u2013 which keeps them continuously focused on what the customer really wants from each user story. Best practices [ edit ] Test structure [ edit ] Effective layout of a test case ensures all required actions are completed, improves the readability of the test case, and smooths the flow of execution. Consistent structure helps in building a self-documenting test case. A commonly applied structure for test cases has (1) setup, (2) execution, (3) validation, and (4) cleanup. Setup: Put the Unit Under Test (UUT) or the overall test system in the state needed to run the test. Execution: Trigger/drive the UUT to perform the target behavior and capture all output, such as return values and output parameters. This step is usually very simple. Validation: Ensure the results of the test are correct. These results may include explicit outputs captured during execution or state changes in the UUT. Cleanup: Restore the UUT or the overall test system to the pre-test state. This restoration permits another test to execute immediately after this one. In some cases, in order to preserve the information for possible test failure analysis, the cleanup should be starting the test just before the test's setup run. [ 11 ] Individual best practices [ edit ] Some best practices that an individual could follow would be to separate common set-up and tear-down logic into test support services utilized by the appropriate test cases, to keep each test oracle focused on only the results necessary to validate its test, and to design time-related tests to allow tolerance for execution in non-real time operating systems. The common practice of allowing a 5-10 percent margin for late execution reduces the potential number of false negatives in test execution. It is also suggested to treat test code with the same respect as production code. Test code must work correctly for both positive and negative cases, last a long time, and be readable and maintainable. Teams can get together and review tests and test practices to share effective techniques and catch bad habits. [ 15 ] Practices to avoid, or \"anti-patterns\" [ edit ] See also: Anti-pattern Having test cases depend on system state manipulated from previously executed test cases (i.e., you should always start a unit test from a known and pre-configured state). Dependencies between test cases.  A test suite where test cases are dependent upon each other is brittle and complex. Execution order should not be presumed. Basic refactoring of the initial test cases or structure of the UUT causes a spiral of increasingly pervasive impacts in associated tests. Interdependent tests.  Interdependent tests can cause cascading false negatives. A failure in an early test case breaks a later test case even if no actual fault exists in the UUT, increasing defect analysis and debug efforts. Testing precise execution, timing or performance. Building \"all-knowing oracles\".  An oracle that inspects more than necessary is more expensive and brittle over time. This very common error is dangerous because it causes a subtle but pervasive time sink across the complex project. [ 15 ] [ clarification needed ] Testing implementation details. Slow running tests. Comparison and demarcation [ edit ] TDD and ATDD [ edit ] Test-driven development is related to, but different from acceptance test\u2013driven development (ATDD). [ 16 ] TDD is primarily a developer's tool to help create well-written unit of code (function, class, or module) that correctly performs a set of operations. ATDD is a communication tool between the customer, developer, and tester to ensure that the requirements are well-defined. TDD requires test automation. ATDD does not, although automation helps with regression testing. Tests used in TDD can often be derived from ATDD tests, since the code units implement some portion of a requirement. ATDD tests should be readable by the customer. TDD tests do not need to be. TDD and BDD [ edit ] BDD ( behavior-driven development ) combines practices from TDD and from ATDD. [ 17 ] It includes the practice of writing tests first, but focuses on tests which describe behavior, rather than tests which test a unit of implementation.  Tools such as JBehave , Cucumber , Mspec and Specflow provide syntaxes which allow product owners, developers and test engineers to define together the behaviors which can then be translated into automated tests. Software for TDD [ edit ] There are many testing frameworks and tools that are useful in TDD. xUnit frameworks [ edit ] Developers may use computer-assisted testing frameworks , commonly collectively named xUnit (which are derived from SUnit, created in 1998), to create and automatically run the test cases. xUnit frameworks provide assertion-style test validation capabilities and result reporting. These capabilities are critical for automation as they move the burden of execution validation from an independent post-processing activity to one that is included in the test execution.  The execution framework provided by these test frameworks allows for the automatic execution of all system test cases or various subsets along with other features. [ 18 ] TAP results [ edit ] Testing frameworks may accept unit test output in the language-agnostic Test Anything Protocol created in 1987. TDD for complex systems [ edit ] Exercising TDD on large, challenging systems requires a modular architecture, well-defined components with published interfaces, and disciplined system layering with maximization of platform independence. These proven practices yield increased testability and facilitate the application of build and test automation. [ 11 ] Designing for testability [ edit ] Complex systems require an architecture that meets a range of requirements.  A key subset of these requirements includes support for the complete and effective testing of the system. Effective modular design yields components that share traits essential for effective TDD. High Cohesion ensures each unit provides a set of related capabilities and makes the tests of those capabilities easier to maintain. Low Coupling allows each unit to be effectively tested in isolation. Published Interfaces restrict Component access and serve as contact points for tests, facilitating test creation and ensuring the highest fidelity between test and production unit configuration. A key technique for building effective modular architecture is Scenario Modeling where a set of sequence charts is constructed, each one focusing on a single system-level execution scenario. The Scenario Model provides an excellent vehicle for creating the strategy of interactions between components in response to a specific stimulus. Each of these Scenario Models serves as a rich set of requirements for the services or functions that a component must provide, and it also dictates the order in which these components and services interact together. Scenario modeling can greatly facilitate the construction of TDD tests for a complex system. [ 11 ] Managing tests for large teams [ edit ] In a larger system, the impact of poor component quality is magnified by the complexity of interactions. This magnification makes the benefits of TDD accrue even faster in the context of larger projects. However, the complexity of the total population of tests can become a problem in itself, eroding potential gains. It sounds simple, but a key initial step is to recognize that test code is also important software and should be produced and maintained with the same rigor as the production code. Creating and managing the architecture of test software within a complex system is just as important as the core product architecture. Test drivers interact with the UUT, test doubles and the unit test framework. [ 11 ] Advantages and Disadvantages [ edit ] Advantages [ edit ] Test Driven Development (TDD) is a software development approach where tests are written before the actual code. It offers several advantages: Comprehensive Test Coverage : TDD ensures that all new code is covered by at least one test, leading to more robust software. Enhanced Confidence in Code : Developers gain greater confidence in the code's reliability and functionality. Enhanced Confidence in Tests : As the tests are known to be failing without the proper implementation, we know that the tests actually tests the implementation correctly. Well-Documented Code : The process naturally results in well-documented code, as each test clarifies the purpose of the code it tests. Requirement Clarity : TDD encourages a clear understanding of requirements before coding begins. Facilitates Continuous Integration : It integrates well with continuous integration processes, allowing for frequent code updates and testing. Boosts Productivity : Many developers find that TDD increases their productivity. Reinforces Code Mental Model : TDD helps in building a strong mental model of the code's structure and behavior. Emphasis on Design and Functionality : It encourages a focus on the design, interface, and overall functionality of the program. Reduces Need for Debugging : By catching issues early in the development process, TDD reduces the need for extensive debugging later. System Stability : Applications developed with TDD tend to be more stable and less prone to bugs. [ 19 ] Disadvantages [ edit ] However, TDD is not without its drawbacks: Increased Code Volume : Implementing TDD can result in a larger codebase as tests add to the total amount of code written. False Security from Tests : A large number of passing tests can sometimes give a misleading sense of security regarding the code's robustness. [ 20 ] Maintenance Overheads : Maintaining a large suite of tests can add overhead to the development process. Time-Consuming Test Processes : Writing and maintaining tests can be time-consuming. Testing Environment Set-Up : TDD requires setting up and maintaining a suitable testing environment. Learning Curve : It takes time and effort to become proficient in TDD practices. Overcomplication : Designing code to cater for complex tests via TDD can lead to code that is more complicated than necessary. Neglect of Overall Design : Focusing too narrowly on passing tests can sometimes lead to neglect of the bigger picture in software design. Benefits [ edit ] A 2005 study found that using TDD meant writing more tests and, in turn, programmers who wrote more tests tended to be more productive. [ 21 ] Hypotheses relating to code quality and a more direct correlation between TDD and productivity were inconclusive. [ 22 ] Programmers using pure TDD on new (\" greenfield \") projects reported they only rarely felt the need to invoke a debugger . Used in conjunction with a version control system , when tests fail unexpectedly, reverting the code to the last version that passed all tests may often be more productive than debugging. [ 23 ] Test-driven development offers more than just simple validation of correctness, but can also drive the design of a program. [ 24 ] By focusing on the test cases first, one must imagine how the functionality is used by clients (in the first case, the test cases). So, the programmer is concerned with the interface before the implementation. This benefit is complementary to design by contract as it approaches code through test cases rather than through mathematical assertions or preconceptions. Test-driven development offers the ability to take small steps when required. It allows a programmer to focus on the task at hand as the first goal is to make the test pass. Exceptional cases and error handling are not considered initially, and tests to create these extraneous circumstances are implemented separately. Test-driven development ensures in this way that all written code is covered by at least one test. This gives the programming team, and subsequent users, a greater level of confidence in the code. While it is true that more code is required with TDD than without TDD because of the unit test code, the total code implementation time could be shorter based on a model by M\u00fcller and Padberg. [ 25 ] Large numbers of tests help to limit the number of defects in the code. The early and frequent nature of the testing helps to catch defects early in the development cycle, preventing them from becoming endemic and expensive problems. Eliminating defects early in the process usually avoids lengthy and tedious debugging later in the project. TDD can lead to more modularized, flexible, and extensible code. This effect often comes about because the methodology requires that the developers think of the software in terms of small units that can be written and tested independently and integrated together later. This leads to smaller, more focused classes, looser coupling , and cleaner interfaces. The use of the mock object design pattern also contributes to the overall modularization of the code because this pattern requires that the code be written so that modules can be switched easily between mock versions for unit testing and \"real\" versions for deployment. Because no more code is written than necessary to pass a failing test case, automated tests tend to cover every code path. For example, for a TDD developer to add an else branch to an existing if statement, the developer would first have to write a failing test case that motivates the branch. As a result, the automated tests resulting from TDD tend to be very thorough: they detect any unexpected changes in the code's behaviour. This detects problems that can arise where a change later in the development cycle unexpectedly alters other functionality. Madeyski [ 26 ] provided empirical evidence (via a series of laboratory experiments with over 200 developers) regarding the superiority of the TDD practice over the traditional Test-Last approach or testing for correctness approach, with respect to the lower coupling between objects (CBO). The mean effect size represents a medium (but close to large) effect on the basis of meta-analysis of the performed experiments which is a substantial finding. It suggests a better modularization (i.e., a more modular design), easier reuse and testing of the developed software products due to the TDD programming practice. [ 26 ] Madeyski also measured the effect of the TDD practice on unit tests using branch coverage (BC) and mutation score indicator (MSI), [ 27 ] [ 28 ] [ 29 ] which are indicators of the thoroughness and the fault detection effectiveness of unit tests, respectively. The effect size of TDD on branch coverage was medium in size and therefore is considered substantive effect. [ 26 ] These findings have been subsequently confirmed by further, smaller experimental evaluations of TDD. [ 30 ] [ 31 ] [ 32 ] [ 33 ] Psychological benefits to programmer [ edit ] Increased Confidence : TDD allows programmers to make changes or add new features with confidence. Knowing that the code is constantly tested reduces the fear of breaking existing functionality. This safety net can encourage more innovative and creative approaches to problem-solving. Reduced Fear of Change, Reduced Stress : In traditional development, changing existing code can be daunting due to the risk of introducing bugs. TDD, with its comprehensive test suite, reduces this fear, as tests will immediately reveal any problems caused by changes. Knowing that the codebase has a safety net of tests can reduce stress and anxiety associated with programming. Developers might feel more relaxed and open to experimenting and refactoring. Improved Focus : Writing tests first helps programmers concentrate on requirements and design before writing the code. This focus can lead to clearer, more purposeful coding, as the developer is always aware of the goal they are trying to achieve. Sense of Achievement and Job Satisfaction : Passing tests can provide a quick, regular sense of accomplishment, boosting morale. This can be particularly motivating in long-term projects where the end goal might seem distant. The combination of all these factors can lead to increased job satisfaction. When developers feel confident, focused, and part of a collaborative team, their overall job satisfaction can significantly improve. Limitations [ edit ] This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. ( August 2013 ) ( Learn how and when to remove this message ) Test-driven development does not perform sufficient testing in situations where full functional tests are required to determine success or failure, due to extensive use of unit tests. [ 34 ] Examples of these are user interfaces , programs that work with databases , and some that depend on specific network configurations. TDD encourages developers to put the minimum amount of code into such modules and to maximize the logic that is in testable library code, using fakes and mocks to represent the outside world. [ 35 ] Management support is essential. Without the entire organization believing that test-driven development is going to improve the product, management may feel that time spent writing tests is wasted. [ 36 ] Unit tests created in a test-driven development environment are typically created by the developer who is writing the code being tested. Therefore, the tests may share blind spots with the code: if, for example, a developer does not realize that certain input parameters must be checked, most likely neither the test nor the code will verify those parameters. Another example: if the developer misinterprets the requirements for the module they are developing, the code and the unit tests they write will both be wrong in the same way. Therefore, the tests will pass, giving a false sense of correctness. A high number of passing unit tests may bring a false sense of security, resulting in fewer additional software testing activities, such as integration testing and compliance testing . Tests become part of the maintenance overhead of a project. Badly written tests, for example ones that include hard-coded error strings, are themselves prone to failure, and they are expensive to maintain. This is especially the case with fragile tests . [ 37 ] There is a risk that tests that regularly generate false failures will be ignored, so that when a real failure occurs, it may not be detected. It is possible to write tests for low and easy maintenance, for example by the reuse of error strings, and this should be a goal during the code refactoring phase described above. Writing and maintaining an excessive number of tests costs time. Also, more-flexible modules (with limited tests) might accept new requirements without the need for changing the tests. For those reasons, testing for only extreme conditions, or a small sample of data, can be easier to adjust than a set of highly detailed tests. The level of coverage and testing detail achieved during repeated TDD cycles cannot easily be re-created at a later date. Therefore, these original, or early, tests become increasingly precious as time goes by. The tactic is to fix it early. Also, if a poor architecture, a poor design, or a poor testing strategy leads to a late change that makes dozens of existing tests fail, then it is important that they are individually fixed. Merely deleting, disabling or rashly altering them can lead to undetectable holes in the test coverage. Conference [ edit ] First TDD Conference was held during July 2021. [ 38 ] Conferences were recorded on YouTube [ 39 ] See also [ edit ] Acceptance testing Behavior-driven development Design by contract Inductive programming Integration testing List of software development philosophies List of unit testing frameworks Mock object Programming by example Sanity check Self-testing code Software testing Transformation Priority Premise Unit testing Continuous test-driven development References [ edit ] ^ Parsa, Saeed; Zakeri-Nasrabadi, Morteza; Turhan, Burak (2025-01-01). \"Testability-driven development: An improvement to the TDD efficiency\" . Computer Standards & Interfaces . 91 103877. doi : 10.1016/j.csi.2024.103877 . ISSN 0920-5489 . ^ Lee Copeland (December 2001). \"Extreme Programming\" . Computerworld. Archived from the original on June 5, 2011 . Retrieved January 11, 2011 . ^ a b Newkirk, JW and Vorontsov, AA. Test-Driven Development in Microsoft .NET , Microsoft Press, 2004. ^ Feathers, M. Working Effectively with Legacy Code, Prentice Hall, 2004 ^ Kent Beck (May 11, 2012). \"Why does Kent Beck refer to the \"rediscovery\" of test-driven development?\" . Retrieved December 1, 2014 . ^ a b c Beck, Kent (2002-11-08). Test-Driven Development by Example . Vaseem: Addison Wesley. ISBN 978-0-321-14653-3 . ^ Kent Beck (May 11, 2012). \"Why does Kent Beck refer to the \"rediscovery\" of test-driven development?\" . Retrieved December 1, 2014 . ^ Beck, Kent (2023-12-11). \"Canon TDD\" . Software Design: Tidy First? . Retrieved 2024-10-22 . ^ Leybourn, E. (2013) Directing the Agile Organisation: A Lean Approach to Business Management . London: IT Governance Publishing: 176-179. ^ Mohan, Gayathri. \"Full Stack Testing\" . www.thoughtworks.com . Retrieved 2022-09-07 . ^ a b c d e f \"Effective TDD for Complex Embedded Systems Whitepaper\" (PDF) . Pathfinder Solutions. Archived from the original (PDF) on 2016-03-16. ^ \"Agile Test Driven Development\" . Agile Sherpa. 2010-08-03. Archived from the original on 2012-07-23 . Retrieved 2012-08-14 . ^ Fowler, Martin (1999). Refactoring - Improving the design of existing code . Boston: Addison Wesley Longman, Inc. ISBN 0-201-48567-2 . ^ Koskela, L. \"Test Driven: TDD and Acceptance TDD for Java Developers\", Manning Publications, 2007 ^ a b Test-Driven Development (TDD) for Complex Systems Introduction on YouTube by Pathfinder Solutions ^ Lean-Agile Acceptance Test-Driven Development: Better Software Through Collaboration . Boston: Addison Wesley Professional. 2011. ISBN 978-0-321-71408-4 . ^ \"BDD\" . Archived from the original on 2015-05-08 . Retrieved 2015-04-28 . ^ \"Effective TDD for Complex, Embedded Systems Whitepaper\" . Pathfinder Solutions. Archived from the original on 2013-08-20 . Retrieved 2012-11-27 . ^ Advantages and Disadvantages of Test Driven Development - LASOFT ^ Parsa, Saeed; Zakeri-Nasrabadi, Morteza; Turhan, Burak (2025-01-01). \"Testability-driven development: An improvement to the TDD efficiency\" . Computer Standards & Interfaces . 91 103877. doi : 10.1016/j.csi.2024.103877 . ISSN 0920-5489 . ^ Erdogmus, Hakan; Morisio, Torchiano. \"On the Effectiveness of Test-first Approach to Programming\" . Proceedings of the IEEE Transactions on Software Engineering, 31(1). January 2005. (NRC 47445). Archived from the original on 2014-12-22 . Retrieved 2008-01-14 . We found that test-first students on average wrote more tests and, in turn, students who wrote more tests tended to be more productive. ^ Proffitt, Jacob. \"TDD Proven Effective! Or is it?\" . Archived from the original on 2008-02-06 . Retrieved 2008-02-21 . So TDD's relationship to quality is problematic at best. Its relationship to productivity is more interesting. I hope there's a follow-up study because the productivity numbers simply don't add up very well to me. There is an undeniable correlation between productivity and the number of tests, but that correlation is actually stronger in the non-TDD group (which had a single outlier compared to roughly half of the TDD group being outside the 95% band). ^ Llopis, Noel (20 February 2005). \"Stepping Through the Looking Glass: Test-Driven Game Development (Part 1)\" . Games from Within . Retrieved 2007-11-01 . Comparing [TDD] to the non-test-driven development approach, you're replacing all the mental checking and debugger stepping with code that verifies that your program does exactly what you intended it to do. ^ Mayr, Herwig (2005). Projekt Engineering Ingenieurm\u00e4ssige Softwareentwicklung in Projektgruppen (2., neu bearb. Aufl.\u00a0ed.). M\u00fcnchen: Fachbuchverl. Leipzig im Carl-Hanser-Verl. p.\u00a0239. ISBN 978-3-446-40070-2 . ^ M\u00fcller, Matthias M.; Padberg, Frank. \"About the Return on Investment of Test-Driven Development\" (PDF) . Universit\u00e4t Karlsruhe, Germany. p.\u00a06. S2CID 13905442 . Archived from the original (PDF) on 2017-11-08 . Retrieved 2012-06-14 . ^ a b c Madeyski, L. \"Test-Driven Development - An Empirical Evaluation of Agile Practice\", Springer, 2010, ISBN 978-3-642-04287-4 , pp. 1-245. DOI: 978-3-642-04288-1 ^ The impact of Test-First programming on branch coverage and mutation score indicator of unit tests: An experiment. by L. Madeyski Information & Software Technology 52(2): 169-184 (2010) ^ On the Effects of Pair Programming on Thoroughness and Fault-Finding Effectiveness of Unit Tests by L. Madeyski PROFES 2007: 207-221 ^ Impact of pair programming on thoroughness and fault detection effectiveness of unit test suites. by L. Madeyski Software Process: Improvement and Practice 13(3): 281-295 (2008) ^ M. Pan\u010dur and M. Ciglari\u010d, \"Impact of test-driven development on productivity, code and tests: A controlled experiment\", Information and Software Technology, 2011, vol. 53, no. 6, pp. 557\u2013573, DOI: 10.1016/j.infsof.2011.02.002 ^ D. Fucci, H. Erdogmus, B. Turhan, M. Oivo, and N. Juristo, \"A dissection of the test-driven development process: does it really matter to test-first or to test-last?\", IEEE Transactions on Software Engineering, 2017, vol. 43, no. 7, pp. 597\u2013614, DOI: 10.1109/TSE.2016.2616877 ^ A. Tosun, O. Dieste Tubio, D. Fucci, S. Vegas, B. Turhan, H. Erdogmus, A. Santos, M. Oivo, K. Toro, J. Jarvinen, and N. Juristo, \"An industry experiment on the effects of test-driven development on external quality and productivity\", Empirical Software Engineering, 2016, vol. 22, pp. 1\u201343, DOI: 10.1007/s10664-016-9490-0 ^ B. Papis, K. Grochowski, K. Subzda and K. Sijko, \"Experimental evaluation of test-driven development with interns working on a real industrial project\" , IEEE Transactions on Software Engineering, 2020, DOI: 10.1109/TSE.2020.3027522 ^ \"Problems with TDD\" . Dalkescientific.com. 2009-12-29 . Retrieved 2014-03-25 . ^ Hunter, Andrew (2012-10-19). \"Are Unit Tests Overused?\" . Simple Talk . Simple-talk.com . Retrieved 2014-03-25 . ^ Loughran, Steve (November 6, 2006). \"Testing\" (PDF) . HP Laboratories. Archived from the original (PDF) on 2009-02-20 . Retrieved 2009-08-12 . ^ \"Fragile Tests\" . ^ Bunardzic, Alex. \"First International Test Driven Development (TDD) Conference\" . TDD Conference . Retrieved 2021-07-20 . ^ First International TDD Conference - Saturday July 10, 2021 , 10 July 2021, archived from the original on 2021-12-21 , retrieved 2021-07-20 External links [ edit ] TestDrivenDevelopment on WikiWikiWeb Bertrand Meyer (September 2004). \"Test or spec? Test and spec? Test from spec!\" . Archived from the original on 2005-02-09. Microsoft Visual Studio Team Test from a TDD approach Write Maintainable Unit Tests That Will Save You Time And Tears Improving Application Quality Using Test-Driven Development (TDD) Test Driven Development Conference Retrieved from \" https://en.wikipedia.org/w/index.php?title=Test-driven_development&oldid=1314699862 \" Categories : Extreme programming Software development philosophies Software development process Software testing Hidden categories: Articles with short description Short description is different from Wikidata Wikipedia articles needing clarification from February 2022 Articles needing additional references from August 2013 All articles needing additional references This page was last edited on 2 October 2025, at 20:32 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Test-driven development 29 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Extreme_programming",
    "title": "Extreme programming - Wikipedia",
    "content": "Extreme programming - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History Toggle History subsection 1.1 Origins 2 Concept Toggle Concept subsection 2.1 Goals 2.2 Activities 2.2.1 Coding 2.2.2 Testing 2.2.3 Listening 2.2.4 Designing 2.3 Values 2.3.1 Communication 2.3.2 Simplicity 2.3.3 Feedback 2.3.4 Courage 2.3.5 Respect 2.4 Rules 2.5 Principles 2.5.1 Feedback 2.5.2 Assuming simplicity 2.5.3 Embracing change 3 Practices Toggle Practices subsection 3.1 Fine-scale feedback 3.2 Continuous process 3.3 Shared understanding 3.4 Programmer welfare 4 Controversial aspects Toggle Controversial aspects subsection 4.1 Scalability 4.2 Severability and responses 5 Criticism 6 See also 7 References 8 Further reading 9 External links Toggle the table of contents Extreme programming 38 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Az\u0259rbaycanca \u0411\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f (\u0442\u0430\u0440\u0430\u0448\u043a\u0435\u0432\u0456\u0446\u0430) \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u010ce\u0161tina Dansk Deutsch Eesti Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais Galego \ud55c\uad6d\uc5b4 \u0939\u093f\u0928\u094d\u0926\u0940 Bahasa Indonesia Interlingua Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Lietuvi\u0173 Magyar Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Srpskohrvatski / \u0441\u0440\u043f\u0441\u043a\u043e\u0445\u0440\u0432\u0430\u0442\u0441\u043a\u0438 Suomi Svenska \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikiquote Wikiversity Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Software development methodology Planning and feedback loops in extreme programming Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Extreme programming ( XP ) is a software development methodology intended to improve software quality and responsiveness to changing customer requirements. As a type of agile software development , [ 1 ] [ 2 ] [ 3 ] it advocates frequent releases in short development cycles, intended to improve productivity and introduce checkpoints at which new customer requirements can be adopted. Other elements of extreme programming include programming in pairs or doing extensive code review , unit testing of all code, not programming features until they are actually needed , a flat management structure, code simplicity and clarity, expecting changes in the customer's requirements as time passes and the problem is better understood, and frequent communication with the customer and among programmers. [ 2 ] [ 3 ] [ 4 ] The methodology takes its name from the idea that the beneficial elements of traditional software engineering practices are taken to \"extreme\" levels. As an example, code reviews are considered a beneficial practice; taken to the extreme, code can be reviewed continuously (i.e. the practice of pair programming ). History [ edit ] Kent Beck developed extreme programming during his work on the Chrysler Comprehensive Compensation System (C3) payroll project . [ 5 ] Beck became the C3 project leader in March 1996. He began to refine the development methodology used in the project and wrote a book on the methodology ( Extreme Programming Explained , published in October 1999). [ 5 ] Chrysler cancelled the C3 project in February 2000, after seven years, when Daimler-Benz acquired the company. [ 6 ] Ward Cunningham was another major influence on XP. Many extreme-programming practices have been around for some time; the methodology takes \" best practices \" to extreme levels. For example, the \"practice of test-first development, planning and writing tests before each micro-increment\" was used as early as NASA's Project Mercury , in the early 1960s. [ 7 ] To shorten the total development time, some formal test documents (such as for acceptance testing ) have been developed in parallel with (or shortly before) the software being ready for testing. A NASA independent test group can write the test procedures, based on formal requirements and logical limits, before programmers write the software and integrate it with the hardware. XP takes this concept to the extreme level, writing automated tests (sometimes inside software modules) which validate the operation of even small sections of software coding, rather than only testing the larger features. Origins [ edit ] Two major influences shaped software development in the 1990s: Internally, object-oriented programming replaced procedural programming as the programming paradigm favored by some developers. Externally, the rise of the Internet and the dot-com boom emphasized speed-to-market and company growth as competitive business factors. Rapidly changing requirements demanded shorter product life-cycles , and often clashed with traditional methods of software development. The Chrysler Comprehensive Compensation System (C3) started in order to determine the best way to use object technologies, using the payroll systems at Chrysler as the object of research, with Smalltalk as the language and GemStone as the data access layer . Chrysler brought in Kent Beck , [ 5 ] a prominent Smalltalk practitioner, to do performance tuning on the system, but his role expanded as he noted several problems with the development process. He took this opportunity to propose and implement some changes in development practices - based on his work with his frequent collaborator, Ward Cunningham . Beck describes the early conception of the methods: [ 8 ] The first time I was asked to lead a team, I asked them to do a little bit of the things I thought were sensible, like testing and reviews. The second time there was a lot more on the line. I thought, \"Damn the torpedoes, at least this will make a good article,\" [and] asked the team to crank up all the knobs to 10 on the things I thought were essential and leave out everything else. Beck invited Ron Jeffries to the project to help develop and refine these methods. Jeffries thereafter acted as a coach to instill the practices as habits in the C3 team. Information about the principles and practices behind XP disseminated to the wider world through discussions on the original wiki , Cunningham's WikiWikiWeb . Various contributors discussed and expanded upon the ideas, and some spin-off methodologies resulted (see agile software development ). Also, XP concepts have been explained, for several years, using a hypertext system map on the XP website at http://www.extremeprogramming.org c. 1999 . Beck edited a series of books on XP, beginning with his own Extreme Programming Explained (1999, ISBN 0-201-61641-6 ), spreading his ideas to a much larger audience. Authors in the series went through various aspects attending XP and its practices. The series included a book critical of the practices. Concept [ edit ] This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. ( February 2025 ) ( Learn how and when to remove this message ) Goals [ edit ] Extreme Programming Explained describes extreme programming as a software-development discipline that organizes people to produce higher-quality software more productively. XP attempts to reduce the cost of changes in requirements by having multiple short development cycles, rather than a long one.\nIn this doctrine, changes are a natural, inescapable and desirable aspect of software-development projects, and should be planned for, instead of attempting to define a stable set of requirements. Extreme programming also introduces a number of basic values, principles and practices on top of the agile methodology. Activities [ edit ] XP describes four basic activities that are performed within the software development process: coding, testing, listening, and designing. Each of those activities is described below. Coding [ edit ] The advocates of XP argue that the only truly important product of the system development process is code \u2013 software instructions that a computer can interpret. Without code, there is no working product. Coding can be used to figure out the most suitable solution. Coding can also help to communicate thoughts about programming problems. A programmer dealing with a complex programming problem, or finding it hard to explain the solution to fellow programmers, might code it in a simplified manner and use the code to demonstrate what they mean. Code, say the proponents of this position, is always clear and concise and cannot be interpreted in more than one way. Other programmers can give feedback on this code by also coding their thoughts. Testing [ edit ] Main article: Test-driven development Testing is central to extreme programming. [ 9 ] Extreme programming's approach is that if a little testing can eliminate a few flaws, a lot of testing can eliminate many more flaws. Unit tests determine whether a given feature works as intended. Programmers write as many automated tests as they can think of that might \"break\" the code; if all tests run successfully, then the coding is complete. Every piece of code that is written is tested before moving on to the next feature. Acceptance tests verify that the requirements as understood by the programmers satisfy the customer's actual requirements. System-wide integration testing was encouraged, initially, as a daily end-of-day activity, for early detection of incompatible interfaces, to reconnect before the separate sections diverged widely from coherent functionality. However, system-wide integration testing has been reduced, to weekly, or less often, depending on the stability of the overall interfaces in the system. [ citation needed ] Listening [ edit ] Programmers must listen to what the customers need the system to do, what \" business logic \" is needed. They must understand these needs well enough to give the customer feedback about the technical aspects of how the problem might be solved, or cannot be solved. Communication between the customer and programmer is further addressed in the planning game . Designing [ edit ] From the point of view of simplicity, of course one could say that system development doesn't need more than coding, testing and listening. If those activities are performed well, the result should always be a system that works. In practice, this will not work. One can come a long way without designing but at a given time one will get stuck. The system becomes too complex and the dependencies within the system cease to be clear. One can avoid this by creating a design structure that organizes the logic in the system. Good design will avoid many dependencies within a system; this means that changing one part of the system will not affect other parts of the system. [ citation needed ] Values [ edit ] Extreme programming initially recognized four values in 1999: communication, simplicity, feedback, and courage. A new value, respect, was added in the second edition of Extreme Programming Explained . Those five values are described below. Communication [ edit ] Building software systems requires communicating system requirements to the developers of the system. In formal software development methodologies, this task is accomplished through documentation. Extreme programming techniques can be viewed as methods for rapidly building and disseminating institutional knowledge among members of a development team. The goal is to give all developers a shared view of the system which matches the view held by the users of the system. To this end, extreme programming favors simple designs, common metaphors, collaboration of users and programmers, frequent verbal communication, and feedback. Simplicity [ edit ] Extreme programming encourages starting with the simplest solution. Extra functionality can then be added later. The difference between this approach and more conventional system development methods is the focus on designing and coding for the needs of today instead of those of tomorrow, next week, or next month. This is sometimes summed up as the \" You aren't gonna need it \" (YAGNI) approach. [ 10 ] Proponents of XP acknowledge the disadvantage that this can sometimes entail more effort tomorrow to change the system; their claim is that this is more than compensated for by the advantage of not investing in possible future requirements that might change before they become relevant. Coding and designing for uncertain future requirements implies the risk of spending resources on something that might not be needed, while perhaps delaying crucial features. Related to the \"communication\" value, simplicity in design and coding should improve the quality of communication. A simple design with very simple code could be easily understood by most programmers in the team. Feedback [ edit ] Within extreme programming, feedback relates to different dimensions of the system development: Feedback from the system: by writing unit tests , [ 5 ] or running periodic integration tests, the programmers have direct feedback from the state of the system after implementing changes. Feedback from the customer: The functional tests (aka acceptance tests ) are written by the customer and the testers. They will get concrete feedback about the current state of their system. This review is planned once in every two or three weeks so the customer can easily steer the development. Feedback from the team: When customers come up with new requirements in the planning game the team directly gives an estimation of the time that it will take to implement. Feedback is closely related to communication and simplicity. Flaws in the system are easily communicated by writing a unit test that proves a certain piece of code will break. The direct feedback from the system tells programmers to recode this part. A customer is able to test the system periodically according to the functional requirements, known as user stories . [ 5 ] To quote Kent Beck , \"Optimism is an occupational hazard of programming. Feedback is the treatment.\" [ 11 ] Courage [ edit ] Several practices embody courage. One is the commandment to always design and code for today and not for tomorrow. This is an effort to avoid getting bogged down in design and requiring a lot of effort to implement anything else. Courage enables developers to feel comfortable with refactoring their code when necessary. [ 5 ] This means reviewing the existing system and modifying it so that future changes can be implemented more easily. Another example of courage is knowing when to throw code away: courage to remove source code that is obsolete, no matter how much effort was used to create that source code. Also, courage means persistence: a programmer might be stuck on a complex problem for an entire day, then solve the problem quickly the next day, but only if they are persistent. Respect [ edit ] The respect value includes respect for others as well as self-respect. Programmers should never commit changes that break compilation, that make existing unit-tests fail, or that otherwise delay the work of their peers. Members respect their own work by always striving for high quality and seeking for the best design for the solution at hand through refactoring. Adopting the four earlier values leads to respect gained from others in the team. Nobody on the team should feel unappreciated or ignored. This ensures a high level of motivation and encourages loyalty toward the team and toward the goal of the project. This value is dependent upon the other values, and is oriented toward teamwork. Rules [ edit ] The first version of rules for XP was published in 1999 by Don Wells [ 12 ] at the XP website. 29 rules are given in the categories of planning, managing, designing, coding, and testing. Planning, managing and designing are called out explicitly to counter claims that XP doesn't support those activities. Another version of XP rules was proposed by Ken Auer [ 13 ] in XP/Agile Universe 2003. He felt XP was defined by its rules, not its practices (which are subject to more variation and ambiguity). He defined two categories: \"Rules of Engagement\" which dictate the environment in which software development can take place effectively, and \"Rules of Play\" which define the minute-by-minute activities and rules within the framework of the Rules of Engagement. Here are some of the rules (incomplete): Coding The customer is always available Code the unit test first Only one pair integrates code at a time Leave optimization until last No overtime Testing All code must have unit tests All code must pass all unit tests before it can be released. When a bug is found, tests are created before the bug is addressed (a bug is not an error in logic; it is a test that was not written) Acceptance tests are run often and the results are published Principles [ edit ] The principles that form the basis of XP are based on the values just described and are intended to foster decisions in a system development project. The principles are intended to be more concrete than the values and more easily translated to guidance in a practical situation. Feedback [ edit ] Extreme programming sees feedback as most useful if it is done frequently and promptly. It stresses that minimal delay between an action and its feedback is critical to learning and making changes. Unlike traditional system development methods, contact with the customer occurs in more frequent iterations. The customer has clear insight into the system that is being developed, and can give feedback and steer the development as needed. With frequent feedback from the customer, a mistaken design decision made by the developer will be noticed and corrected quickly, before the developer spends much time implementing it. Unit tests contribute to the rapid feedback principle. When writing code, running the unit test provides direct feedback as to how the system reacts to the changes made. This includes running not only the unit tests that test the developer's code, but running in addition all unit tests against all the software, using an automated process that can be initiated by a single command. That way, if the developer's changes cause a failure in some other portion of the system that the developer knows little or nothing about, the automated all-unit-test suite will reveal the failure immediately, alerting the developer of the incompatibility of their change with other parts of the system, and the necessity of removing or modifying their change. Under traditional development practices, the absence of an automated, comprehensive unit-test suite meant that such a code change, assumed harmless by the developer, would have been left in place, appearing only during integration testing \u2013 or worse, only in production; and determining which code change caused the problem, among all the changes made by all the developers during the weeks or even months previous to integration testing, was a formidable task. Assuming simplicity [ edit ] This is about treating every problem as if its solution were \"extremely simple\". Traditional system development methods say to plan for the future and to code for reusability. Extreme programming rejects these ideas. The advocates of extreme programming say that making big changes all at once does not work. Extreme programming applies incremental changes: for example, a system might have small releases every three weeks. When many little steps are made, the customer has more control over the development process and the system that is being developed. Embracing change [ edit ] The principle of embracing change is about not working against changes but embracing them. For instance, if at one of the iterative meetings it appears that the customer's requirements have changed dramatically, programmers are to embrace this and plan the new requirements for the next iteration. Practices [ edit ] Further information: Extreme programming practices Extreme programming has been described as having 12 practices, grouped into four areas: Fine-scale feedback [ edit ] Pair programming [ 5 ] Planning game Test-driven development Whole team Continuous process [ edit ] Continuous integration Refactoring or design improvement [ 5 ] Small releases Shared understanding [ edit ] Coding standards Collective code ownership [ 5 ] Simple design [ 5 ] System metaphor Programmer welfare [ edit ] Sustainable pace Controversial aspects [ edit ] The practices in XP have been heavily debated. [ 5 ] Proponents of extreme programming claim that by having the on-site customer [ 5 ] request changes informally, the process becomes flexible, and saves the cost of formal overhead. Critics of XP claim this can lead to costly rework and project scope creep beyond what was previously agreed or funded. [ citation needed ] Change-control boards are a sign that there are potential conflicts in project objectives and constraints between multiple users. XP's expedited methods are somewhat dependent on programmers being able to assume a unified client viewpoint so the programmer can concentrate on coding, rather than documentation of compromise objectives and constraints. [ 14 ] This also applies when multiple programming organizations are involved, particularly organizations which compete for shares of projects. [ citation needed ] Other potentially controversial aspects of extreme programming include: Requirements are expressed as automated acceptance tests rather than specification documents. Requirements are defined incrementally, rather than trying to get them all in advance. Software developers are usually required to work in pairs. There is no big design up front . Most of the design activity takes place on the fly and incrementally, starting with \"the simplest thing that could possibly work\" and adding complexity only when it's required by failing tests. Critics characterize this as \" debugging a system into appearance\" and fear this will result in more re-design effort than only re-designing when requirements change. A customer representative is attached to the project. This role can become a single-point-of-failure for the project, and some people have found it to be a source of stress. Also, there is the danger of micro-management by a non-technical representative trying to dictate the use of technical software features and architecture. Critics have noted several potential drawbacks, [ 5 ] including problems with unstable requirements, no documented compromises of user conflicts, and a lack of an overall design specification or document. Scalability [ edit ] Thoughtworks has claimed reasonable success on distributed XP projects with up to sixty people. [ citation needed ] In 2004, industrial extreme programming (IXP) [ 15 ] was introduced as an evolution of XP. It is intended to bring the ability to work in large and distributed teams. It now has 23 practices and flexible values. Severability and responses [ edit ] In 2003, Matt Stephens and Doug Rosenberg published Extreme Programming Refactored: The Case Against XP , which questioned the value of the XP process and suggested ways in which it could be improved. [ 6 ] This triggered a lengthy debate in articles, Internet newsgroups, and web-site chat areas. The core argument of the book is that XP's practices are interdependent but that few practical organizations are willing/able to adopt all the practices; therefore the entire process fails. The book also makes other criticisms, and it draws a likeness of XP's \"collective ownership\" model to socialism in a negative manner. Certain aspects of XP have changed since the publication of Extreme Programming Refactored ; in particular, XP now accommodates modifications to the practices as long as the required objectives are still met. XP also uses increasingly generic terms for processes. Some argue that these changes invalidate previous criticisms; others claim that this is simply watering the process down. Other authors have tried to reconcile XP with the older methodologies in order to form a unified methodology. Some of these XP sought to replace, such as the waterfall methodology ; example Project Lifecycles: Waterfall , Rapid Application Development (RAD), etc. JPMorgan Chase & Co. tried combining XP with the computer programming methods of capability maturity model integration (CMMI), and Six Sigma . They found that the three systems reinforced each other well, leading to better development, and did not mutually contradict. [ 16 ] Criticism [ edit ] Extreme programming's initial buzz and controversial tenets, such as pair programming and continuous design , have attracted particular criticisms, such as the ones coming from McBreen, [ 17 ] Boehm and Turner, [ 18 ] Matt Stephens and Doug Rosenberg. [ 19 ] Many of the criticisms, however, are believed by Agile practitioners to be misunderstandings of agile development. [ 20 ] In particular, extreme programming has been reviewed and critiqued by Matt Stephens's and Doug Rosenberg's Extreme Programming Refactored . [ 6 ] See also [ edit ] Agile software development Continuous obsolescence EXtreme Manufacturing Extreme project management Extreme programming practices Kaizen List of software development philosophies Pair programming Scrum (development) Software craftsmanship Stand-up meeting Timeboxing References [ edit ] ^ \"Human Centred Technology Workshop 2006 \", 2006, PDF, Human Centred Technology Workshop 2006 ^ a b UPenn-Lectures-design-patterns \"Design Patterns and Refactoring\", University of Pennsylvania, 2003 Archived August 2, 2010, at the Wayback Machine . ^ a b USFCA-edu-601-lecture Extreme Programming . ^ \"Manifesto for Agile Software Development\" . Agilemanifesto.org. 2001 . Retrieved March 26, 2019 . ^ a b c d e f g h i j k l m Computerworld-appdev-92 \"Extreme Programming\", Computerworld (online), December 2001 . ^ a b c Rosenberg, Doug; Stephens, Matt (2003). Extreme Programming Refactored: The Case Against XP . Apress. ISBN 978-1-59059-096-6 . ^ Larman & Basili 2003 . ^ Interview with Kent Beck and Martin Fowler . March 23, 2001. {{ cite book }} : |work= ignored ( help ) ^ Lisa Crispin; Tip House (2003). Testing Extreme Programming . Addison-Wesley Professional. ISBN 9780321113559 . ^ \"Everyone's a Programmer\" by Clair Tristram. Technology Review , November 2003. p. 39. ^ Beck, K. (1999). Extreme Programming Explained: Embrace Change . Addison-Wesley. ISBN 978-0-321-27865-4 . ^ \"Extreme Programming Rules\" . extremeprogramming.org . ^ Ken Auer Archived September 20, 2008, at the Wayback Machine ^ John Carroll; David Morris (July 29, 2015). Agile Project Management in easy steps, 2nd edition . In Easy Steps. p.\u00a0162. ISBN 978-1-84078-703-0 . ^ Cutter Consortium. \"Industrial XP: Making XP Work in Large Organizations - Cutter Consortium\" . cutter.com . ^ Extreme Programming (XP) Six Sigma CMMI . ^ McBreen, P. (2003). Questioning Extreme Programming . Boston, MA: Addison-Wesley. ISBN 978-0-201-84457-3 . ^ Boehm, B. ; R. Turner (2004). Balancing Agility and Discipline: A Guide for the Perplexed . Boston, MA: Addison-Wesley. ISBN 978-0-321-18612-6 . ^ Stephens, Matt ; Doug Rosenberg (2004). The irony of extreme programming . MA: Dr Dobbs journal. {{ cite book }} : |work= ignored ( help ) ^ sdmagazine Archived March 16, 2006, at the Wayback Machine Further reading [ edit ] Ken Auer and Roy Miller. Extreme Programming Applied: Playing To Win , Addison\u2013Wesley. Ken Auer; Ron Jeffries ; Jeff Canna; Glen B. Alleman; Lisa Crispin; Janet Gregory (2002). \"Are Testers eXtinct? How Can Testers Contribute to XP Teams?\". Extreme Programming and Agile Methods \u2014 XP/Agile Universe 2002 . Lecture Notes in Computer Science. Vol.\u00a02418. Springer-Verlag. p.\u00a0287. doi : 10.1007/3-540-45672-4_50 . ISBN 978-3-540-44024-6 . Kent Beck : Extreme Programming Explained: Embrace Change , Addison\u2013Wesley. First edition, 1999. Second edition, with Cynthia Andres, 2004. Kent Beck and Martin Fowler : Planning Extreme Programming , Addison\u2013Wesley. Alistair Cockburn : Agile Software Development , Addison\u2013Wesley. Martin Fowler : Refactoring: Improving the Design of Existing Code .With Kent Beck, John Brant, William Opdyke, and Don Roberts (1999). Addison-Wesley. Harvey Herela (2005). Case Study: The Chrysler Comprehensive Compensation System . Galen Lab, U.C. Irvine. Jim Highsmith . Agile Software Development Ecosystems , Addison\u2013Wesley. Ron Jeffries , Ann Anderson and Chet Hendrickson (2000), Extreme Programming Installed , Addison\u2013Wesley. Larman, C. ; Basili, V.R. (June 2003). \"Iterative and incremental developments. a brief history\" (PDF) . Computer . 36 (6): 47\u2013 56. doi : 10.1109/MC.2003.1204375 . Matt Stephens and Doug Rosenberg (2003). Extreme Programming Refactored: The Case Against XP , Apress. Waldner, JB. (2008). \"Nanocomputers and Swarm Intelligence\". In: ISTE, 225\u2013256. External links [ edit ] Wikimedia Commons has media related to Extreme programming . Wikiquote has quotations related to Extreme programming . A gentle introduction Industrial eXtreme Programming Problems and Solutions to XP implementation Using an Agile Software Process with Offshore Development \u2013 ThoughtWorks ' experiences with implementing XP in large distributed projects v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Authority control databases International GND National United States France BnF data Czech Republic Spain Israel Other Yale LUX Retrieved from \" https://en.wikipedia.org/w/index.php?title=Extreme_programming&oldid=1324872920 \" Categories : Extreme programming Software development philosophies Agile software development Hidden categories: Webarchive template wayback links CS1 errors: periodical ignored Articles with short description Short description is different from Wikidata Use mdy dates from May 2021 Articles needing additional references from February 2025 All articles needing additional references All articles with unsourced statements Articles with unsourced statements from January 2013 Articles with unsourced statements from June 2009 Articles with unsourced statements from February 2020 Articles with unsourced statements from July 2008 Articles with unsourced statements from August 2009 Commons category link is on Wikidata This page was last edited on 30 November 2025, at 00:38 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Extreme programming 38 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Unified_process",
    "title": "Unified process - Wikipedia",
    "content": "Unified process - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Overview 2 Unified process characteristics Toggle Unified process characteristics subsection 2.1 Iterative and incremental 2.2 Architecture-centric 2.3 Risk-focused 2.4 Use case driven 3 Project lifecycle (phases of unified process) Toggle Project lifecycle (phases of unified process) subsection 3.1 Inception phase 3.2 Elaboration phase 3.3 Construction phase 3.4 Transition phase 4 Refinements and variations 5 References Toggle the table of contents Unified process 14 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 Dansk Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Bahasa Indonesia \u05e2\u05d1\u05e8\u05d9\u05ea Magyar \u65e5\u672c\u8a9e Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Object oriented software development process framework This article includes a list of references , related reading , or external links , but its sources remain unclear because it lacks inline citations . Please help improve this article by introducing more precise citations. ( November 2017 ) ( Learn how and when to remove this message ) Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Profile of a typical project showing the relative sizes of the four phases of the Unified Process. The unified software development process or unified process is an iterative and incremental software development process framework.  The best-known and extensively documented refinement of the unified process is the rational unified process (RUP). Other examples are OpenUP and agile unified process . Overview [ edit ] The unified process is not simply a process, but rather an extensible framework which should be customized for specific organizations or projects.  The rational unified process is, similarly, a customizable framework.  As a result, it is often impossible to say whether a refinement of the process was derived from UP or from RUP, and so the names tend to be used interchangeably. The name unified process as opposed to rational unified process is generally used to describe the generic process, including those elements which are common to most refinements.  The unified process name is also used to avoid potential issues of trademark infringement since Rational Unified Process and RUP are trademarks of IBM .  The first book to describe the process was titled The Unified Software Development Process ( ISBN 0-201-57169-2 ) and published in 1999 by Ivar Jacobson , Grady Booch and James Rumbaugh .  Since then various authors unaffiliated with Rational Software have published books and articles using the name Unified Process , whereas authors affiliated with Rational Software have favored the name Rational Unified Process . In 2012 the disciplined agile delivery framework was released, a hybrid framework that adopts and extends strategies from unified process, scrum , extreme programming , and other methods. Unified process characteristics [ edit ] Iterative and incremental [ edit ] Diagram illustrating how the relative emphasis of different disciplines changes over the course of the project. The unified process is an iterative and incremental development process. The elaboration, construction and transition phases are divided into a series of timeboxed iterations. (The inception phase may also be divided into iterations for a large project.) Each iteration results in an increment , which is a release of the system that contains added or improved functionality compared with the previous release. Although most iterations will include work in most of the process disciplines ( e.g. requirements, design, implementation, testing) the relative effort and emphasis will change over the course of the project. Architecture-centric [ edit ] The unified process insists that architecture sits at the heart of the project team's efforts to shape the system. Since no single model is sufficient to cover all aspects of a system, the unified process supports multiple architectural models and views. One of the most important deliverables of the process is the executable architecture baseline which is created during the elaboration phase. This partial implementation of the system serves to validate the architecture and act as a foundation for remaining development. Risk-focused [ edit ] The unified process requires the project team to focus on addressing the most critical risks early in the project life cycle. The deliverables of each iteration, especially in the elaboration phase, must be selected in order to ensure that the greatest risks are addressed first. Use case driven [ edit ] Use cases are the primary modeling tools to define the system functionalities. It also acts as straightforward communication means for technical and non-technical team members. Project lifecycle (phases of unified process) [ edit ] The unified process divides the project into four phases: Inception Elaboration (milestone) Construction (release) Transition (final production release) Each phase will generally contain multiple iterations (named I1, E1, E2, C1, etc. in the UP phase illustration). The exact number of iterations in each phase depends on the scale and nature of the project. The UP phase illustration here contains exactly 1, 2, 4 and 2 iterations in the four phases, but this is merely an example of how a specific project could look. Inception phase [ edit ] Inception is the smallest phase in the project, and ideally, it should be quite short. If the inception phase is long then it may be an indication of excessive up-front specification, which is contrary to the spirit of the unified process. Develop an approximate vision of the system, make the business case, define the scope, and produce a rough cost estimate and project schedule. Elaboration phase [ edit ] During the elaboration phase, the project team is expected to capture a healthy majority of the system requirements. However, the primary goals of Elaboration are to address known risk factors and to establish and validate the system architecture. Common processes undertaken in this phase include the creation of use case diagrams , conceptual diagrams ( class diagrams with only basic notation) and package diagrams (architectural diagrams). The architecture is validated primarily through the implementation of an executable architecture baseline. This is a partial implementation of the system which includes the core most architecturally significant components. It is built in a series of small time-boxed iterations. By the end of the elaboration phase, the system architecture must have stabilized and the executable architecture baseline must demonstrate that the architecture will support the key system functionality and exhibit the right behavior in terms of performance, scalability, and cost. The final elaboration phase deliverable is a plan (including cost and schedule estimates) for the construction phase. At this point the plan should be accurate and credible since it should be based on the elaboration phase experience and since significant risk factors should have been addressed during the elaboration phase. Construction phase [ edit ] Construction is the largest phase of the project. In this phase, the remainder of the system is built on the foundation laid in elaboration. System features are implemented in a series of short, time-boxed iterations. Each iteration results in an executable release of the software. It is customary to write full-text use cases during the construction phase and each one becomes the start of a new iteration. Common Unified Modeling Language (UML) diagrams used during this phase include activity diagrams , sequence diagrams , collaboration diagrams , state transition diagrams and interaction overview diagrams . Iterative implementation for the lower risks and easier elements are done. The final construction phase deliverable is software ready to be deployed in the transition phase. Transition phase [ edit ] The final project phase is transition. In this phase the system is deployed to the target users. Feedback received from an initial release (or initial releases) may result in further refinements to be incorporated over the course of several transition phase iterations. The transition phase also includes system conversions and user training. Refinements and variations [ edit ] Refinements of the unified process vary from each other in how they categorize the project disciplines or workflows . The rational unified process defines nine disciplines: business modeling , requirements , analysis and design , Implementation , test , deployment , configuration and change management , project management , and environment . The enterprise unified process extends RUP through the addition of eight \"enterprise\" disciplines. Agile refinements of UP such as OpenUP/Basic and the agile unified process simplify RUP by reducing the number of disciplines. Refinements also vary in the emphasis placed on different project artifacts . Agile refinements streamline RUP by simplifying workflows and reducing the number of expected artifacts. Refinements also vary in their specification of what happens after the transition phase. In the rational unified process the transition phase is typically followed by a new inception phase. In the enterprise unified process the transition phase is followed by a production phase. The number of unified process refinements and variations are countless. Organizations utilizing the unified process invariably incorporate their own modifications and extensions. The following is a list of some of the better known refinements and variations. Agile unified process (AUP), a lightweight variation developed by Scott W. Ambler Basic unified process (BUP), a lightweight variation developed by IBM and a precursor to OpenUP Enterprise unified process (EUP), an extension of the rational unified process Essential unified process (EssUP), a lightweight variation developed by Ivar Jacobson Open unified process (OpenUP), the Eclipse Process Framework software development process Rational unified process (RUP), the IBM / Rational Software development process Oracle unified method (OUM), the Oracle development and implementation process Rational Unified Process-System Engineering (RUP-SE), a version of RUP tailored by Rational Software for System Engineering References [ edit ] Kroll, Per; Kruchten, Philippe (2003). The Rational Unified Process Made Easy: A Practitioner's Guide to the RUP . ISBN 0-321-16609-4 . Kruchten, Philippe (2004). The Rational Unified Process: An Introduction (3rd Ed.). ISBN 0-321-19770-4 . Ambler, Scott (2002). Agile Modeling: Effective Practices for EXtreme Programming and the Unified Process . J. Wiley. ISBN 0-471-20282-7 . Archived from the original on 2019-08-08 . Retrieved 2014-02-05 . Scott, Kendall (2002). The Unified Process Explained . ISBN 0-201-74204-7 . Bergstrom, Stefan; Raberg, Lotta (2004). Adopting the Rational Unified Process: Success with the RUP . ISBN 0-321-20294-5 . Ambler, Scott ; Constantine, Larry (2002). The Unified Process Transition and Production Phases . CMP Books. ISBN 1-57820-092-X . Archived from the original on 2019-07-14 . Retrieved 2014-02-05 . Larman, Craig (2004). Agile and Iterative Development: A Manager's Guide . ISBN 0-13-111155-8 . v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Unified_process&oldid=1303306798 \" Category : Software development process Hidden categories: Articles with short description Short description is different from Wikidata Articles lacking in-text citations from November 2017 All articles lacking in-text citations This page was last edited on 30 July 2025, at 05:55 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Unified process 14 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/SEMAT",
    "title": "SEMAT - Wikipedia",
    "content": "SEMAT - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Practice area 2 Education area 3 Theory area 4 Organizational structure Toggle Organizational structure subsection 4.1 Main organization 4.2 Japan Chapter 4.3 Korea Chapter 4.4 Latin American Chapter 4.5 Russia Chapter 5 Practical Applications of SEMAT 6 Tools supporting SEMAT 7 References 8 External links Toggle the table of contents SEMAT 3 languages Catal\u00e0 Fran\u00e7ais Portugu\u00eas Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia A major contributor to this article appears to have a close connection with its subject. It may require cleanup to comply with Wikipedia's content policies, particularly neutral point of view . Please discuss further on the talk page . ( January 2019 ) ( Learn how and when to remove this message ) SEMAT ( Software Engineering Method and Theory ) is an initiative to reshape software engineering such that software engineering qualifies as a rigorous discipline. The initiative was launched in December 2009  by Ivar Jacobson , Bertrand Meyer , and Richard Soley [ 1 ] with a call for action statement [ 2 ] and a vision statement. [ 3 ] The initiative was envisioned as a multi-year effort for bridging the gap between the developer community and the academic community and for creating a community giving value to the whole software community. The work is now structured in four different but strongly related areas: Practice, Education, Theory, and Community. [ citation needed ] The Practice area primarily addresses practices. The Education area is concerned with all issues related to training for both the developers and the academics including students. The Theory area is primarily addressing the search for a General Theory in Software Engineering. Finally, the Community area works with setting up legal entities, creating websites and community growth.  It was expected that the Practice area, the Education area and the Theory area would at some point in time integrate in a way of value to all of them: the Practice area would be a \"customer\" of the Theory area, and direct the research to useful results for the developer community.  The Theory area would give a solid and practical platform for the Practice area.  And, the Education area would communicate the results in proper ways. Practice area [ edit ] The first step was here to develop a common ground or a kernel including the essence of software engineering \u2013 things we always have, always do, always produce when developing software.  The second step was envisioned to add value on top of this kernel in the form of a library of practices to be composed to become specific methods, specific for all kinds of reasons such as the preferences of the team using it, kind of software being built, etc.\nThe first step is as of this writing just about to be concluded.  The results are a kernel including universal elements for software development \u2013 called the Essence Kernel, and a language \u2013 called the Essence Language - to describe these elements (and elements built on top of the kernel (practices, methods, and more).  Essence, including both the kernel and language, has been published as an OMG standard in beta status in July 2013 [ 4 ] and is expected to become a formally adopted standard in early 2014. The second step has just started, and the Practice area will be divided into a number of separate but interconnected tracks: the practice (library track), the tool track are so far identified and work has started or is about to get started. [ citation needed ] The practice track is currently working on a Users Guide. Education area [ edit ] The area focuses on leveraging the work of SEMAT in software engineering education, both within academia and industry. It promotes global education based on a common ground called Essence. The area's target groups are instructors such as university professors and industrial coaches as well as their students and learning practitioners. The goal of the area is to create educational courses and course materials that are internationally viable, identify pedagogical approaches that are appropriate and effective for specific target groups and disseminate experience and lessons learned. The area includes members from a number of universities and institutes worldwide. [ citation needed ] Most members have already been involved in leveraging aspects of SEMAT in the context of their software engineering courses. They are gathering their resources and starting a common venture towards defining a new generation of SEMAT-powered software engineering curricula. As of 2018, some studies of utilizing Essence in educational settings exist. One example of the use of Essence in university education was a software engineering course carried out in Norwegian University of Science and Technology. A study [ 5 ] was conducted by introducing Essence into a project-based software engineering course, with the aim of understanding what difficulties the students faced in using Essence, and whether they considered it to have been useful. The results indicated that Essence could also be useful for novice software engineers by (1) encouraging them to look up and study new practices and methods in order to create their own, (2) encouraging them to adjust their way-of-working reflectively and in a situation-specific manner, (3) helping them structure their way of working. The findings of another study introducing students to Essence through a digital game supported these findings: the students felt that Essence will be useful to them in future, real-world projects, and that they wish to utilize it in them. [ 6 ] Theory area [ edit ] An important part of SEMAT is that a general theory of software engineering is planned to emerge with significant benefits. [ 7 ] A series of workshops held under the title SEMAT Workshop on a General Theory of Software Engineering (GTSE) are a key component in awareness building around general theories. [ 8 ] In addition to community awareness building, SEMAT also aims to contribute with a specific general theory of software engineering. This theory should be solidly based on the SEMAT Essence language and kernel, and should support software engineering practitioners' goal-oriented decision making. As argued elsewhere, such support is predicated on the predictive capabilities of the theory. Thus, the SEMAT Essence should be augmented to allow the prediction of critical software engineering phenomena. The GTSE workshop series assists in the development of the SEMAT general software engineering theory by engaging a larger community in the search for, development of, and evaluation of promising theories, which may be used as a base for the SEMAT theory. Organizational structure [ edit ] Main organization [ edit ] SEMAT is chaired by Sumeet S. Malhotra of Tata Consultancy Services. [ 9 ] The CEO of the organization is Ste Nadin of Fujitsu. The Executive Management Committee of SEMAT are Ivar Jacobson, Ste Nadin, Sumeet S. Malhotra, Paul E. McMahon, Michael Goedicke and Cecile Peraire. Japan Chapter [ edit ] Japan Chapter was established in April 2013, and it has more than 250 members as of November 2013. [ citation needed ] Member activities include carrying out seminars about SEMAT, considering utilization of SEMAT Essence for integrating different requirements engineering techniques and body of knowledges (BoKs), and translating articles into Japanese. Korea Chapter [ edit ] The chapter was inaugurated with about 50 members in October 2013.  Member activities include: 2e Consulting started rewriting their IT service engagement methods using the Essence kernel, and uEngine Solutions started developing a tool to orchestrate Essence-kernel based practices into a project method. Korean government supported KAIST to conduct research in Essence. Latin American Chapter [ edit ] Semat Latin American Chapter was created in August 2011 in Medellin (Colombia) by Ivar Jacobson during the Latin American Software Engineering Symposium. This Chapter has 9 Executive Committee members from Colombia, Venezuela, Peru, Brazil, Argentina, Chile, and Mexico, chaired by Dr. Carlos Zapata from Colombia. More than 80 people signed the initial declaration of the Chapter and nowadays the Chapter members are in charge of disseminating the Semat ideas in all Latin America. Chapter members have participated in various Latin American conferences, including the Latin American Conference on Informatics (CLEI), [ 10 ] the Ibero American Software Engineering and Knowledge Engineering Journeys (JIISIC), [ 11 ] the Colombian Computing Conference (CCC), [ 12 ] and the Chilean Computing Meeting (ECC). The Chapter contributed in the submission sent in response to the OMG call for proposals and currently studies didactic strategies for teaching the Semat kernel by games, theoretical studies about some kernel elements, and practical representations of several software development and quality methods by using the Semat kernel. Some of the members also translated the Essence book and some other Semat materials and papers into Spanish. Russia Chapter [ edit ] Russian Chapter has about 20 members. A few universities have incorporated SEMAT in their training courses [ citation needed ] , including Moscow State University , Moscow Institute of Physics and Technology , Higher School of Economics , Moscow State University of Economics, Statistics, and Informatics .  The chapter and some commercial companies are carrying out seminars about SEMAT. INCOSE Russian Chapter is working on an extension of SEMAT to Systems Engineering . EC-leasing is working on an extension of the Kernel for Software Life Cycle. Russian Chapter attended in two conferences: Actual Problems of System and Software Engineering and SECR with SEMAT section and articles. [ citation needed ] Translation of the Essence book into Russian is in progress. Practical Applications of SEMAT [ edit ] Ideas developed by the SEMAT community have been applied by both industry and academia. Notable examples include: Reinsurance company Munich Re have assembled a family of \"collaboration models\" to cover the whole spectrum of software and application work. Four collaboration models \u2014 exploratory, standard, maintenance, and support \u2014 have been built on the same kernel from the same set of 12 practices. [ 13 ] Tools supporting SEMAT [ edit ] The first tool that supported the authoring and development of SEMAT practices based on a kernel was the EssWork Practice Workbench [ 14 ] tool provided by Ivar Jacobson International. The Practice Workbench tool was made available to the SEMAT community in June 2012 and is now publicly available and free to use. The Practice Workbench is an Integrated Practice Development Environment with support for collaborative practice and method development. Key features of the Practice Workbench include: Interactive presentation of the Essence Kernel Practice authoring and extension using the Essence Language Method composition Innovative card-based representation Publication of methods, practices and kernels as card-based HTML web-sites Export to the EssWork deployment environment Other publicly available tools supporting SEMAT's Essence include: SematAcc, [ 15 ] [ 16 ] the Essence Accelerator System, designed to speed up the learning of Essence Theory in Software Engineering and to easily test it with any software project The Essence Board Game, [ 17 ] intended to teach the basics of Essence in a fun fashion Essencery, [ 18 ] [ 19 ] an Open Source alternative for composing methods using the Essence graphical language syntax References [ edit ] ^ \"Welcome - SEMAT\" . www.semat.org . ^ \"The SEMAT Initiative: A Call for Action\" . Dr. Dobb's . ^ \"Software engineering method and theory \u2013 a vision statement\" (PDF) . Archived from the original (PDF) on 2021-05-01. ^ \"Essence 1.0\" . www.omg.org . Retrieved 2025-01-08 . ^ Kemell, Kai-Kristian; Nguyen-Duc, Anh; Wang, Xiaofeng; Risku, Juhanki; Abrahamsson, Pekka (2018). \"The Essence Theory of Software Engineering - Large-Scale Classroom Experiences from 450+ Software Engineering BSC Students\". arXiv : 1809.08827 [ cs.SE ]. ^ Pieper, J., Lueth, O., Goedicke, M., and Forbrig, P. (2017). A Case Study of Software Engineering Methods Education Supported By Digital Game-Based Learning - Applying the SEMAT Essence Kernel in Games and Course Projects. In Proceedings of the 2017 IEEE Global Engineering Education Conference (EDUCON), pp. 1689-1698. ^ Pontus Johnson; Mathias Ekstedt; Ivar Jacobson. \"Where's the Theory for Software Engineering?\" (PDF) . Archived from the original (PDF) on 2014-08-01 . Retrieved 2013-08-08 . ^ \"Welcome - SEMAT\" . semat.org . ^ \"Dr. Sumeet Malhotra has been elected Chairman of the Board of Directors of SEMAT, Inc. - News - SEMAT\" . www.semat.org . ^ \"Tutoriales \u00ab\u00a0CLEI 2013\" . Archived from the original on 2013-12-02 . Retrieved 2013-11-25 . ^ \"Class Schedule\" (PDF) . University of Medellin. Archived from the original (PDF) on 2022-12-08. ^ \"Tutorial sobre la iniciativa Semat y el juego MetriCC\" [Tutorial on the Semat initiative and the MetriCC game] (PDF) (in Spanish). Archived from the original (PDF) on 2013-12-02 . Retrieved 2013-11-25 . ^ \"Applying SEMAT Concepts at Munich Re\" . July 27, 2013. ^ \"Agile Practices Workbench | Agile Development Tools\" . Ivar Jacobson International . August 7, 2015. ^ Graziotin, Daniel; Abrahamsson, Pekka (2 September 2013). \"A Web-based modeling tool for the SEMAT Essence theory of software engineering\" . Journal of Open Research Software . 1 (1): E4. arXiv : 1307.2075 . doi : 10.5334/jors.ad . ^ \"Unknown\" . [ permanent dead link ] ^ Kemell, Kai-Kristian; Risku, Juhani; Evensen, Arthur; Abraharnsson, Pekka; Dahl, Aleksander Madsen; Grytten, Lars Henrik; Jcdryszek, Agata; Rostrup, Petter; Nguyen-Duc, Anh (2018). \"Gamifying the Escape from the Engineering Method Prison\". 2018 IEEE International Conference on Engineering, Technology and Innovation (ICE/ITMC) . pp. 1\u2013 9. arXiv : 1809.08656 . doi : 10.1109/ICE.2018.8436340 . ISBN 978-1-5386-1469-3 . S2CID 52015385 . ^ \"Semat\" . www.essencery.com . ^ Evensen, Arthur; Kemell, Kai-Kristian; Wang, Xiaofeng; Risku, Juhani; Abrahamsson, Pekka (2018). \"Essencery - A Tool for Essentializing Software Engineering Practices\". arXiv : 1808.02723 [ cs.SE ]. External links [ edit ] Official website The SEMAT Initiative: A Call for Action Why We Need a Theory for Software Engineering Methods Need Theory SEMAT - Software Engineering Method and Theory The Essence of Software Engineering: The SEMAT Kernel Retrieved from \" https://en.wikipedia.org/w/index.php?title=SEMAT&oldid=1319057171 \" Categories : Software engineering organizations Software engineering Operations research Hidden categories: CS1 Spanish-language sources (es) All articles with dead external links Articles with dead external links from January 2025 Articles with permanently dead external links Wikipedia articles with possible conflicts of interest from January 2019 All articles with unsourced statements Articles with unsourced statements from November 2013 Articles with unsourced statements from January 2020 Official website not in Wikidata This page was last edited on 27 October 2025, at 15:17 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents SEMAT 3 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_configuration_management",
    "title": "Software configuration management - Wikipedia",
    "content": "Software configuration management - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Goals 2 History 3 Examples 4 See also 5 References 6 Further reading 7 External links Toggle the table of contents Software configuration management 18 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Az\u0259rbaycanca Catal\u00e0 Deutsch Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Hrvatski Italiano \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 \u65e5\u672c\u8a9e Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Suomi \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikiversity Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Tracking and controlling software changes This article includes a list of general references , but it lacks sufficient corresponding inline citations . Please help to improve this article by introducing more precise citations. ( September 2010 ) ( Learn how and when to remove this message ) IEEE software life cycle Software project management Software quality assurance Software requirements specification Software configuration management Software design description Software test documentation Software verification and validation Software user documentation Software audit review v t e Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Software configuration management ( SCM ), a.k.a. software change and configuration management ( SCCM ), [ 1 ] is the software engineering practice of tracking and controlling changes to a software system ; part of the larger cross-disciplinary field of configuration management (CM). [ 2 ] SCM includes version control and the establishment of baselines . Goals [ edit ] The goals of SCM include: [ citation needed ] Configuration identification - Identifying configurations, configuration items and baselines . Configuration control - Implementing a controlled change process. This is usually achieved by setting up a change control board whose primary function is to approve or reject all change requests that are sent against any baseline. Configuration status accounting - Recording and reporting all the necessary information on the status of the development process. Configuration auditing - Ensuring that configurations contain all their intended parts and are sound with respect to their specifying documents, including requirements, architectural specifications and user manuals. Build management - Managing the process and tools used for builds. Process management - Ensuring adherence to the organization's development process. Environment management - Managing the software and hardware that host the system. Teamwork - Facilitate team interactions related to the process. Defect tracking - Making sure every defect has traceability back to the source. With the introduction of cloud computing and DevOps the purposes of SCM tools have become merged in some cases.  The SCM tools themselves have become virtual appliances that can be instantiated as virtual machines and saved with state and version.  The tools can model and manage cloud-based virtual resources, including virtual appliances, storage units, and software bundles.  The roles and responsibilities of the actors have become merged as well with developers now being able to dynamically instantiate virtual servers and related resources. [ 3 ] History [ edit ] This section is an excerpt from History of software configuration management . [ edit ] The history of software configuration management (SCM) can be traced back as early as the 1950s, when CM (configuration management), originally for hardware development and production control, was being applied to software development. Early software had a physical footprint, such as cards , tapes , and other media. The first software configuration management was a manual operation. With the advances in language and complexity, software engineering , involving configuration management and other methods, became a major concern due to issues like schedule, budget, and quality. Practical lessons, over the years, had led to the definition, and establishment, of procedures and tools. Eventually, the tools became systems to manage software changes. [ 4 ] Industry-wide practices were offered as solutions, either in an open or proprietary manner (such as Revision Control System ). With the growing use of computers, systems emerged that handled a broader scope, including requirements management , design alternatives, quality control, and more; later tools followed the guidelines of organizations, such as the Capability Maturity Model of the Software Engineering Institute . Examples [ edit ] Ansible \u2013 Open-source software platform for remote configuring and managing computers CFEngine \u2013 Configuration management software Chef \u2013 Configuration management tool Pages displaying short descriptions of redirect targets LCFG \u2013 Computer configuration management system NixOS \u2013 Linux distribution OpenMake Software \u2013 DevOps company Otter Puppet \u2013 Open source configuration management software Salt \u2013 Configuration management software Rex \u2013 Open source software See also [ edit ] Application lifecycle management \u2013 Product management of computer programs throughout their development lifecycles Comparison of open source configuration management software Comparison of version control software Continuous configuration automation List of revision control software Infrastructure as code \u2013 Data center management method References [ edit ] ^ Gartner and Forrester Research ^ Roger S. Pressman (2009). Software Engineering: A Practitioner's Approach (7th International\u00a0ed.). New York: McGraw-Hill. ^ Amies, A; Peddle S; Pan T M; Zou P X (June 5, 2012). \"Develop cloud applications with Rational tools\" . IBM DeveloperWorks . IBM. ^ \"1988 \"A Guide to Understanding Configuration Management in Trusted Systems\" National Computer Security System (via Google ) Further reading [ edit ] 828-2012 IEEE Standard for Configuration Management in Systems and Software Engineering . 2012. doi : 10.1109/IEEESTD.2012.6170935 . ISBN 978-0-7381-7232-3 . Aiello, R. (2010). Configuration Management Best Practices: Practical Methods that Work in the Real World (1st ed.). Addison-Wesley. ISBN 0-321-68586-5 . Babich, W.A. (1986). Software Configuration Management, Coordination for Team Productivity . 1st edition. Boston: Addison-Wesley Berczuk, Appleton; (2003). Software Configuration Management Patterns: Effective TeamWork, Practical Integration (1st ed.). Addison-Wesley. ISBN 0-201-74117-2 . Bersoff, E.H. (1997). Elements of Software Configuration Management. IEEE Computer Society Press, Los Alamitos, CA, 1-32 Dennis, A., Wixom, B.H. & Tegarden, D. (2002). System Analysis & Design: An Object-Oriented Approach with UML. Hoboken, New York: John Wiley & Sons, Inc. Department of Defense, USA (2001). Military Handbook: Configuration management guidance (rev. A) (MIL-HDBK-61A) . Retrieved January 5, 2010, from http://www.everyspec.com/MIL-HDBK/MIL-HDBK-0001-0099/MIL-HDBK-61_11531/ Futrell, R.T. et al. (2002). Quality Software Project Management. 1st edition. Prentice-Hall. International Organization for Standardization (2003). ISO 10007: Quality management systems \u2013 Guidelines for configuration management . Saeki M. (2003). Embedding Metrics into Information Systems Development Methods: An Application of Method Engineering Technique. CAiSE 2003, 374\u2013389. Scott, J.A. & Nisse, D. (2001). Software configuration management. In: Guide to Software Engineering Body of Knowledge . Retrieved January 5, 2010, from http://www.computer.org/portal/web/swebok/htmlformat Paul M. Duvall, Steve Matyas, and Andrew Glover (2007). Continuous Integration: Improving Software Quality and Reducing Risk . (1st ed.). Addison-Wesley Professional. ISBN 0-321-33638-0 . External links [ edit ] SCM and ISO 9001 by Robert Bamford and William Deibler, SSQC Use Cases and Implementing Application Lifecycle Management Parallel Development Strategies for Software Configuration Management v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control flow Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Computational problem Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human-centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human\u2013computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Specialized Platform\nDevelopment Thermodynamic computing Category Outline Glossaries v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons v t e IEEE standards Current 488 693 730 754 Revision 854 828 829 896 1003 1014 1016 1076 1149.1 1154 1164 1275 1278 1284 1355 1394 1451 1497 1516 1541 1547 1584 1588 1596 1603 1613 1619 1666 1667 1675 1685 1722 1733 1800 1801 1815 1849 1850 1855 1900 1901 1902 1904 1905 2030 2050 11073 12207 14764 16085 16326 29148 42010 802 series 802 .2 .4 .5 .6 .7 .8 .9 .10 .12 .14 .16 WiMAX \u00b7 d \u00b7 e .17 .18 .20 .21 .22 .24 802.1 D p Q Qav Qat Qay Qaz Qbb w X AB ad AE ag ah ak aq AS AX ( LACP ) BA 802.3 ( Ethernet ) -1983 a b d e i j u x y z ab ac ad ae af ah ak an aq at au av az ba bt bu by bz ca cb cc cd ce cg ch ck cm cn cp cq cr cs ct cu cv cw cx cy cz da db dd de df 802.11 ( Wi-Fi ) -1997 legacy mode a b c d e f g h i j k n ( Wi-Fi 4 ) p r s u v w y z aa ac ( Wi-Fi 5 ) ad ( WiGig ) ae af ah ai aj ak aq ax ( Wi-Fi 6 ) ay az ba bb bc bd be ( Wi-Fi 7 ) bf bh bi bk bn ( Wi-Fi 8 ) 802.15 .1 ( Bluetooth ) .2 .3 .4 ( Zigbee ) .4a .4b .4c .4d .4e .4f .4g .4z .5 .6 .7 Proposed P1363 P1699 P1823 P1906.1 Superseded 754-1985 830 1219 1233 1362 1364 1471 Category Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_configuration_management&oldid=1297918713 \" Categories : Configuration management Software engineering IEEE standards Types of tools used in software development Hidden categories: Articles with short description Short description is different from Wikidata Articles lacking in-text citations from September 2010 All articles lacking in-text citations All articles with unsourced statements Articles with unsourced statements from March 2008 Articles with excerpts Pages displaying short descriptions of redirect targets via Module:Annotated link This page was last edited on 29 June 2025, at 10:19 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software configuration management 18 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_quality_assurance",
    "title": "Software quality assurance - Wikipedia",
    "content": "Software quality assurance - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Purpose 2 Activities 3 See also 4 References 5 External links Toggle the table of contents Software quality assurance 13 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Catal\u00e0 \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 \u05e2\u05d1\u05e8\u05d9\u05ea Latvie\u0161u \u65e5\u672c\u8a9e Polski \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Means of monitoring the software and ensuring high quality stable applications This article includes a list of general references , but it lacks sufficient corresponding inline citations . Please help to improve this article by introducing more precise citations. ( April 2019 ) ( Learn how and when to remove this message ) IEEE software life cycle Software project management Software quality assurance Software requirements specification Software configuration management Software design description Software test documentation Software verification and validation Software user documentation Software audit review v t e Software quality assurance ( SQA ) is a means and practice of monitoring all software engineering processes , methods, and work products to ensure compliance against defined standards. [ 1 ] It may include ensuring conformance to standards or models, such as ISO/IEC 9126 (now superseded by ISO 25010), SPICE or CMMI . [ 2 ] It includes standards and procedures that managers, administrators or developers may use to review and audit software products and activities to verify that the software meets quality criteria which link to standards. SQA encompasses the entire software development process, including requirements engineering , software design , coding , code reviews , source code control , software configuration management , testing , release management and software integration . It is organized into goals, commitments, abilities, activities, measurements, verification and validation . [ 3 ] Purpose [ edit ] This section is in list format but may read better as prose . You can help by converting this section , if appropriate. Editing help is available. ( November 2019 ) SQA involves a three-pronged approach: Organization-wide policies, procedures and standards Project-specific policies, procedures and standards Compliance to appropriate procedures Guidelines for the application of ISO 9001:2015 to computer software are described in ISO/IEC/IEEE 90003:2018. [ 4 ] External entities can be contracted as part of process assessments to verify that projects are standard-compliant. More specifically in case of software, ISO/IEC 9126 (now superseded by ISO 25010) should be considered and applied for software quality. Activities [ edit ] Quality assurance activities take place at each phase of development. Analysts use application technology and techniques to achieve high-quality specifications and designs, such as model-driven design . Engineers and technicians find bugs and problems with related software quality through testing activities. Standards and process deviations are identified and addressed throughout development by project managers or quality managers, who also ensure that changes to functionality, performance, features, architecture and component ( in general: changes to product or service scope ) are made only after appropriate review, e.g. as part of change control boards . [ 5 ] See also [ edit ] DOD-STD-2167 Quality by design Software assurance Software quality analyst Software quality management Software testing References [ edit ] ^ \"What is Software Quality Assurance (SQA): A Guide for Beginners\" . Software Testing Help . Retrieved 2022-06-02 . ^ Kelemen, Z\u00e1dor D\u00e1niel; Kusters, Rob; Trienekens, Jos (December 2012). \"Identifying criteria for multimodel software process improvement solutions - based on a review of current problems and initiatives\". Journal of Software: Evolution and Process . 24 (8): 895\u2013 909. doi : 10.1002/smr.549 . S2CID 14382496 . ^ Nielsen, David CMM and Project Quality Management ^ \"ISO/IEC/IEEE 90003:2018\" . ISO . Retrieved 2020-07-14 . ^ Wieczorek, Martin; Vos, Diederik; Bons, Heinz (2014-05-08). Systems and Software Quality: The next step for industrialisation . Springer Science & Business Media. ISBN 978-3-642-39971-8 . Wikimedia Commons has media related to Software quality assurance . External links [ edit ] IEEE Standard for Software Quality Assurance Processes . doi : 10.1109/IEEESTD.2014.6835311 . ISBN 978-0-7381-9168-3 . April, Alain (2018). Software Quality Assurance . Wiley-IEEE. ISBN 978-1-118-50182-5 . Chemuturi, Murali (2010). Software Quality Assurance: Best Practices, Tools and Techniques for Software Developers . J.Ross Publishing. ISBN 978-1-60427-032-7 . \"Software Quality Requirements\". Software Quality Assurance . 2017. pp. 66\u2013 100. doi : 10.1002/9781119312451.ch3 . ISBN 9781119312451 . \"Software Quality Assurance(SQA): Plan, Audit & Review.\" Meet Guru99 \u2013 Free Training Tutorials & Video for IT Courses , www.guru99.com/software-quality-assurance-test-audit-review-makes-your-life-easy.html. Collofello, J.S.; Buck, J.J. (September 1987). \"Software Quality Assurance for Maintenance\". IEEE Software . 4 (5): 46\u2013 51. doi : 10.1109/MS.1987.231418 . S2CID 2205647 . Parnas, D.L.; Lawford, M. (July 2003). \"Inspection's role in software quality assurance\". IEEE Software . 20 (4): 16\u2013 20. doi : 10.1109/MS.2003.1207449 . hdl : 10344/161 . S2CID 7071357 . Laporte, Claude Y.; April, Alain (2018). Software Quality Assurance . John Wiley & Sons. ISBN 978-1-118-50182-5 . v t e Software quality Qualities Internal Size Maintainability Flexibility Portability Reusability Readability Scalability Testability Understandability Loose coupling Orthogonality External Usability Reliability Adaptability Correctness Accuracy Efficiency Robustness Security Safety Standards and lists ISO/IEC 9126 Non-functional requirements List of system quality attributes Processes Software quality management Software quality control Software quality assurance Commons v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons v t e IEEE standards Current 488 693 730 754 Revision 854 828 829 896 1003 1014 1016 1076 1149.1 1154 1164 1275 1278 1284 1355 1394 1451 1497 1516 1541 1547 1584 1588 1596 1603 1613 1619 1666 1667 1675 1685 1722 1733 1800 1801 1815 1849 1850 1855 1900 1901 1902 1904 1905 2030 2050 11073 12207 14764 16085 16326 29148 42010 802 series 802 .2 .4 .5 .6 .7 .8 .9 .10 .12 .14 .16 WiMAX \u00b7 d \u00b7 e .17 .18 .20 .21 .22 .24 802.1 D p Q Qav Qat Qay Qaz Qbb w X AB ad AE ag ah ak aq AS AX ( LACP ) BA 802.3 ( Ethernet ) -1983 a b d e i j u x y z ab ac ad ae af ah ak an aq at au av az ba bt bu by bz ca cb cc cd ce cg ch ck cm cn cp cq cr cs ct cu cv cw cx cy cz da db dd de df 802.11 ( Wi-Fi ) -1997 legacy mode a b c d e f g h i j k n ( Wi-Fi 4 ) p r s u v w y z aa ac ( Wi-Fi 5 ) ad ( WiGig ) ae af ah ai aj ak aq ax ( Wi-Fi 6 ) ay az ba bb bc bd be ( Wi-Fi 7 ) bf bh bi bk bn ( Wi-Fi 8 ) 802.15 .1 ( Bluetooth ) .2 .3 .4 ( Zigbee ) .4a .4b .4c .4d .4e .4f .4g .4z .5 .6 .7 Proposed P1363 P1699 P1823 P1906.1 Superseded 754-1985 830 1219 1233 1362 1364 1471 Category Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_quality_assurance&oldid=1322498493 \" Categories : Quality assurance Software quality IEEE standards Hidden categories: Articles with short description Short description is different from Wikidata Articles lacking in-text citations from April 2019 All articles lacking in-text citations Articles needing cleanup from November 2019 All pages needing cleanup Articles with sections that need to be turned into prose from November 2019 Commons category link is on Wikidata This page was last edited on 16 November 2025, at 15:29 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software quality assurance 13 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_documentation",
    "title": "Software documentation - Wikipedia",
    "content": "Software documentation - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Types Toggle Types subsection 1.1 Requirements documentation 1.2 Architecture design documentation 1.3 Technical documentation 1.3.1 Technical documentation embedded in source code 1.3.1.1 Literate programming 1.3.1.2 Elucidative programming 1.4 User documentation 1.4.1 Composing user documentation 1.5 Marketing documentation 2 Documentation and agile development controversy Toggle Documentation and agile development controversy subsection 2.1 Docs as Code 2.1.1 Benefits 3 See also 4 Notes Toggle the table of contents Software documentation 19 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 \u010ce\u0161tina Deutsch \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Hrvatski Ido Italiano \u049a\u0430\u0437\u0430\u049b\u0448\u0430 \u0d2e\u0d32\u0d2f\u0d3e\u0d33\u0d02 Nederlands \u65e5\u672c\u8a9e Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Explains the functionality of software Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Software documentation is written text or illustration that accompanies computer software or is embedded in the source code. The documentation either explains how the software operates or how to use it, and may mean different things to people in different roles. Documentation is an important part of software engineering. Types of documentation include: Requirements \u2013 Statements that identify attributes, capabilities, characteristics, or qualities of a system. This is the foundation for what will be or has been implemented. Architecture/Design \u2013 Overview of software. Includes relations to an environment and construction principles to be used in design of software components. Technical \u2013 Documentation of code, algorithms, interfaces, and APIs. End user \u2013 Manuals for the end-user, system administrators and support staff. Marketing \u2013 How to market the product and analysis of the market demand. Types [ edit ] Requirements documentation [ edit ] Requirements documentation is the description of what a given software does or should do. It is used throughout development to communicate how the software functions or how it is intended to operate. It is also used as an agreement or as the foundation for agreement on what the software will do. Requirements are produced and consumed by everyone involved in the production of software, including: end users , customers , project managers , sales , marketing , software architects , usability engineers , interaction designers , developers , and testers . Requirements come in a variety of styles, notations and formality. Requirements can be goal-like (e.g., distributed work environment ), close to design (e.g., builds can be started by right-clicking a configuration file and selecting the 'build' function ), and anything in between. They can be specified as statements in natural language , as drawn figures, as detailed mathematical formulas , or as a combination of them all. The variation and complexity of requirement documentation make it a proven challenge. Requirements may be implicit and hard to uncover. It is difficult to know exactly how much and what kind of documentation is needed and how much can be left to the architecture and design documentation, and it is difficult to know how to document requirements considering the variety of people who shall read and use the documentation. Thus, requirements documentation is often incomplete (or non-existent). Without proper requirements documentation, software changes become more difficult \u2014 and therefore more error prone (decreased software quality ) and time-consuming (expensive). The need for requirements documentation is typically related to the complexity of the product, the impact of the product, and the life expectancy of the software. If the software is very complex or developed by many people (e.g., mobile phone software), requirements can help better communicate what to achieve. If the software is safety-critical and can have a negative impact on human life (e.g., nuclear power systems, medical equipment, mechanical equipment), more formal requirements documentation is often required. If the software is expected to live for only a month or two (e.g., very small mobile phone applications developed specifically for a certain campaign) very little requirements documentation may be needed. If the software is a first release that is later built upon, requirements documentation is very helpful when managing the change of the software and verifying that nothing has been broken in the software when it is modified. Traditionally, requirements are specified in requirements documents (e.g. using word processing applications and spreadsheet applications). To manage the increased complexity and changing nature of requirements documentation (and software documentation in general), database-centric systems and special-purpose requirements management tools are advocated. In Agile software development, requirements are often expressed as user stories with accompanying acceptance criteria. User stories are typically part of a feature, or an epic, which is a broader functionality or set of related functionalities that deliver a specific value to the user based on the business requirements. Architecture design documentation [ edit ] Architecture documentation (also known as software architecture description ) is a special type of design document. In a way, architecture documents are third derivative from the code ( design document being second derivative, and code documents being first). Very little in the architecture documents is specific to the code. These documents do not describe how to program a given routine, or even why a routine exists in the form that it does, but instead merely list the general requirements that would motivate the existence of such a routine. A good architecture document is short on details but thick on explanation. It may suggest approaches for lower level design, but leave the actual exploration trade studies to other documents. Another type of design document is the comparison document, or trade study. This would often take the form of a whitepaper . It focuses on one specific aspect of the system and suggests alternate approaches. It could be at the user interface , code, design, or even architectural level. It will outline what the situation is, describe one or more alternatives, and enumerate the pros and cons of each. A good trade study document is heavy on research, expresses its idea clearly (without relying heavily on obtuse jargon to dazzle the reader), and most importantly is impartial. It should honestly and clearly explain the costs of whatever solution it offers as best. The objective of a trade study is to devise the best solution, rather than to advance some viewpoint. It is acceptable to state no conclusion, or to conclude that none of the alternatives are sufficiently better than the baseline to warrant a change. It should be approached as a scientific endeavor, not as a marketing technique. A very important part of the design document in enterprise software development is the Database Design Document (DDD). It contains Conceptual, Logical, and Physical Design Elements. The DDD includes the formal information that the people who interact with the database need. The purpose of preparing it is to create a common source to be used by all players within the scene. The potential users are: Database designer Database developer Database administrator Application designer Application developer When talking about Relational Database Systems, the document should include following parts: Entity - Relationship Schema ( enhanced or not), including following information and their clear definitions: Entity Sets and their attributes Relationships and their attributes Candidate keys for each entity set Attribute and Tuple based constraints Relational Schema, including following information: Tables, Attributes, and their properties Views Constraints such as primary keys, foreign keys, Cardinality of referential constraints Cascading Policy for referential constraints Primary keys It is very important to include all information that is to be used by all actors in the scene. It is also very important to update the documents as any change occurs in the database as well. Technical documentation [ edit ] Further information: Technical documentation It is important for the code documents associated with the source code (which may include README files and application programming interface ( API ) documentation) to be thorough, but not so verbose that it becomes overly time-consuming or difficult to maintain them. Various how-to and overview documentation guides are commonly found specific to the software application or software product being documented by API writers . This documentation may be used by developers, testers, and also end-users. Today, a lot of high-end applications are seen in the fields of power, energy, transportation, networks, aerospace, safety, security, industry automation, and a variety of other domains. Technical documentation has become important within such organizations as the basic and advanced level of information may change over a period of time with architecture changes. There is evidence that the existence of good code documentation actually reduces maintenance costs for software. [ 1 ] Code documents are often organized into a reference guide style, allowing a programmer to quickly look up an arbitrary function or class. Technical documentation embedded in source code [ edit ] Often, tools such as Doxygen , NDoc , Visual Expert , Javadoc , JSDoc , EiffelStudio , Sandcastle , ROBODoc , Plain Old Documentation (POD), TwinText , or Universal Report can be used to auto-generate the code documents\u2014that is, they extract the comments and software contracts , where available, from the source code and create reference manuals in such forms as text or HTML files. The idea of auto-generating documentation is attractive to programmers for various reasons. For example, because it is extracted from the source code (for example, through comments ), the programmer can write it while referring to the code, and use the same tools used to create the source code to make the documentation. This makes it much easier to keep the documentation up-to-date. A possible downside is that only programmers can edit this kind of documentation, and it depends on them to refresh the output (for example, by running a cron job to update the documents nightly). Some would characterize this as a pro rather than a con. Literate programming [ edit ] Respected computer scientist Donald Knuth has noted that documentation can be a very difficult afterthought process and has advocated literate programming (LP), written at the same time and location as the source code and extracted by automatic means. The programming languages Haskell and CoffeeScript have built-in support for a simple form of LP, but this support is not used widely. A stricter, more rigorous advance in method in the same direction is Docs as Code Elucidative programming [ edit ] Elucidative programming is the result of practical applications of literate programming in real programming contexts. The elucidative paradigm proposes that source code and documentation be stored separately. Often, software developers need to be able to create and access information that is not going to be part of the source file itself. Such annotations are usually part of several software development activities, such as code walks and porting, where third-party source code is analysed in a functional way. Annotations can therefore help the developer during any stage of software development where a formal documentation system would hinder progress. User documentation [ edit ] This section is about consumable guides for software usage. For more general systems, see End user documentation . Unlike code documents, user documents simply describe how a program is used. In the case of a software library , the code documents and user documents could in some cases be effectively equivalent and worth conjoining, but for a general application this is not often true. Typically, the user documentation describes each feature of the program, and assists the user in realizing these features. It is very important for user documents to not be confusing, and for them to be up to date. User documents do not need to be organized in any given way, but it is very important for them to have a thorough index . Consistency and simplicity are also very valuable. User documentation is considered to constitute a contract specifying what the software will do. API Writers are very well accomplished towards writing good user documents as they would be well aware of the software architecture and programming techniques used. See also technical writing . User documentation can be produced in a variety of online and print formats. [ 2 ] However, user documentation may be organized in three main ways: Tutorial \u2013 A tutorial approach is considered most useful for a new user, in which they are guided through each step of accomplishing given tasks. [ 3 ] Thematic \u2013 A thematic approach, where chapters or sections concentrate on one given area of interest, is of more general use to an intermediate user. Some authors prefer to convey ideas through a knowledge based article to facilitate the user needs. This approach is usually practiced by a dynamic industry, such as Information technology . [ 4 ] List or Reference \u2013 The final type of organizing principle is one in which commands or tasks are simply listed alphabetically or logically grouped, often via cross-referenced indexes. This latter approach is of greater use to advanced users who know exactly what sort of information they are looking for. A common complaint among users regarding software documentation is that only one of these three approaches was taken to the near-exclusion of the other two. It is common to limit provided software documentation for personal computers to online help that gives only reference information on commands or menu items. The job of tutoring new users or helping more experienced users get the most out of a program is left to private publishers, who are often given significant assistance by the software developer. Composing user documentation [ edit ] Like other forms of technical documentation, good user documentation benefits from an organized process of development. In the case of user documentation, the process as it commonly occurs in industry consists of five steps: [ 5 ] User analysis , the basic research phase of the process. [ 6 ] Planning, or the actual documentation phase. [ 7 ] Draft review, is a self-explanatory phase where feedback is sought on the draft composed in the previous step. [ 8 ] Usability testing , whereby the usability of the document is tested empirically. [ 9 ] Editing , is the final step in which the information collected in steps three and four is used to produce the final draft. Marketing documentation [ edit ] For many applications it is necessary to have some promotional materials to encourage casual observers to spend more time learning about the product. This form of documentation has three purposes: To excite the potential user about the product and instill in them a desire to become more involved with it. To inform them about what exactly the product does, so that their expectations are in line with what they will be receiving. To explain the position of this product with respect to other alternatives. Documentation and agile development controversy [ edit ] \"The resistance to documentation among developers is well known and needs no emphasis.\" [ 10 ] This situation is common in agile software development because those methodologies try to avoid needless activities that add no direct value. The Agile Manifesto advocates valuing \"working software over comprehensive documentation\", which could be interpreted cynically as \"We want to spend all our time coding. Remember, real programmers don't write documentation.\" [ 11 ] A survey among software engineering experts revealed, however, that documentation is by no means considered unnecessary in agile development.\nYet it is acknowledged that there are motivational problems in development, and that documentation methods tailored to agile development (e.g. through Reputation systems and Gamification ) may be needed. [ 12 ] [ 13 ] Docs as Code [ edit ] Docs as Code is a system for documentation that treats it with the same rigor and processes as software code. This includes: Version control \u2013 Using systems like Git to track changes and manage versions Continuous integration \u2013 Automating the process of documentation generation and updates Collaboration \u2013 Enabling multiple contributors to work on documentation concurrently, as in code development Benefits [ edit ] Consistency \u2013 Documentation can be kept in sync with the codebase, ensuring accuracy. Automation \u2013 Automated tools can handle repetitive tasks, such as formatting and deployment. Collaboration \u2013 Encourages contributions from various team members, including developers, testers, and product managers. Combining Docs as Code with Agile methods creates a robust framework for maintaining high-quality, up-to-date documentation. The two can be integrated, thusly: Setup Version Control \u2013 Start by placing documentation in a version control system. Structure it similarly to the codebase. Automate Processes \u2013 Implement CI/CD tools to automate generating and deploying documentation. Define Roles \u2013 Assign roles and responsibilities for documentation within the Agile team. Ensure everyone understands the importance of documentation. Regular Reviews \u2013 Schedule regular documentation reviews as part of the sprint retrospectives. See also [ edit ] API Writer Comparison of documentation generators Design by contract Design document Docstring Documentation Literate programming README files User Assistance Unified Modeling Language (UML) Notes [ edit ] ^ \"How to get a budget for code documentation\" . ^ Earle, R.H.; Rosso, M.A.; Alexander, K.E. (16 July 2015). \"User preferences of software documentation genres\". Proceedings of the 33rd Annual International Conference on the Design of Communication (ACM SIGDOC) . pp. 1\u2013 10. doi : 10.1145/2775441.2775457 . ISBN 978-1-4503-3648-2 . ^ Woelz, Carlos. \"The KDE Documentation Primer\" . Retrieved 15 June 2009 . ^ \"Knowledge Base Articles for Driver Development\" . Microsoft . Retrieved 15 June 2009 . ^ Thomas T. Barker, Writing Software Documentation , Preface, xxiv. Part of the Allyn & Bacon Series in Technical Communication, 2nd ed. Upper Saddle River : Pearson Education , 2003. ISBN 0321103289 Archived May 13, 2013, at the Wayback Machine ^ Barker, pg. 118. ^ Barker, pg. 173. ^ Barker, pg. 217. ^ Barker, pg. 240. ^ Herbsleb, James D.; Moitra, Dependra (March\u2013April 2001). \"Guest Editors' Introduction: Global Software Development\". IEEE Software . 18 (2): 16\u2013 20. ^ Rakitin, Steven (2001). \"Manifesto elicits cynicism\" (PDF) . IEEE Computer . 34 (12): 4. ^ Prause, Christian R., and Zoya Durdik. \"Architectural design and documentation: Waste in agile development?\" In: International Conference on Software and System Process (ICSSP), IEEE, 2012. ^ Selic, Bran. \"Agile documentation, anyone?\" In: IEEE Software , vol. 26, no. 6, pp. 11-12, 2009 v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_documentation&oldid=1324232660 \" Categories : Software documentation Technical communication Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata This page was last edited on 26 November 2025, at 10:59 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software documentation 19 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Software_project_management",
    "title": "Software project management - Wikipedia",
    "content": "Software project management - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 History 2 Software development process 3 Project planning, execution, monitoring, and control 4 Issue Toggle Issue subsection 4.1 Severity levels 4.2 Issue management 5 Philosophy 6 References 7 External links Toggle the table of contents Software project management 11 languages Catal\u00e0 \u0641\u0627\u0631\u0633\u06cc \ud55c\uad6d\uc5b4 Magyar \u65e5\u672c\u8a9e \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Shqip \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Field of planning and leading software projects This article has multiple issues. Please help improve it or discuss these issues on the talk page . ( Learn how and when to remove these messages ) This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Software project management\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( August 2010 ) ( Learn how and when to remove this message ) This article contains weasel words : vague phrasing that often accompanies biased or unverifiable information . Such statements should be clarified or removed . ( November 2018 ) This article possibly contains original research . Please improve it by verifying the claims made and adding inline citations . Statements consisting only of original research should be removed. ( November 2018 ) ( Learn how and when to remove this message ) ( Learn how and when to remove this message ) IEEE software life cycle Software project management Software quality assurance Software requirements specification Software configuration management Software design description Software test documentation Software verification and validation Software user documentation Software audit review v t e Software project management is the process of planning and leading software projects. [ 1 ] It is a sub-discipline of project management in which software projects are planned, implemented, monitored and controlled. History [ edit ] In the 1970s and 1980s, the software industry grew very quickly, as computer companies quickly recognized the relatively low cost of software production compared to hardware production and circuitry. To manage new development efforts, companies applied the established project management methods, but project schedules slipped during test runs, especially when confusion occurred in the gray zone between the user specifications and the delivered software. To be able to avoid these problems, software project management methods focused on matching user requirements to delivered products, in a method known now as the waterfall model . As the industry has matured, analysis of software project management failures has shown that the following are the most common causes: [ 2 ] [ 3 ] [ 4 ] Insufficient end-user involvement Poor communication among customers, developers, users and project managers Unrealistic or unarticulated project goals Inaccurate estimates of needed resources Badly defined or incomplete system requirements and specifications Poor reporting of the project's status Poorly managed risks Use of immature technology Inability to handle the project's complexity Sloppy development practices Stakeholder politics (e.g. absence of executive support, or politics between the customer and end-users) Commercial pressures The first five items in the list above show the difficulties articulating the needs of the client in such a way that proper resources can deliver the proper project goals. Specific software project management tools are useful and often necessary, but the true art in software project management is applying the correct method and then using tools to support the method. Without a method, tools are worthless. Since the 1960s, several proprietary software project management methods have been developed by software manufacturers for their own use, while computer consulting firms have also developed similar methods for their clients. Today software project management methods are still evolving, but the current trend leads away from the waterfall model to a more cyclic project delivery model that imitates a software development process. Software development process [ edit ] A software development process is concerned primarily with the production aspect of software development , as opposed to the technical aspect, such as software tools . These processes exist primarily for supporting the management of software development, and are generally skewed toward addressing business concerns. Many software development processes can be run in a similar way to general project management processes. Examples are: Interpersonal communication and conflict management and resolution . Active, frequent and honest communication is the most important factor in increasing the likelihood of project success and mitigating problematic projects. The development team should seek end-user involvement and encourage user input in the development process. Not having users involved can lead to misinterpretation of requirements, insensitivity to changing customer needs, and unrealistic expectations on the part of the client. Software developers, users, project managers, customers and project sponsors need to communicate regularly and  frequently. The information gained from these discussions allows the project team to analyze the strengths, weaknesses, opportunities and threats (SWOT) and to act on that information to benefit from opportunities and to minimize threats. Even bad news may be good if it is communicated relatively early, because problems can be mitigated if they are not discovered too late. For example, casual conversation with users, team members, and other stakeholders may often surface potential problems sooner than formal meetings. All communications need to be intellectually honest and authentic, and regular, frequent, high quality criticism of development work is necessary, as long as it is provided in a calm, respectful, constructive , non-accusatory, non-angry fashion. Frequent casual communications between developers and end-users, and between project managers and clients, are necessary to keep the project relevant, useful and effective for the end-users, and within the bounds of what can be completed. Effective interpersonal communication and conflict management and resolution are the key to software project management. No methodology or process improvement strategy can overcome serious problems in communication or mismanagement of interpersonal conflict. Moreover, outcomes associated with such methodologies and process improvement strategies are enhanced with better communication. The communication must focus on whether the team understands the project charter and whether the team is making progress towards that goal. End-users, software developers and project managers must frequently ask the elementary , simple questions that help identify problems before they fester into near-disasters. While end-user participation, effective communication and teamwork are not sufficient, they are necessary to ensure a good outcome, and their absence will almost surely lead to a bad outcome. [ 3 ] [ 4 ] [ 5 ] Risk management is the process of measuring or assessing risk and then developing strategies to manage the risk. In general, the strategies employed include transferring the risk to another party, avoiding the risk, reducing the negative effect of the risk, and accepting some or all of the consequences of a particular risk. Risk management in software project management begins with the business case for starting the project, which includes a cost-benefit analysis as well as a list of fallback options for project failure, called a contingency plan . A subset of risk management is Opportunity Management , which means the same thing, except that the potential risk outcome will have a positive, rather than a negative impact. Though theoretically handled in the same way, using the term \"opportunity\" rather than the somewhat negative term \"risk\" helps to keep a team focused on possible positive outcomes of any given risk register in their projects, such as spin-off projects, windfalls, and free extra resources. Requirements management is the process of identifying, eliciting , documenting, analyzing, tracing , prioritizing and agreeing on requirements and then controlling change and communicating to relevant stakeholders. New or altered computer system [ 1 ] Requirements management, which includes Requirements analysis , is an important part of the software engineering process; whereby business analysts or software developers identify the needs or requirements of a client; having identified these requirements they are then in a position to design a solution. Change management is the process of identifying, documenting, analyzing, prioritizing and agreeing on changes to scope (project management) and then controlling changes and communicating to relevant stakeholders. Change impact analysis of new or altered scope, which includes Requirements analysis at the change level, is an important part of the software engineering process; whereby business analysts or software developers identify the altered needs or requirements of a client; having identified these requirements they are then in a position to re-design or modify a solution. Theoretically, each change can impact the timeline and budget of a software project, and therefore by definition must include risk-benefit analysis before approval. Software configuration management is the process of identifying, and documenting the scope itself, which is the software product underway, including all sub-products and changes and enabling communication of these to relevant stakeholders.  In general, the processes employed include version control , naming convention (programming) , and software archival agreements. Release management is the process of identifying, documenting, prioritizing and agreeing on releases of software and then controlling the release schedule and communicating to relevant stakeholders. Most software projects have access to three software environments to which software can be released; Development, Test, and Production. In very large projects, where distributed teams need to integrate their work before releasing to users, there will often be more environments for testing, called unit testing , system testing , or integration testing , before release to User acceptance testing (UAT). A subset of release management that is gaining attention is Data Management , as obviously the users can only test based on data that they know, and \"real\" data is only in the software environment called \"production\". In order to test their work, programmers must therefore also often create \"dummy data\" or \"data stubs\". Traditionally, older versions of a production system were once used for this purpose, but as companies rely more and more on outside contributors for software development, company data may not be released to development teams. In complex environments, datasets may be created that are then migrated across test environments according to a test release schedule, much like the overall software release schedule. Maintenance and update is the process where Requirements and customer needs are always involving. They will undoubtedly find bugs, may request new features and ask for different functionality and more updates. So, all of these requests need to check and fulfill the customer's requirements and satisfaction. Project planning, execution, monitoring, and control [ edit ] The purpose of project planning is to identify the scope of the project, estimate the work involved, and create a project schedule . Project planning begins with requirements that define the software to be developed. The project plan is then developed to describe the tasks that will lead to completion. The project execution is the process of completing the tasks defined in the project plan. The purpose of project monitoring and control is to keep the team and management up to date on the project's progress. If the project deviates from the plan, then the project manager can take action to correct the problem. Project monitoring and control involves status meetings to gather status from the team. When changes need to be made, change control is used to keep the products up to date. Issue [ edit ] This section possibly contains original research . Please improve it by verifying the claims made and adding inline citations . Statements consisting only of original research should be removed. ( November 2018 ) ( Learn how and when to remove this message ) This section does not cite any sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . ( December 2020 ) ( Learn how and when to remove this message ) In computing, the term \"issue\" is a unit of work to accomplish an improvement in a system. [ 6 ] An issue could be a bug , a requested feature , task, missing documentation , and so forth. For example, OpenOffice.org used to call their modified version of Bugzilla IssueZilla. As of September 2010 [update] , they call their system Issue Tracker. [ 7 ] Severity levels [ edit ] Issues are often categorized in terms of severity levels . Different companies have different definitions of severities, but some of the most common ones are: High The bug or issue affects a crucial part of a system, and must be fixed in order for it to resume normal operation. [ 8 ] Medium The bug or issue affects a minor part of a system, but has some impact on its operation. This severity level is assigned when a non-central requirement of a system is affected. [ 9 ] Low / Fixed The bug or issue affects a minor part of a system, and has very little impact on its operation. This severity level is assigned when a non-central requirement of a system (and with lower importance) is affected. [ 10 ] Trivial (cosmetic, aesthetic) The system works correctly, but the appearance does not match the expected one. For example: wrong colors, too much or too little spacing between contents, incorrect font sizes, typos, etc. This is the lowest severity issue. [ 11 ] Issue management [ edit ] In some implementations of software development processes, issues are investigated by quality assurance analysts a system is verified for correctness, and then assigned back to a member of the development team to resolve the identified issue.  They can also be identified by system users during the User Acceptance Testing (UAT) phase. Issues can be recorded and communicated using Issue or Defect Tracking Systems . In the absence of a formal Issue or Defect Tracking system, it is commonplace to simply use any form of written communication such as emails or instant messages to communicate the existence of a found issue. Philosophy [ edit ] As a subdiscipline of project management, some regard the management of software development akin to the management of manufacturing , which can be performed by someone with management skills, but no programming skills. John C. Reynolds rebuts this view, and argues that software development is entirely design work, and compares a manager who cannot program to the managing editor of a newspaper who cannot write . [ 12 ] References [ edit ] ^ a b Stellman, Andrew; Greene, Jennifer (2005). Applied Software Project Management . O'Reilly Media. ISBN 978-0-596-00948-9 . Archived from the original on 2015-02-09. ^ \"Why Software Fails\" , in IEEE Spectrum ^ a b Producing Open Source Software: How to Run a Successful Free Software Project (e-book, freely downloadable), by Karl Fogel ^ a b Robert Frese and Vicki Sauter , \"Improving your odds for software project success,\" IEEE Engineering Management Review , Vol. 42, No. 4, Fourth Quarter, Dec 2014 ^ Philip Greenspun , in Jessica Livingston's Founders at Work (2007), ISBN 1-59059-714-1 ^ Dane, Bertram (2009). \"The social nature of issue tracking in software engineering\" (PDF) . Archived from the original (PDF) on 2016-11-08 . Retrieved 2023-10-07 . ^ \"Bugs&Issues Explained\" . www.openoffice.org . Retrieved 2025-10-13 . ^ \"Bug Severity: How & Why to Measure + Levels Guide\" . brainhub.eu . Retrieved 2025-10-13 . ^ \"Bug Severity: How & Why to Measure + Levels Guide\" . brainhub.eu . Retrieved 2025-10-13 . ^ \"Bug Severity: How & Why to Measure + Levels Guide\" . brainhub.eu . Retrieved 2025-10-13 . ^ \"Bug Severity: How & Why to Measure + Levels Guide\" . brainhub.eu . Retrieved 2025-10-13 . ^ John C. Reynolds, Some thoughts on teaching programming and programming languages , SIGPLAN Notices, Volume 43, Issue 11, November 2008, p.108: \"Some argue that one can manage software production without the ability to program. This belief seems to arise from the mistaken view that software production is a form of manufacturing. But manufacturing is the repeated construction of identical objects, while software production is the construction of unique objects, i.e., the entire process is a form of design. As such it is closer to the production of a newpaper [sic] \u2014 so that a software manager who cannot program is akin to a managing editor who cannot write.\" General 16326:2019(E) - ISO/IEC/IEEE International Standard - Systems and software engineering - Life cycle processes - Project management . 2019. doi : 10.1109/IEEESTD.2019.8932690 . ISBN 978-1-5044-6299-0 . 1058-1998 - IEEE Standard for Software Project Management Plans . 1998. doi : 10.1109/IEEESTD.1998.88822 . ISBN 978-0-7381-1448-4 . Jalote, Pankaj (2002). Software project management in practice . Addison-Wesley. ISBN 0-201-73721-3 . Murali Chemuturi, Thomas M. Cagley Jr. & (2010). Software Project Management: Best Practices, Tools and Techniques . J.Ross Publishing. ISBN 978-1-60427-034-1 . External links [ edit ] Media related to Software project management at Wikimedia Commons Robert Frese (2003-12-16). \"PROJECT SUCCESS AND FAILURE: WHAT IS SUCCESS, WHAT IS FAILURE, AND HOW CAN YOU IMPROVE YOUR ODDS FOR SUCCESS?\" . University of Missouri-St. Louis . Retrieved 2015-05-13 . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Software_project_management&oldid=1316611865 \" Categories : Software project management Project management Hidden categories: Articles with short description Short description is different from Wikidata Articles needing additional references from August 2010 All articles needing additional references Articles with weasel words from November 2018 Articles that may contain original research from November 2018 All articles that may contain original research Articles with multiple maintenance issues Articles needing additional references from December 2020 Articles containing potentially dated statements from September 2010 All articles containing potentially dated statements Commons category link is on Wikidata This page was last edited on 13 October 2025, at 14:15 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software project management 11 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Deployment_management#Computer_science",
    "title": "Deployment management - Wikipedia",
    "content": "Deployment management - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Industry-specific definitions Toggle Industry-specific definitions subsection 1.1 Computer science 1.2 Information technology (IT) 1.3 Political science 1.4 Social and health sciences 1.5 Water and natural resources 2 Role of end users Toggle Role of end users subsection 2.1 User concerns 2.2 Designer concerns 3 See also 4 References Toggle the table of contents Deployment management 1 language \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Software engineering terminology Look up deployment management in Wiktionary, the free dictionary. Deployment is the realisation of an application, or execution of a plan , idea, model , design , specification , standard , algorithm , or policy . Industry-specific definitions [ edit ] Computer science [ edit ] In computer science , a deployment is a realisation of a technical specification or algorithm as a program , software component , or other computer system through computer programming and deployment .  Many implementations may exist for a given specification or standard.  For example, web browsers contain implementations of World Wide Web Consortium -recommended specifications, and software development tools contain deployment of programming languages . A special case occurs in object-oriented programming , when a concrete class deploys an interface ; in this case the concrete class is a deployment of the interface and it includes methods which are deployments of those methods specified by the interface. Information technology (IT) [ edit ] In the IT Industry, deployment refers to post-sales process of guiding a client from purchase to use of the software or hardware that was purchased. This includes requirements analysis, scope analysis, customisations, systems integrations, user policies, user training and delivery. These steps are often overseen by a project manager using project management methodologies. Software Deployment involves several professionals that are relatively new to the knowledge based economy such as business analysts , software implementation specialists, solutions architects , and project managers. To deploy a system successfully, a large number of inter-related tasks need to be carried out in an appropriate sequence. Utilising a well-proven implementation methodology and enlisting professional advice can help but often it is the number of tasks, poor planning and inadequate resourcing that causes problems with a deployment project, rather than any of the tasks being particularly difficult. Similarly with the cultural issues it is often the lack of adequate consultation and two-way communication that inhibits achievement of the desired results. Political science [ edit ] In political science , deployment refers to the carrying out of public policy . Legislatures pass laws that are then carried out by public servants working in bureaucratic agencies . This process consists of rule-making, rule-administration and rule-adjudication. Factors impacting deployment include the legislative intent, the administrative capacity of the deploying bureaucracy, interest group activity and opposition, and executive support. Social and health sciences [ edit ] \"Deployment is defined as a specified set of activities designed to put into practice an activity or program of known dimensions. According to this definition, deployment processes are purposeful and are described in sufficient detail such that independent observers can detect the presence and strength of the \"specific set of activities\" related to implementation. In addition, the activity or program being deployed is described in sufficient detail so that independent observers can detect its presence and strength.\" [ 1 ] Water and natural resources [ edit ] In water and natural resources, deployment refers to the actualisation of best management practices with the ultimate goals of conserving natural resources and improving the quality of water bodies. Types: Direct changeover Parallel running or as known as parallel Pilot introduction or as known as pilot Well-trade Phased Deployment Role of end users [ edit ] System deployment generally benefits from high levels of user involvement and management support. User participation in the design and operation of information systems has several positive results. First, if users are heavily involved in systems design, they move opportunities to mold the system according to their priorities and business requirements, and more opportunities to control the outcome. Second, they are more likely to react positively to the change process. Incorporating user knowledge and expertise leads to better solutions. The relationship between users and information systems specialists has traditionally been a problem area for information systems deployment efforts.  Users and information systems specialists tend to have different backgrounds, interests, and priorities. This is referred to as the user-designer communications gap. These differences lead to divergent organizational loyalties, approaches to problem solving, and vocabularies. [ 2 ] Examples of these differences or concerns are below: User concerns [ edit ] Will the system deliver the information I need for my work? How quickly can I access the data? How easily can I retrieve the data? How much clerical support will I need to enter data into the system? How will the operation of the system fit into my daily business schedule? [ 2 ] Designer concerns [ edit ] How much storage space will the master file consume? How many lines of program code will it take to perform this function? How can we cut down on CPU time when we run the system? What are the most efficient ways of storing this data? What database management system should we use? [ 2 ] See also [ edit ] Application software References [ edit ] ^ The National Implementation Research Network ^ a b c Laudon, K., & Laudon, J. (2010). \"Management Information Systems: Managing the Digital Firm.\" Eleventh  Edition (11 ed.). New Jersey: Prentice Hall. Retrieved from \" https://en.wikipedia.org/w/index.php?title=Deployment_management&oldid=1318045167 \" Categories : Computing terminology Political science terminology Design Hidden categories: Articles with short description Short description matches Wikidata This page was last edited on 21 October 2025, at 16:09 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Deployment management 1 language Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Behavior-driven_development",
    "title": "Behavior-driven development - Wikipedia",
    "content": "Behavior-driven development - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Overview 2 Principles Toggle Principles subsection 2.1 Behavioral specifications 2.2 Specification as a ubiquitous language 3 Specialized tooling Toggle Specialized tooling subsection 3.1 Tooling principles 4 Story versus specification 5 The three amigos 6 See also 7 References Toggle the table of contents Behavior-driven development 19 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 Catal\u00e0 Deutsch Eesti Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Italiano \u05e2\u05d1\u05e8\u05d9\u05ea Magyar Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Software test naming Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Behavior-driven development ( BDD ) involves naming software tests using domain language to describe the behavior of the code . BDD involves use of a domain-specific language (DSL) using natural-language constructs (e.g., English-like sentences) that can express the behavior and the expected outcomes. Proponents claim it encourages collaboration among developers, quality assurance experts, and customer representatives in a software project. [ 1 ] [ 2 ] It encourages teams to use conversation and concrete examples to formalize a shared understanding of how the application should behave. [ 3 ] BDD is considered an effective practice especially when the problem space is complex. [ 4 ] BDD is considered a refinement of test-driven development (TDD). [ 1 ] [ 5 ] [ 6 ] [ vague ] [ 7 ] [ 8 ] BDD combines the techniques of TDD with ideas from domain-driven design and object-oriented analysis and design to provide software development and management teams with shared tools and a shared process to collaborate on software development. [ 1 ] [ 7 ] At a high level, BDD is an idea about how software development should be managed by both business interests and technical insight. Its practice involves use of specialized tools. [ 5 ] Some tools specifically for BDD can be used for TDD. The tools automate the ubiquitous language . Overview [ edit ] BDD is a process by which DSL structured natural-language statements are converted into executable tests. The result are tests that read like acceptance criteria for a given function. As such, BDD is an extension of TDD. BDD focuses on: Where to start in the process What to test and what not to test How much to test in one go What to call the tests How to understand why a test fails At its heart, BDD is about rethinking the approach to automated testing (including unit testing and acceptance testing ) in order to avoid issues that naturally arise. For example, BDD suggests that unit test names be whole sentences starting with a conditional verb (\"should\" in English for example) and should be written in order of business value. Acceptance tests should be written using the standard agile framework of a user story : \"Being a [role/actor/stakeholder] I want a [feature/capability] yielding a [benefit]\". Acceptance criteria should be written in terms of scenarios and implemented in classes: Given [initial context], when [event occurs], then [ensure some outcomes] . Starting from this point, many people developed BDD frameworks over a period of years, finally framing it in terms of a communication and collaboration framework for developers, QA and non-technical or business participants in a software project. [ 9 ] Principles [ edit ] BDD suggests that software tests should be named in terms of desired behavior . [ 5 ] [ 7 ] Borrowing from agile software development the \"desired behavior\" in this case consists of the requirements set by the business \u2014 that is, the desired behavior that has business value for whatever entity commissioned the software unit under construction. [ 5 ] Within BDD practice, this is referred to as BDD being an \"outside-in\" activity. TDD does not differentiate tests in terms of high-level software requirements, low-level technical details or anything in between. One way of looking at BDD therefore, is that it is an evolution of TDD which makes more specific choices. Behavioral specifications [ edit ] Another BDD suggestion relates to how the desired behavior should be specified. BDD suggests using a semi-formal format for behavioral specification which is borrowed from user story specifications from the field of object-oriented analysis and design . The scenario aspect of this format may be regarded as an application of Hoare logic to behavioral specification of software using the domain-specific language. BDD suggests that business analysts and software developers should collaborate in this area and should specify behavior in terms of user stories, which are each explicitly documented. Each user story should, to some extent, follow the structure: [ 5 ] Title An explicit title. Narrative A short introductory section with the following structure: As a : the person or role who will benefit from the feature; I want : the feature; so that : the benefit or value of the feature. Acceptance criteria A description of each specific scenario of the narrative with the following structure: Given : the initial context at the beginning of the scenario, in one or more clauses; When : the event that triggers the scenario; Then : the expected outcome, in one or more clauses. BDD does not require how this information is formatted, but it does suggest that a team should decide on a relatively simple, standardized format with the above elements. [ 5 ] It also suggests that the scenarios should be phrased declaratively rather than imperatively \u2014 in the business language, with no reference to elements of the UI through which the interactions take place. [ 10 ] This format is referred to in Cucumber as the Gherkin language . Specification as a ubiquitous language [ edit ] BDD borrows the concept of the ubiquitous language from domain driven design . [ 5 ] [ 7 ] A ubiquitous language is a (semi-)formal language that is shared by all members of a software development team \u2014 both software developers and non-technical personnel. [ 11 ] The language in question is both used and developed by all team members as a common means of discussing the domain of the software in question. [ 11 ] In this way BDD becomes a vehicle for communication between all the different roles in a software project. [ 5 ] A common risk with software development includes communication breakdowns between Developers and Business Stakeholders. [ 12 ] BDD uses the specification of desired behavior as a ubiquitous language for the project Team members. This is the reason that BDD insists on a semi-formal language for behavioral specification: some formality is a requirement for being a ubiquitous language. [ 5 ] In addition, having such a ubiquitous language creates a domain model of specifications, so that specifications may be reasoned about formally. [ 13 ] This model is also the basis for the different BDD-supporting software tools that are available. The example given above establishes a user story for a software system under development. This user story identifies a stakeholder, a business effect and a business value. It also describes several scenarios, each with a precondition, trigger and expected outcome. Each of these parts is exactly identified by the more formal part of the language (the term Given might be considered a keyword , for example) and may therefore be processed in some way by a tool that understands the formal parts of the ubiquitous language. Most BDD applications use text-based DSLs and specification approaches. However, graphical modeling of integration scenarios has also been applied successfully in practice, e.g., for testing purposes. [ 14 ] Specialized tooling [ edit ] Much like TDD, BDD may involve using specialized tooling. BDD requires not only test code as does TDD, but also a document that describes behavior in a more human-readable language. This requires a two-step process for executing the tests, reading and parsing the descriptions, and reading the test code and finding the corresponding test implementation to execute. This process makes BDD more laborious for developers. Proponents suggest that due to its human-readable nature the value of those documents extends to a relatively non-technical audience, and can hence serve as a communication means for describing requirements (\"features\"). Tooling principles [ edit ] In principle, a BDD support tool is a testing framework for software, much like the tools that support TDD. However, where TDD tools tend to be quite free-format in what is allowed for specifying tests, BDD tools are linked to the definition of the ubiquitous language. The ubiquitous language allows business analysts to document behavioral requirements in a way that will also be understood by developers. The principle of BDD support tooling is to make these same requirements documents directly executable as a collection of tests. If this cannot be achieved because of reasons related to the technical tool that enables the execution of the specifications, then either the style of writing the behavioral requirements must be altered or the tool must be changed. [ 15 ] The exact implementation of behavioral requirements varies per tool, but agile practice has come up with the following general process: The tooling reads a specification document. The tooling directly understands completely formal parts of the ubiquitous language (such as the Given keyword in the example above). Based on this, the tool breaks each scenario up into meaningful clauses. Each individual clause in a scenario is transformed into some sort of parameter for a test for the user story. This part requires project-specific work by the software developers. The framework then executes the test for each scenario, with the parameters from that scenario. Story versus specification [ edit ] A separate subcategory of behavior-driven development is formed by tools that use specifications as an input language rather than user stories. Specification tools don't use user stories as an input format for test scenarios but rather use functional specifications for units that are being tested. These specifications often have a more technical nature than user stories and are usually less convenient for communication with business personnel than are user stories. [ 5 ] [ 16 ] An example of a specification for a stack might look like this: Specification: Stack When a new stack is created Then it is empty When an element is added to the stack Then that element is at the top of the stack When a stack has N elements And element E is on top of the stack Then a pop operation returns E And the new size of the stack is N-1 Such a specification may exactly specify the behavior of the component being tested, but is less meaningful to a business user. As a result, specification-based testing is seen in BDD practice as a complement to story-based testing and operates at a lower level. Specification testing is often seen as a replacement for free-format unit testing. [ 16 ] The three amigos [ edit ] The \"three amigos\", also referred to as a \"Specification Workshop\", is a meeting where the product owner discusses the requirement in the form of specification by example with different stakeholders like the QA and development team. The key goal for this discussion is to trigger conversation and identify any missing specifications. The discussion also gives a platform for QA, development team and product owner to converge and hear out each other's perspective to enrich the requirement and also make sure if they are building the right product. [ 17 ] The three amigos are: Business - Role of the business user is to define the problem only and not venture into suggesting a solution Development - Role of the developers involve suggesting ways to fix the problem Testing - Role of testers is to question the solution, bring up as many as different possibilities for brain storming through what-if scenarios and help make the solution more precise to fix the problem. See also [ edit ] Specification by example Behat (PHP framework) Cynefin framework Concordion (Java framework) RSpec Gauge Jasmine (JavaScript testing framework) Squish GUI Tester (BDD GUI Testing Tool for JavaScript, Python, Perl, Ruby and Tcl) Use case Fitnesse has been used to roll out BDD [ 18 ] References [ edit ] ^ a b c \"Behaviour-Driven Development\" . Archived from the original on 1 September 2015 . Retrieved 12 August 2012 . ^ Keogh, Liz (2009-09-07). \"Introduction to Behavior-Driven Development\" . SkillsMatterr . Archived from the original on 2021-02-25 . Retrieved 1 May 2019 . ^ John Ferguson Smart (2014). BDD in Action: Behavior-Driven Development for the Whole Software Lifecycle . Manning Publications. ISBN 9781617291654 . ^ Tharayil, Ranjith (15 February 2016). \"Behavior-Driven Development: Simplifying the Complex Problem Space\" . SolutionsIQ . Retrieved 15 February 2018 . ^ a b c d e f g h i j Haring, Ronald (February 2011). de Ruiter, Robert (ed.). \"Behavior Driven development: Beter dan Test Driven Development\". Java Magazine (in Dutch) (1). Veen Magazines: 14\u2013 17. ISSN 1571-6236 . ^ Solis, Carlos; Wang, Xiaofeng (2011). \"A Study of the Characteristics of Behaviour Driven Development\". 2011 37th EUROMICRO Conference on Software Engineering and Advanced Applications . pp. 383\u2013 387. doi : 10.1109/SEAA.2011.76 . hdl : 10344/1256 . ISBN 978-1-4577-1027-8 . S2CID 3392536 . ^ a b c d Bellware, Scott (June 2008). \"Behavior-Driven Development\" . Code Magazine . Archived from the original on 12 July 2012 . Retrieved 1 May 2019 . ^ Liz Keogh (June 27, 2011). \"ATDD vs. BDD, and a potted history of some related stuff\" . Retrieved 6 May 2019 . ^ \"The RSpec Book \u2013 Question about Chapter 11: Writing software that matters\" . Archived from the original on 2009-11-07 . Retrieved 2009-08-09 . ^ Mabey, Ben. \"Imperative vs. Declarative Scenarios in user stories\" . Archived from the original on 3 June 2010 . Retrieved 19 May 2008 . ^ a b Evans, Eric (2003). Domain-Driven Design: Tackling Complexity in the Heart of Software . Addison-Wesley. ISBN 978-0-321-12521-7 . Retrieved August 12, 2012 . ^ Geneca (16 Mar 2011). \"Why Software Projects Fail\" . Retrieved 16 March 2011 . ^ Mahmudul Haque Azad (6 Feb 2011). \"Say Hello To Behavior Driven Development\" . Retrieved 12 August 2012 . ^ L\u00fcbke, Daniel; van Lessen, Tammo (2016). \"Modeling Test Cases in BPMN for Behavior-Driven Development\". IEEE Software . 33 (5): 15\u2013 21. doi : 10.1109/MS.2016.117 . S2CID 14539297 . ^ Adam Craven (September 21, 2015). \"Fundamentals of Enterprise-Scale Behaviour-Driven Development (BDD)\" . Retrieved 14 January 2016 . ^ a b Roy Osherove (October 4, 2008). \"BDD: Behavior vs. Spec Frameworks\" . Retrieved 12 August 2012 . ^ \"What are the Three Amigos in Agile?\" . Agile Alliance . 2016-06-16 . Retrieved 2019-06-10 . ^ Ketil Jensen (December 13, 2009). \"BDD with Scenario tables in Fitnesse Slim\" . Walk the walk . Wordpress . Retrieved 12 August 2012 . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Behavior-driven_development&oldid=1280022524 \" Categories : Software design Software development philosophies Software testing Hidden categories: CS1 Dutch-language sources (nl) Articles with short description Short description is different from Wikidata All Wikipedia articles needing clarification Wikipedia articles needing clarification from May 2015 Articles with example Java code This page was last edited on 12 March 2025, at 00:21 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Behavior-driven development 19 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/User_experience",
    "title": "User experience - Wikipedia",
    "content": "User experience - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Definitions 2 History 3 Influences on user experience 4 Momentary emotion or overall user experience 5 Critiques and ethical debates in user experience Toggle Critiques and ethical debates in user experience subsection 5.1 Profit versus people 5.2 Dark patterns and manipulative design 5.3 Inclusivity and accessibility gaps 6 Developer experience 7 See also 8 References Toggle the table of contents User experience 32 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438 Boarisch Catal\u00e0 Dansk Deutsch Eesti Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 \u0939\u093f\u0928\u094d\u0926\u0940 Hrvatski Bahasa Indonesia Italiano \u05e2\u05d1\u05e8\u05d9\u05ea \u041c\u0430\u043a\u0435\u0434\u043e\u043d\u0441\u043a\u0438 Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Polski Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Simple English \u0421\u0440\u043f\u0441\u043a\u0438 / srpski Suomi \u0e44\u0e17\u0e22 T\u00fcrk\u00e7e \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u7cb5\u8a9e \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Human interaction with a particular product, system or service User experience ( UX ) is how a user interacts with and experiences a product , system , or service . It includes a person's perceptions of utility , ease of use , and efficiency . Improving user experience is important to most companies, designers, and creators when creating and refining products because negative user experience can diminish the use of the product and, therefore, any desired positive impacts. Conversely, designing toward profitability as a main objective often conflicts with ethical user experience objectives and even causes harm. User experience is subjective . However, the attributes that make up the user experience are objective . Definitions [ edit ] According to Nielsen Norman Group , 'user experience' includes all the aspects of the interaction between the end-user with the company, its services, and its products. [ 1 ] The international standard on ergonomics of human-system interaction , ISO 9241 , defines user experience as a \"user's perceptions and responses that result from the use and/or anticipated use of a system, product or service\". [ 2 ] According to the ISO definition, user experience includes all the users' emotions, beliefs, preferences, perceptions, physical and psychological responses, behaviors, and accomplishments that occur before, during, and after use. The ISO also lists three factors that influence user experience: the system, the user, and the context of use. Note 3 of the standard hints that usability addresses aspects of user experience, e.g., \"usability criteria can be used to assess aspects of user experience\". The standard does not go further in clarifying the relation between user experience and usability. Clearly, the two are overlapping concepts, with usability including pragmatic aspects (getting a task done) and user experience focusing on users' feelings stemming from both pragmatic and hedonic aspects of the system. Many practitioners use the terms interchangeably. The term \"usability\" pre-dates the term \"user experience\". Part of the reason the terms are often used interchangeably is that, as a practical matter, a user will, at a minimum, require sufficient usability to accomplish a task, while the feelings of the user may be less important, even to the user themselves. Since usability is about getting a task done, aspects of user experience like information architecture and user interface can help or hinder a user's experience. If a website has \"bad\" information architecture and a user has a difficult time finding what they are looking for, then the user will not have an effective, efficient, and satisfying search. In addition to the ISO standard, there exist several other definitions for user experience. [ 3 ] Some of them have been studied by various researchers. [ 4 ] History [ edit ] Early developments in user experience can be traced back to the Machine Age , which includes the 19th and early 20th centuries. Inspired by the machine age intellectual framework, a quest for improving assembly processes to increase production efficiency and output led to the development of major technological advancements, such as mass production of high-volume goods on moving assembly lines, high-speed printing presses, large hydroelectric power production plants, and radio technology, to name a few. Frederick Winslow Taylor and Henry Ford explored ways to make human labor more efficient and productive. Taylor's research into the efficiency of interactions between workers and their tools is the earliest example that resembles today's user experience fundamentals. [ citation needed ] The term user experience was brought to wider knowledge by Donald Norman in the mid-1990s. [ 5 ] He never intended the term \"user experience\" to be applied only to the affective aspects of usage. A review of his earlier work [ 6 ] suggests that the term \"user experience\" was used to signal a shift to include affective factors, along with the pre-requisite behavioral concerns, which had been traditionally considered in the field. Many usability practitioners continue to research and attend to affective factors associated with end-users, and have been doing so for years, long before the term \"user experience\" was introduced in the mid-1990s. [ 7 ] In an interview in 2007, Norman discusses the widespread use of the term \"user experience\" and its imprecise meaning as a consequence thereof. [ 8 ] Several developments affected the rise of interest in the user experience: Recent advances in mobile , ubiquitous , social , and tangible computing technologies have moved human-computer interaction into practically all areas of human activity. This has led to a shift away from usability engineering to a much richer scope of user experience, where users' feelings, motivations, and values are given as much, if not more, attention than efficiency, effectiveness, and basic subjective satisfaction (i.e., the three traditional usability metrics ) [ 9 ] [ 10 ] In website design , it was important to combine the interests of different stakeholders: marketing , branding , visual design , and usability . Marketing and branding people needed to enter the interactive world where usability was important. Usability people needed to take marketing, branding, and aesthetic needs into account when designing websites. User experience provided a platform to cover the interests of all stakeholders: making websites easy to use, valuable, and effective for visitors. This is why several early user experience publications focus on website user experience. [ 11 ] [ 12 ] [ 13 ] [ 14 ] The field of user experience represents an expansion and extension of the field of usability to include the holistic perspective of how a person feels about using a system. The focus is on pleasure and value as well as on performance. The exact definition, framework, and elements of user experience are still evolving. User experience of an interactive product or a website is usually measured by a number of methods, including questionnaires, focus groups, observed usability tests, user journey mapping and other methods. A freely available questionnaire (available in several languages) is the User Experience Questionnaire (UEQ). [ 15 ] The development and validation of this questionnaire is described in a computer science essay published in 2008. [ 16 ] Higher levels of user experience have been linked to increased effectiveness of digital health interventions targeting improvements in physical activity, [ 17 ] nutrition, mental health and smoking. [ 18 ] Google Ngram Viewer shows wide use of the term starting in the 1930s. [ 19 ] \"He suggested that more follow-up in the field would be welcomed by the user, and would be a means of incorporating the results of the user's experience into the design of new machines.\" Use of the term in relation to computer software also pre-dates Norman . [ 20 ] Influences on user experience [ edit ] Many factors can influence a user's experience with a system. To address the variety, factors influencing user experience have been classified into three main categories: the user's state and previous experience, system properties, and the usage context (situation). [ 21 ] Understanding representative users, working environments, interactions, and emotional reactions helps in designing the system during User experience design . Momentary emotion or overall user experience [ edit ] Single experiences influence the overall user experience: [ 22 ] the experience of a key click affects the experience of typing a text message, the experience of typing a message affects the experience of text messaging, and the experience of text messaging affects the overall user experience with the phone. The overall user experience is not simply a sum of smaller interaction experiences, because some experiences are more salient than others. Overall user experience is also influenced by factors outside the actual interaction episode: brand , pricing, friends' opinions, reports in the media, etc. One branch of user experience research focuses on emotions. This includes momentary experiences during interaction: designing effective interaction and evaluating emotions . Another branch is interested in understanding the long-term relationship between user experience and product appreciation. The industry sees a good overall user experience with a company's products as critical for securing brand loyalty and enhancing the growth of the customer base. All temporal levels of user experience (momentary, episodic, and long-term) are important, but the methods to design and evaluate these levels can be very different. Critiques and ethical debates in user experience [ edit ] While user experience has become an essential part of design and product development, it has also attracted criticism and ethical scrutiny. Focusing on user satisfaction and business goals may lead to harmful design choices, unintentional accessibility gaps, or user manipulation . [ 23 ] [ 24 ] [ 25 ] These conflicts suggest that UX has room to become a more responsible and inclusive practice. [ 23 ] [ 25 ] Profit versus people [ edit ] One major critique of UX is the conflict between designing for user benefit and designing for business objectives. UX decisions are often shaped by financial incentives rather than users\u2019 well-being. [ 23 ] This leads to design choices that prioritize growth over ethics, for example, features that encourage excessive screen time, [ 23 ] collect unnecessary personal data (also known as privacy zuckering ), [ 25 ] or make it difficult for users to unsubscribe from services (also known as forced continuity ). [ 25 ] While trying to increase profits, it may actually increase economic harm and reduce market efficiency. [ 26 ] Critics argue that such practices compromise the foundational goal of UX, which is to improve the user's experience, not exploit it. [ 23 ] [ 26 ] Companies can be held accountable for their design choices by prioritizing user interests. For instance, ensuring price transparency helps users make informed decisions. [ 23 ] Organizations can also align design decisions with user well-being by evaluating qualitative outcomes, like how a product contributes to users\u2019 happiness or mental health, instead of relying solely on engagement metrics. [ 23 ] By making business success dependent on user trust and satisfaction, rather than engagement metrics alone, organizations can create sustainable products that support both profitability and user well-being. [ 23 ] [ 26 ] Dark patterns and manipulative design [ edit ] Another major ethical concern in UX is the use of dark patterns , interface designs that intentionally mislead or manipulate users into taking actions they might not otherwise choose. [ 26 ] Examples include use of checkboxes to opt out rather than opt in ( double negatives ), [ 25 ] confusing cancellation processes, [ 25 ] or \u201cconfirm\u201d buttons that lead to unintended purchases. [ 23 ] Scholars from Princeton and Purdue University have argued that dark patterns represent a misuse of UX principles, using psychological insights and interface design against user interests. [ 26 ] [ 25 ] One proposed solution to the problem of dark patterns is to focus on how to distinguish manipulative patterns from legitimate persuasion . For example, researchers at Princeton suggest using guidelines to evaluate when a design crosses the line into manipulation. [ 26 ] Researchers from Purdue University instead argue that ethical awareness cannot rely solely on codes of conduct but should instead focus on the designer\u2019s intent, judgment, and ongoing responsibility. [ 25 ] Inclusivity and accessibility gaps [ edit ] Another area of criticism concerns accessibility and inclusivity in UX design. Although improving usability is a central aim of UX, many products and services continue to overlook the needs of people with disabilities, older users, or those from different cultural and linguistic backgrounds. [ 24 ] This exclusion can occur due to implicit bias in design teams, [ 24 ] lack of diverse user testing, [ 23 ] [ 24 ] or assumptions about \u201caverage\u201d users. [ 24 ] To address these gaps, experts recommend adopting inclusive design principles throughout the development process. This includes conducting accessibility audits, following the Web Content Accessibility Guidelines (WCAG), and involving users with disabilities in usability testing to ensure products meet real-world needs. [ 23 ] [ 24 ] [ 27 ] Expanding user research to include diverse groups can also uncover assumptions and biases early. [ 24 ] [ 27 ] Additionally, ongoing education about unconscious bias for design teams can help create products that reflect a broader range of user experiences. [ 25 ] Developer experience [ edit ] See also: Programming tool Developer experience (DX) is a user experience from a developer's point of view. It is defined by the tools, processes, and software that a developer uses when interacting with a product or system while in the process of producing another one, such as in software development . [ 28 ] DX has had increased attention paid to it, especially in businesses that primarily offer software as a service to other businesses, where ease of use is a key differentiator in the market. [ 29 ] See also [ edit ] Chief experience officer Content strategy Customer experience Expectation Hick's law Human factors and ergonomics Interaction design Interaction design pattern Responsive web design Usability User-centered design User experience design User experience evaluation User interface design User research Online to offline References [ edit ] ^ Don, Norman; Jakob, Nielsen. \"The Definition of User Experience (UX)\" . Nielsen Norman Group . Retrieved 2 March 2021 . ^ International Organization for Standardization (2019). Ergonomics of human-system interaction \u2013 Part 210: Human-centred design for interactive systems (2nd\u00a0ed.). ISO 9241-210:2019 (formerly known as ISO 13407). ^ \"User experience definitions\" . Archived from the original on 13 January 2012. ^ Law, E.; Roto, V.; Hassenzahl, M.; Vermeeren, A.; Kort, J. (4\u20139 April 2009). \"Understanding, Scoping and Defining User Experience: A Survey Approach\" . Proceedings of Human Factors in Computing Systems conference . CHI'09. Boston, MA, USA. Archived (PDF) from the original on 11 September 2017. ^ Donald Norman, Jim Miller, Austin Henderson: What You See, Some of What's in the Future, And How We Go About Doing It: HI at Apple Computer Archived 20 October 2017 at the Wayback Machine . Proceedings of CHI 1995, Denver, Colorado, USA ^ Buley, Leah. 2013, The User Experience Team of One: A Research and Design Survival Guide. Rosenfield Media, LLC, USA. ^ Nielsen, Jakob. \"A 100-Year View of User Experience\" . Nielsen Norman Group . Retrieved 5 August 2022 . ^ \"Peter in Conversation with Don Norman About UX & Innovation\" . Archived from the original on 7 December 2013. ^ ISO 9241-11:1998, Ergonomics of Human System Interaction: Guidance on usability ^ \"COST - Towards the Integration of Transectorial IT Design and Evaluation (End date: November 2013)\" . cost.eu . Archived from the original on 14 March 2015 . Retrieved 9 May 2018 . ^ Fleming, J. 1998, Web Navigation: Designing the User Experience Archived 10 August 2017 at the Wayback Machine . O'Reilly & Associates, Inc, USA. ^ Garrett, J. 2003, Elements of User Experience: User-Centered Design for the Web Archived 3 December 2016 at the Wayback Machine . New Riders Press, USA. ^ Kuniavsky, M. (2003). Observing the User Experience: A Practitioner's Guide to User Research . United States: Elsevier. ISBN 978-0-08-049756-3 . Archived from the original on 9 May 2018. ^ Berry, D. 2000, The user experience - The iceberg analogy of usability. Technical library of the IBM Ease of Use Team. \"The user experience\" . IBM . October 2000. Archived from the original on 15 August 2010 . Retrieved 15 September 2010 . ^ \"UEQ - User Experience Questionnaire\" . ueq-online.org . Archived from the original on 1 October 2017 . Retrieved 9 May 2018 . ^ Laugwitz, B., Held, T. & Schrepp, M. (2008). Construction and evaluation of a user experience questionnaire Archived 11 September 2017 at the Wayback Machine . In: Holzinger, A. (Ed.): USAB 2008, LNCS 5298, S. 63\u201376. ^ Mclaughlin, Matthew; Delaney, Tessa; Hall, Alix; Byaruhanga, Judith; Mackie, Paul; Grady, Alice; Reilly, Kathryn; Campbell, Elizabeth; Sutherland, Rachel; Wiggers, John; Wolfenden, Luke (19 February 2021). \"Associations Between Digital Health Intervention Engagement, Physical Activity, and Sedentary Behavior: Systematic Review and Meta-analysis\" . Journal of Medical Internet Research . 23 (2) e23180. doi : 10.2196/23180 . ISSN 1438-8871 . PMC 8011420 . PMID 33605897 . ^ Donkin, Liesje; Christensen, Helen; Naismith, Sharon L; Neal, Bruce; Hickie, Ian B; Glozier, Nick (5 August 2011). \"A Systematic Review of the Impact of Adherence on the Effectiveness of e-Therapies\" . Journal of Medical Internet Research . 13 (3): e52. doi : 10.2196/jmir.1772 . ISSN 1438-8871 . PMC 3222162 . PMID 21821503 . ^ Lubrication Engineering . 1945. ^ \"Google Ngram Viewer\" . books.google.com . Retrieved 9 May 2018 . ^ Hassenzahl, M. & Tractinsky, N. 2006, User Experience \u2013 a Research Agenda Archived 20 October 2014 at the Wayback Machine . Behaviour and Information Technology, Vol. 25, No. 2, March\u2013April 2006, pp. 91\u201397 ^ Forlizzi, J., Battarbee, K. 2004, Understanding Experience in Interactive Systems Archived 31 January 2016 at the Wayback Machine . Proceedings of DIS2004, 1\u20134 August 2004, Cambridge, USA. ^ a b c d e f g h i j k Peek, Sean (7 August 2024). \"How to Provide an Honest and Ethical User Experience\" . Business.com . Business.com . Retrieved 4 October 2025 . ^ a b c d e f g Pervall, Trina Moore (29 September 2022). \"Unconscious Biases That Get In The Way Of Inclusive Design\" . Smashing Magazine . Retrieved 4 October 2025 . ^ a b c d e f g h i Gray, Colin M.; Kou, Yubo; Battles, Bryan; Hoggatt, Joseph; Toombs, Austin L. (21\u201326 April 2018). \"The Dark (Patterns) Side of UX Design\" . CHI 2018 . Montreal, QC, Canada: ACM. doi : 10.1145/3173574.3174108 . Retrieved 4 October 2025 . ^ a b c d e f Mathur, Arunesh; Mayer, Jonathan; Kshirsagar, Mihir (8\u201313 May 2021). \"What Makes a Dark Pattern... Dark? Design Attributes, Normative Considerations, and Measurement Methods\" . CHI Conference on Human Factors in Computing Systems (CHI \u201921) . Yokohama, Japan: ACM. pp. 1\u2013 27. arXiv : 2101.04843 . doi : 10.1145/3411764.3445610 . Retrieved 4 October 2025 . ^ a b \"Introduction to Web Accessibility\" . W3C Web Accessibility Initiative . W3C . Retrieved 4 October 2025 . ^ \"Good Developer Experience\" . Developer Experience Knowledge Base . Retrieved 10 September 2021 . ^ \"What is Developer Experience (DX)?\" . CSS-Tricks . 15 June 2020 . Retrieved 10 September 2021 . Wikimedia Commons has media related to User experience . Retrieved from \" https://en.wikipedia.org/w/index.php?title=User_experience&oldid=1327717043 \" Categories : Human\u2013computer interaction User interfaces Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata Use dmy dates from December 2020 All articles with unsourced statements Articles with unsourced statements from August 2016 Commons category link is on Wikidata This page was last edited on 15 December 2025, at 21:09 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents User experience 32 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Extreme_programming_practices#Collective_code_ownership",
    "title": "Extreme programming practices - Wikipedia",
    "content": "Extreme programming practices - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Fine-scale feedback Toggle Fine-scale feedback subsection 1.1 Pair programming 1.2 Planning game 1.2.1 Release planning 1.2.1.1 Exploration phase 1.2.1.2 Commitment phase 1.2.1.2.1 Sort by value 1.2.1.2.2 Sort by risk 1.2.1.3 Steering phase 1.2.2 Iteration Planning 1.2.2.1 Exploration phase 1.2.2.2 Commitment phase 1.2.2.3 Steering phase 1.3 Test driven development 1.4 Whole team 2 Continuous process Toggle Continuous process subsection 2.1 Continuous integration 2.2 Design improvement 2.3 Small releases 3 Shared understanding Toggle Shared understanding subsection 3.1 Coding standard 3.2 Collective code ownership 3.3 Simple design 3.4 System metaphor 4 Programmer welfare Toggle Programmer welfare subsection 4.1 Sustainable pace 5 See also 6 References 7 External links Toggle the table of contents Extreme programming practices 2 languages Magyar \u65e5\u672c\u8a9e Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Software development methodology Extreme programming ( XP ) is an agile software development methodology used to implement software systems. This article details the practices used in this methodology.  Extreme programming has 12 practices, grouped into four areas, derived from the best practices of software engineering . [ 1 ] Fine-scale feedback [ edit ] Pair programming [ edit ] This article may be confusing or unclear to readers . In particular, the first sentence of the following paragraph seems to be an incomplete sentence. Where is the verb phrase?. Please help clarify the article . There might be a discussion about this on the talk page . ( June 2023 ) ( Learn how and when to remove this message ) Pair programming is a method of programming in which code is produced by two people programming together on one task. One programmer has control over the workstation and is thinking mostly about the coding in detail. The other programmer is more focused on the big picture, and is continually reviewing the code that is being produced by the first programmer. Programmers trade roles after minute to hour periods. The pairs are not fixed; programmers switch partners frequently, so that everyone knows what everyone is doing, and everybody remains familiar with the whole system, even the parts outside their skill set. This way, pair programming also can enhance team-wide communication. (This also goes hand-in-hand with the concept of Collective Ownership). Planning game [ edit ] The main planning process within extreme programming is called the Planning Game. The game is a meeting that occurs once per iteration, typically once a week. The planning process is divided into two parts: Release Planning : This is focused on determining what requirements are included in which near-term releases, and when they should be delivered. The customers and developers are both part of this. Release Planning consists of three phases: Exploration Phase: In this phase the customer will provide a shortlist of high-value requirements for the system. These will be written down on user story cards. Commitment Phase: Within the commitment phase business and developers will commit themselves to the functionality that will be included and the date of the next release. Steering Phase: In the steering phase the plan can be adjusted, new requirements can be added and/or existing requirements can be changed or removed. Iteration Planning : This plans the activities and tasks of the developers. In this process the customer is not involved. Iteration Planning also consists of three phases: Exploration Phase: Within this phase the requirement will be translated to different tasks. The tasks are recorded on task cards. Commitment Phase: The tasks will be assigned to the programmers and the time it takes to complete will be estimated. Steering Phase: The tasks are performed and the end result is matched with the original user story. The purpose of the Planning Game is to guide the product into delivery. Instead of predicting the exact dates of when deliverables will be needed and produced, which is difficult to do, it aims to \"steer the project\" into delivery using a straightforward approach. [ 2 ] The Planning Game approach is used in development frameworks beyond just software systems. For example, it is used by teams in the context of business agility . [ 3 ] Release planning [ edit ] Exploration phase [ edit ] This is an iterative process of gathering requirements and estimating the work impact of each of those requirements. Write a Story: Business has come with a problem; during a meeting, development will try to define this problem and get requirements. Based on the business problem, a story ( user story ) has to be written. This is done by business, where they point out what they want a part of the system to do. It is important that development has no influence on this story. The story is written on a user story card. Estimate a Story: Development estimates how long it will take to implement the work implied by the story card. Development can also create spike solutions to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. Again, this may not influence the business requirements. Split a Story: Every design critical complexity has to be addressed before starting the iteration planning. If development isn't able to estimate the story, it needs to be split up and written again. When business cannot come up with any more requirements, one proceeds to the commitment phase. Commitment phase [ edit ] This phase involves the determination of costs, benefits, and schedule impact. It has four components: Sort by Value: Business sorts the user stories by Business Value . Sort by Risk: Development sorts the stories by risk. Set Velocity: Development determines at what speed they can perform. Choose scope: The user stories that will be finished in the next release will be picked. Based on the user stories the release date is determined. Sort by value [ edit ] The business side sorts the user stories by business value. They will arrange them into three piles: Critical: stories without which the system cannot function or has no meaning. Significant Business Value : Non-critical user stories that have significant business value. Nice to have: User stories that do not have significant business value. Sort by risk [ edit ] The developers sort the user stories by risk. They also categorize into three piles: low, medium and high risk user stories. The following is an example of an approach to this: Determine Risk Index: Give each user story an index from 0 to 2 on each of the following factors: Completeness (do we know all of the story details?) Complete (0) Incomplete (1) Unknown (2) Volatility (is it likely to change?) low (0) medium (1) high (2) Complexity (how hard is it to build?) simple (0) standard (1) complex (2) All indexes for a user story are added, assigning the user stories a risk index of low (0\u20131), medium (2\u20134), or high (5\u20136). Steering phase [ edit ] Within the steering phase the programmers and business people can \"steer\" the process. That is to say, they can make changes. Individual user stories, or relative priorities of different user stories, might change; estimates might prove wrong. This is the chance to adjust the plan accordingly. Iteration Planning [ edit ] Considering team velocity storypoints to be planned. Iteration duration can be 1 to 3 weeks. Exploration phase [ edit ] The exploration phase of the iteration planning is about creating tasks and estimating their implementation time. Translate the requirement to tasks: Place on task cards. Combine/Split task: If the programmer cannot estimate the task because it is too small or too big, the programmer will need to combine or split the task. Estimate task: Estimate the time it will take to implement the task. Commitment phase [ edit ] Within the commitment phase of the iteration planning programmers are assigned tasks that reference the different user stories. A programmer accepts a task: Each programmer picks a task for which he or she takes responsibility. Programmer estimates the task: Because the programmer is now responsible for the task, he or she should give the eventual estimation of the task. Set load factor: The load factor represents the ideal amount of hands-on development time per programmer within one iteration. For example, in a 40-hour week, with 5 hours dedicated to meetings, this would be no more than 35 hours. Balancing: When all programmers within the team have been assigned tasks, a comparison is made between the estimated time of the tasks and the load factor. Then the tasks are balanced out among the programmers. If a programmer is overcommitted, other programmers must take over some of his or her tasks and vice versa. Steering phase [ edit ] The implementation of the tasks is done during the steering phase of the iteration. Get a task card: The programmer gets the task card for one of the tasks to which he or she has committed. Find a partner: The programmer will implement this task along with another programmer. This is further discussed in the practice of pair programming . Design the task: If needed, the programmers will design the functionality of the task. Implement the task using test-driven development (TDD) (see below) Run functional test: Functional tests (based on the requirements in the associated user story and task card) are run. Test driven development [ edit ] Unit tests are automated tests that test the functionality of pieces of the code (e.g. classes, methods). Within XP, unit tests are written before the eventual code is coded. This approach is intended to stimulate the programmer to think about conditions in which his or her code could fail. XP says that the programmer is finished with a certain piece of code when he or she cannot come up with any further conditions under which the code may fail. Test driven development proceeds by quickly cycling through the following steps, with each step taking minutes at most, preferably much less. Since each user story will usually require one to two days of work, a very large number of such cycles will be necessary per story. Write unit test : The programmers write a minimal test that should fail because the functionality hasn't been fully implemented in the production code. Watch the new test fail: The programmers verify the test does indeed fail. While it may seem like a waste of time, this step is critical because it verifies that your belief about the state of the production code is correct. If the test does not fail, the programmers should determine whether there is a bug in the test code, or that the production code does support the functionality described by the new test. Write code: The programmers write just enough production code so the new test will pass. Run test: The unit tests are executed to verify that the new production code passes the new test, and that no other tests are failing. Refactor : Remove any code smells from both the production and test code. For a more intense version of the above process, see Uncle Bob's Three Rules of TDD. [ 4 ] Whole team [ edit ] Within XP, the \"customer\" is not the one who pays the bill, but the one who really uses the system. XP says that the customer should be on hand at all times and available for questions. For instance, the team developing a financial administration system should include a financial administrator. All the skills necessary to deliver the software product should be present on the team. Continuous process [ edit ] Continuous integration [ edit ] The development team should always be working on the latest version of the software.  Since different team members may have versions  saved locally with various changes and improvements, they should try to upload their current version to the code repository every few hours, or when a significant break presents itself. Continuous integration will avoid delays later on in the project cycle, caused by integration problems. Design improvement [ edit ] Because XP doctrine advocates programming only what is needed today, and implementing it as simply as possible, at times this may result in a system that is stuck. One of the symptoms of this is the need for dual (or multiple) maintenance: functional changes start requiring changes to multiple copies of the same (or similar) code. Another symptom is that changes in one part of the code affect many other parts. XP doctrine says that when this occurs, the system is telling you to refactor your code by changing the architecture, making it simpler and more generic. Small releases [ edit ] The delivery of the software is done via frequent releases of live functionality creating concrete value. The small releases help the customer to gain confidence in the progress of the project. This helps maintain the concept of the whole team as the customer can now come up with his suggestions on the project based on real experience. Shared understanding [ edit ] Coding standard [ edit ] Coding standard is an agreed upon set of rules that the entire development team agree to adhere to throughout the project.  The standard specifies a consistent style and format for source code , within the chosen programming language , as well as various programming constructs and patterns that should be avoided in order to reduce the probability of defects. [ 5 ] The coding standard may be a standard conventions specified by the language vendor (e.g. The Code Conventions for the Java Programming Language, recommended by Sun), or custom defined by the development team. Extreme Programming backers advocate code that is self-documenting to the furthest degree possible.  This reduces the need for code comments , which can get out of sync with the code itself. [ 6 ] Collective code ownership [ edit ] Main article: Code ownership Simple design [ edit ] Programmers should take a \"simple is best\" approach to software design.  Whenever a new piece of code is written, the author should ask themselves 'is there a simpler way to introduce the same functionality?'. If the answer is yes, the simpler course should be chosen.  Refactoring should also be used to make complex code simpler. System metaphor [ edit ] The system metaphor is a story that everyone - customers, programmers, and managers - can tell about how the system works. It's a naming concept for classes and methods that should make it easy for a team member to guess the functionality of a particular class/method, from its name only. For example a library system may create loan_records(class) for borrowers(class) , and if the item were to become overdue it may perform a make_overdue operation on a catalogue(class) .  For each class or operation the functionality is obvious to the entire team. Programmer welfare [ edit ] Sustainable pace [ edit ] The concept is that programmers or software developers should not work more than 40 hour weeks, and if there is overtime one week, that the next week should not include more overtime. Since the development cycles are short cycles of continuous integration, and full development (release) cycles are more frequent, the projects in XP do not follow the typical crunch time that other projects require (requiring overtime). Also, included in this concept is that people perform best and most creatively if they are well rested. A key enabler to achieve sustainable pace is frequent code-merge and always executable & test covered high quality code. The constant refactoring way of working enforces team members with fresh and alert minds.  The intense collaborative way of working within the team drives\na need to recharge over weekends. Well-tested, continuously integrated, frequently deployed code and environments also minimize the frequency of unexpected production problems and outages, and the associated after-hours nights and weekends work that is required. See also [ edit ] Continuous integration Multi-stage continuous integration Class-responsibility-collaboration card References [ edit ] ^ Beck, K. Extreme Programming Explained: Embrace Change 2nd. ed. Addison-Wesley, 2000 pp. 54 ^ Melnik, Grigori; Maurer, Frank (2004). \"Introducing Agile Methods: Three Years of Experience\". Proceedings. 30th Euromicro Conference, 2004 . Proceedings of the 30th Euromicro Conference. IEEE. pp. 334\u2013 341. CiteSeerX 10.1.1.296.4732 . doi : 10.1109/EURMIC.2004.1333388 . ISBN 0-7695-2199-1 . ^ Leybourn, E. (2013). Directing the Agile Organisation: A Lean Approach to Business Management. London: IT Governance Publishing: 146\u2013150. ^ Martin, Robert. \"Three Rules of TDD\" . ^ Kolawa, Adam; Huizinga, Dorota (2007). Automated Defect Prevention: Best Practices in Software Management . Wiley-IEEE Computer Society Press. p.\u00a075. ISBN 978-0-470-04212-0 . ^ \"XP-eXtreme Programming\" . Archived from the original (PPT) on 2021-12-17 . Retrieved 2015-01-31 . This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"Extreme programming practices\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR ( December 2008 ) ( Learn how and when to remove this message ) External links [ edit ] XP Practices Kent Beck XP Practices Ron Jeffries XP Practices Retrieved from \" https://en.wikipedia.org/w/index.php?title=Extreme_programming_practices&oldid=1324873383 \" Categories : Software development process Extreme programming Hidden categories: Articles with short description Short description is different from Wikidata Wikipedia articles needing clarification from June 2023 All Wikipedia articles needing clarification Articles needing additional references from December 2008 All articles needing additional references This page was last edited on 30 November 2025, at 00:41 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Extreme programming practices 2 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Acceptance_test-driven_development",
    "title": "Acceptance test-driven development - Wikipedia",
    "content": "Acceptance test-driven development - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Overview Toggle Overview subsection 1.1 Creation 1.2 Testing strategy 2 Acceptance criteria and tests Toggle Acceptance criteria and tests subsection 2.1 Test format 2.2 Complete test 2.3 Test examination 2.4 Another test example 2.5 Project acceptance tests 3 See also 4 References 5 External links Toggle the table of contents Acceptance test-driven development 2 languages \u0641\u0627\u0631\u0633\u06cc Magyar Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Methodology in software development Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Acceptance test\u2013driven development ( ATDD ) is a development methodology based on communication between the business customers, the developers, and the testers. [ 1 ] ATDD encompasses many of the same practices as specification by example (SBE), [ 2 ] [ 3 ] behavior-driven development (BDD), [ 4 ] example-driven development (EDD), [ 5 ] and support-driven development also called story test\u2013driven development (SDD). [ 6 ] All these processes aid developers and testers in understanding the customer's needs prior to implementation and allow customers to be able to converse in their own domain language. ATDD is closely related to test-driven development (TDD). [ 7 ] It differs by the emphasis on developer-tester-business customer collaboration. ATDD encompasses acceptance testing , but highlights writing acceptance tests before developers begin coding. Overview [ edit ] Acceptance tests are from the user's point of view \u2013 the external view of the system. [ 1 ] They examine externally visible effects, such as specifying the correct output of a system given a particular input.  Acceptance tests can verify how the state of something changes, such as an order that goes from \"paid\" to \"shipped\".  They also can check the interactions with interfaces of other systems, such as shared databases or web services.  In general, they are implementation independent, although automation of them may not be. [ 8 ] [ 9 ] Creation [ edit ] Acceptance tests are created when the requirements are analyzed and prior to coding. [ 1 ] They can be developed collaboratively by requirement requester (product owner, business analyst, customer representative, etc.), developer, and tester.  Developers implement the system using the acceptance tests.  Failing tests provide quick feedback that the requirements are not being met.  The tests are specified in business domain terms.  The terms then form a ubiquitous language that is shared between the customers, developers, and testers. [ 10 ] Tests and requirements are interrelated. [ 11 ] A requirement that lacks a test may not be implemented properly.  A test that does not refer to a requirement is an unneeded test.  An acceptance test that is developed after implementation begins represents a new requirement. [ 12 ] Testing strategy [ edit ] Acceptance tests are a part of an overall testing strategy. They are the customer/user oriented tests that demonstrate the business intent of a system. Depending on your test strategy, you may use them in combination with other test types, e.g. lower level Unit tests, [ 13 ] Cross-functional testing including usability testing, [ 14 ] exploratory testing, [ 15 ] and property testing (scaling and security). [ 16 ] Acceptance criteria and tests [ edit ] Acceptance criteria are a description of what would be checked by a test. Given a requirement such as \"As a user, I want to check out a book from the library\", an acceptance criterion might be, \"verify the book is marked as checked out\". An acceptance test for this requirement gives the details so that the test can be run with the same effect each time. Test format [ edit ] Acceptance tests usually follow this form: [ 1 ] Given (setup) A specified state of a system When (trigger) An action or event occurs Then (verification) The state of the system has changed or an output has been produced Also, it is possible to add Statements that start with AND in any of the sections below (Given, When, Then). For the example requirement, the steps could be listed as: Given Book that has not been checked out And User who is registered on the system When User checks out a book Then Book is marked as checked out Complete test [ edit ] The previous steps do not include any specific example data, so that is added to complete the test: Given: Book that has not been checked out Books Title Checked out Great book No User who is registered on the system Users Name Sam When: User checks out a book Checkout action User Sam Checks out Great book Then: Book is marked as checked out Books Title Checked out User Great book Yes Sam Test examination [ edit ] Examination of the test with specific data usually leads to many questions. For the sample, these might be: What if the book is already checked out? What if the book does not exist? What if the user is not registered on the system? Is there a date that the book is due to be checked-in? How many books can a user check out? These questions help illuminate missing or ambiguous requirements.  Additional details such as a due-date can be added to the expected result.  Other acceptance tests can check that conditions such as attempting to check out a book that is already checked out produces the expected error. Another test example [ edit ] Suppose the business customer wanted a business rule that a user could only check out one book at a time.  The following test would demonstrate that: Scenario: Check that checkout business rule is enforced Given: Book that has been checked out Books Title Checked out User Great book Yes Sam Another great book No Users Name Sam When: User checks out another book Checkout action User Sam Checks out Another great book Then: Error occurs Error occurred Description Violation of checkout business rule Project acceptance tests [ edit ] In addition to acceptance tests for requirements, acceptance tests can be used on a project as a whole. [ 1 ] For example, if this requirement was part of a library book checkout project, there could be acceptance tests for the whole project. These are often termed SMART objectives . An example test is \"When the new library system is in production, the users will be able to check books in and out three times as fast as they do today\". See also [ edit ] Concordion FitNesse Robot Framework Gauge (software) Cucumber (software) References [ edit ] ^ a b c d e Pugh, Ken (2011). Lean-Agile Acceptance Test-Driven Development: Better Software Through Collaboration . Addison-Wesley. ISBN 978-0321714084 . ^ Adzic, Gojko. (2009) Bridging the Communication Gap: Specification by Example and Agile Acceptance Testing , Neuri Limited, ^ Adzic, Gojko (2011). Specification by example: How successful teams deliver the right software . Manning. ISBN 978-0-321-27865-4 . ^ Chelimsky, David, Dave Astels, Zach Dennis, Aslak Helles\u00f8y, Bryan Helmkamp, and Dan North. The RSpec Book: Behaviour Driven Development with RSpec, Cucumber, and Friends. The Pragmatic Bookshelf. ^ \"Example Driven Design\" . Retrieved 2013-04-15 . ^ \"Story Test-Driven Development\" (PDF) . Retrieved 2013-04-15 . ^ Beck, Kent. Test Driven Development: By Example. Addison-Wesley Professional, 2002. ^ Melnik, Grigori, and Frank Maurer. Melnik, Grigori; Maurer, Frank (2007). \"Multiple Perspectives on Executable Acceptance Test-Driven Development\". Agile Processes in Software Engineering and Extreme Programming . Lecture Notes in Computer Science. Vol.\u00a04536. pp. 245\u2013 249. doi : 10.1007/978-3-540-73101-6_46 . ISBN 978-3-540-73100-9 . ^ Koskela, Lasse. (2007) Test Driven: TDD and Acceptance TDD for Java Developers. Manning Publications ^ Evans, Eric. (2003) Domain-Driven Design: Tackling Complexity in the Heart of Software . Addison-Wesley Professional. ^ Weinberg, Gerald ; Gause, Donald (1989). Exploring Requirements: Quality Before Design . Dorset House. ISBN 0-932633-13-7 . ^ Martin, Robert C., and Grigori Melnik. \"Tests and Requirements, Requirements and Tests: A M\u00f6bius Strip\" (PDF) . Retrieved 2013-04-15 . ^ [Test-driven_development] ^ Meszaros, Gerard, and Janice Aston. (2006) \"Adding Usability Testing to an Agile Project.\" Agile Conference ^ \"Exploratory Testing Explained\" (PDF) . 23 March 2019. ^ Meszaros, Gerard.(2007) xUnit Test Patterns: Refactoring Test Code . Addison-Wesley. External links [ edit ] Example of automation frameworks Retrieved from \" https://en.wikipedia.org/w/index.php?title=Acceptance_test-driven_development&oldid=1297242714 \" Categories : Software development philosophies Software testing Business analysis Hidden categories: Articles with short description Short description matches Wikidata This page was last edited on 25 June 2025, at 00:36 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Acceptance test-driven development 2 languages Add topic"
  },
  {
    "url": "https://en.wikipedia.org/wiki/Continuous_delivery",
    "title": "Continuous delivery - Wikipedia",
    "content": "Continuous delivery - Wikipedia Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Contents move to sidebar hide (Top) 1 Principles 2 Deployment pipeline 3 Tools/tool types 4 Architecting for continuous delivery 5 Implementation and usage 6 Benefits and obstacles 7 Strategies to overcome adoption challenges 8 Best practices for cloud systems 9 Relationship to DevOps 10 Relationship to Continuous Deployment 11 See also 12 Further reading 13 References 14 External links Toggle the table of contents Continuous delivery 19 languages \u0627\u0644\u0639\u0631\u0628\u064a\u0629 \u010ce\u0161tina Deutsch Eesti Espa\u00f1ol \u0641\u0627\u0631\u0633\u06cc Fran\u00e7ais \ud55c\uad6d\uc5b4 Magyar Nederlands \u65e5\u672c\u8a9e Norsk bokm\u00e5l Portugu\u00eas \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Suomi Svenska \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 Ti\u1ebfng Vi\u1ec7t \u4e2d\u6587 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Software engineering approach of short cycles Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Continuous delivery ( CD ) is a software engineering approach in which teams produce software in short cycles, ensuring that the software can be reliably released at any time. [ 1 ] [ 2 ] It aims at building, testing, and releasing software with greater speed and frequency. The approach helps reduce the cost, time, [ citation needed ] and risk of delivering changes by allowing for more incremental updates to applications in production. A straightforward and repeatable deployment process is important for continuous delivery. Principles [ edit ] According to Neal Ford, continuous delivery adopts \"Bring the pain forward,\" tackling tough tasks early, fostering automation and swift issue detection. [ 3 ] Continuous delivery treats the commonplace notion of a deployment pipeline [ 4 ] as a lean Poka-Yoke : [ 5 ] a set of validations through which a piece of software must pass on its way to release . Code is compiled if necessary and then packaged by a build server every time a change is committed to a source control repository , then tested by a number of different techniques (possibly including manual testing) before it can be marked as releasable. Developers used to a long cycle time may need to change their mindset when working in a CD environment. Any code commit may be released to customers at any point. Patterns such as feature toggles can be very useful for committing code early which is not yet ready for use by end users. Using NoSQL can eliminate the step of data migrations and schema changes, often manual steps or exceptions to a continuous delivery workflow. [ 6 ] Other useful techniques for developing code in isolation such as code branching are not obsolete in a CD world, but must be adapted to fit the principles of CD - for example, running multiple long-lived code branches can prove impractical, as a releasable artifact must be built early in the CD process from a single code branch if it is to pass through all phases of the pipeline. [ clarification needed ] Deployment pipeline [ edit ] Continuous delivery is enabled through the deployment pipeline. The purpose of the deployment pipeline has three components: visibility, feedback, and continually deploy. [ 7 ] Visibility \u2013 All aspects of the delivery system including building, deploying, testing, and releasing are visible to every member of the team to promote collaboration. Feedback \u2013 Team members learn of problems as soon as possible when they occur so that they are able to fix them as quickly as possible. Continually deploy \u2013 Through a fully automated process, you can deploy and release any version of the software to any environment. According to Yan Cui, when it comes to serverless environments , ephemeral resources should be kept together and have their own deployment pipeline to achieve a high cohesion . However, shared resources that have a long spin-up time and landing zone should have their own separate repository , deployment pipeline and stack. [ 8 ] Tools/tool types [ edit ] Continuous delivery takes automation from source control all the way through production. There are various tools that help accomplish all or part of this process. [ 9 ] These tools are part of the deployment pipeline which includes continuous delivery. The types of tools that execute various parts of the process include: continuous integration , application release automation , build automation , application lifecycle management . [ 10 ] Architecting for continuous delivery [ edit ] To practice continuous delivery effectively, software applications have to meet a set of architecturally significant requirements (ASRs) such as deployability, modifiability, and testability. [ 11 ] These ASRs require a high priority and cannot be traded off lightly. Microservices are often used when architecting for continuous delivery. [ 12 ] The use of Microservices can increase a software system's deployability and modifiability. The observed deployability improvements include: deployment independence, shorter deployment time, simpler deployment procedures, and zero downtime deployment. The observed modifiability improvements include: shorter cycle time for small incremental functional changes, easier technology selection changes, incremental quality attribute changes, and easier language and library upgrades. [ 12 ] Implementation and usage [ edit ] The original CD book written by Jez Humble and David Farley (2010) popularized the term; however, since its creation the definition has continued to advance and now has a more developed meaning. Companies today are implementing these continuous delivery principles and best practices. The difference in domains, e.g. medical vs. web, is still significant and affects the implementation and usage. [ 13 ] Well-known companies that have this approach include Yahoo! , [ 14 ] Amazon , [ 15 ] Facebook , [ 16 ] Google , [ 17 ] Paddy Power [ 1 ] and Wells Fargo . [ 18 ] Benefits and obstacles [ edit ] Several benefits of continuous delivery have been reported. [ 1 ] [ 13 ] Accelerated time to market : Continuous delivery lets an organization deliver the business value inherent in new software releases to customers more quickly. This capability helps the company stay a step ahead of the competition. Building the right product: Frequent releases let the application development teams obtain user feedback more quickly. This lets them work on only the useful features. If they find that a feature isn't useful, they spend no further effort on it. This helps them build the right product. Improved productivity and efficiency: Significant time savings for developers, testers, operations engineers, etc. through automation. Reliable releases: The risks associated with a release have significantly decreased, and the release process has become more reliable. With continuous delivery, the deployment process and scripts are tested repeatedly before deployment to production. So, most errors in the deployment process and scripts have already been discovered. With more frequent releases, the number of code changes in each release decreases. This makes finding and fixing any problems that do occur easier, reducing the time in which they have an impact. Improved product quality : The number of open bugs and production incidents has decreased significantly. Improved customer satisfaction : A higher level of customer satisfaction is achieved. Obstacles have also been investigated. [ 13 ] Customer preferences: Some customers do not want frequent updates to their systems. Domain restrictions: In some domains, such as telecom, medical, avionics, railway and heavy industries, regulations require customer-side or even on-site testing of new versions. Lack of test automation: Lack of test automation leads to a lack of developer confidence and can prevent using continuous delivery. Differences in environments: Different environments used in the development, testing and production can result in undetected issues slipping to the production environment. Tests needing a human oracle : Not all quality attributes can be verified with automation. These attributes require humans in the loop, slowing down the delivery pipeline. Eight further adoption challenges were raised and elaborated on by Chen. [ 19 ] These challenges are in the areas of organizational structure, processes, tools, infrastructure, legacy systems, architecting for continuous delivery, continuous testing of non-functional requirements, and test execution optimization. Strategies to overcome adoption challenges [ edit ] This section contains instructions or advice . Wikipedia is not a guidebook; please help rewrite such content to be encyclopedic or move it to Wikiversity , Wikibooks , or Wikivoyage . ( January 2022 ) Several strategies to overcome continuous delivery adoption challenges have been reported. [ 19 ] Strategies to Overcome CD Adoption Challenges Strategy Description Selling CD as a painkiller Identify each stakeholder's pain points that CD can solve, and sell CD as a painkiller to that stakeholder. This strategy helps to achieve buy-in from the wide range of stakeholders that a CD implementation requires. Dedicated team with multi-disciplinary members Without a dedicated team, it can be hard to progress because employees are often assigned to work on other value streams. A multi-disciplinary team not only provides the wide range of skills required for CD implementation but also smooths the communication with related teams. Continuous delivery of continuous delivery Organize the implementation of CD in a way that delivers value to the company as early as possible, onboarding more projects gradually, in small increments and eventually rolling out CD across the whole organization. This strategy helps justify the investment required by making concrete benefits visible along the way. Visible benefits, in turn, help to achieve the sustained company support and investment required to survive the long and tough journey to CD. Starting with easy but important applications When selecting the first few applications to migrate to CD, choose the ones that are easy to migrate but that are important to the business. Being easy to migrate helps to demonstrate the benefits of CD quickly, which can prevent the implementation initiative from being killed. Being important to the business helps to secure the required resources, demonstrates clear and unarguable value, and raises the visibility of CD in the organization. Visual CD pipeline skeleton Give a team a visual CD pipeline skeleton that has the full CD pipeline view but with empty stages for those they cannot implement yet. This helps to build up a CD mindset and maintain the momentum for CD adoption. The pipeline skeleton is especially useful when the team's migration to CD requires a large effort and mindset changes over a long period of time. Expert drop Assign a CD expert to join tough projects as a senior member of the development team. Having the expert on the team helps to build the motivation and momentum to move to CD from inside the team. It also helps to maintain momentum when the migration requires a large effort and a long period of time. Best practices for cloud systems [ edit ] The following practices can enhance productivity of pipelines , especially in systems hosted in the cloud : [ 20 ] [ 21 ] [ 22 ] Number of Pipelines : Small teams can be more productive by having one repository and one pipeline. In contrast, larger organizations may have separate repositories and pipelines for each team or even separate repositories and pipelines for each service within a team. Permissions : In the context of pipeline-related permissions, adhering to the principle of least privilege can be challenging due to the dynamic nature of architecture . Administrators may opt for more permissive permissions while implementing compensating security controls to minimize the blast radius. Relationship to DevOps [ edit ] Main article: DevOps DevOps is a software engineering approach that centers around cultural change, specifically the collaboration of the various teams involved in software delivery (developers, operations, quality assurance, management, etc.), as well as automating the processes in software delivery. [ 23 ] [ 24 ] [ 25 ] Relationship to Continuous Deployment [ edit ] Main article: Continuous deployment Continuous deployment is a software engineering approach which uses automated software deployments. [ 19 ] In it, software is produced in short cycles but through automated software deployments even to production rather than requiring a \"click of a button\" for that last step. [ 1 ] : 52 Therefore, continuous deployment can be considered a more sophisticated form of automation. [ 26 ] Academic literature differentiates between continuous delivery and continuous deployment according to deployment method; manual vs. automated. [ 2 ] [ 27 ] See also [ edit ] Application lifecycle management Application release automation Build management Change management CI/CD Continuous configuration automation Continuous integration Continuous testing DevOps Release management Software configuration management Version control Further reading [ edit ] Humble, Jez; Farley, David (2010). Continuous Delivery: Reliable Software Releases Through Build, Test and Deployment Automation . Addison-Wesley. ISBN 978-0-321-60191-9 . Wolff, Eberhard (2017). A Practical Guide to Continuous Delivery . Addison-Wesley. ISBN 978-0-134-69147-3 . References [ edit ] ^ a b c d Chen, Lianping (2015). \"Continuous Delivery: Huge Benefits, but Challenges Too\" . IEEE Software . 32 (2): 50\u2013 54. Bibcode : 2015ISoft..32b..50C . doi : 10.1109/MS.2015.27 . S2CID 1241241 . ^ a b Shahin, Mojtaba; Ali Babara, Muhammad; Zhu, Liming (2017). \"Continuous Integration, Delivery and Deployment: A Systematic Review on Approaches, Tools, Challenges and Practices\". IEEE Access . 5 : 3909\u2013 3943. arXiv : 1703.07019 . Bibcode : 2017arXiv170307019S . doi : 10.1109/ACCESS.2017.2685629 . S2CID 11638909 . ^ Ford, Neal; Parsons, Rebecca; Kua, Patrick; Sadalage, Pramod J. (2022). Building Evolutionary Architectures: Automated Software Governance . O'Reilly Media, Incorporated. ISBN 978-1492097549 . ^ Humble, J.; Read, C.; North, D. (2006). \"The Deployment Production Line\". Agile 2006 (Agile'06) . pp. 113\u2013 118. doi : 10.1109/AGILE.2006.53 . ISBN 0-7695-2562-8 . S2CID 16572138 . ^ Fitzgerald, Brian (2014-06-03). Continuous Software Engineering and Beyond: Trends and Challenges (PDF) . 1st International Workshop on Rapid Continuous Software Engineering . New York, NY: Association for Computing Machinery. pp. 1\u2013 9. doi : 10.1145/2593812.2593813 . hdl : 10344/3896 . ISBN 978-1-4503-2856-2 . Archived from the original (PDF) on 2014-10-25 . Retrieved 2014-10-24 . ^ Kluge, Lars (12 September 2013). \"Continuous Deployment with MongoDB at Kitchensurfing\" . slideshare.net . Retrieved 3 January 2014 . ^ Duvall, Paul (2012). \"Continuous Delivery: Patterns and Anti-Patterns in Software Lifecycle\" (PDF) . Refcardz . Archived from the original (PDF) on June 19, 2018 . Retrieved October 9, 2015 . ^ Cui, Yan (2020). Serverless Architectures on AWS (2nd\u00a0ed.). Manning. ISBN 978-1617295423 . ^ Phillips, Andrew (29 July 2014). \"The Continuous Delivery Pipeline \u2013 What it is and Why it's so important in Developing Software\" . DevOps.com . Archived from the original on 28 September 2015 . Retrieved October 9, 2015 . ^ Binstock, Andrew (16 September 2014). \"Continuous Delivery: The Agile SUccessor\" . Dr. Dobb's the World of Software Development . San Francisco: UBM. ^ Chen, Lianping (2015). Towards Architecting for Continuous Delivery . The 12th Working IEEE/IFIP Conference on Software Architecture(WICSA 2015) . Montr\u00e9al, Canada: IEEE. doi : 10.1109/WICSA.2015.23 . Archived 2018-11-13 at the Wayback Machine ^ a b Chen, Lianping (2018). Microservices: Architecting for Continuous Delivery and DevOps . The IEEE International Conference on Software Architecture (ICSA 2018) . IEEE. ^ a b c Lepp\u00e4nen, M.; M\u00e4kinen, S.; Pagels, M.; Eloranta, V. P.; Itkonen, J.; M\u00e4ntyl\u00e4, M. V.; M\u00e4nnist\u00f6, T. (2015-03-01). \"The Highways and Country Roads to Continuous Deployment\". IEEE Software . 32 (2): 64\u2013 72. Bibcode : 2015ISoft..32b..64L . doi : 10.1109/MS.2015.50 . ISSN 0740-7459 . S2CID 18719684 . ^ \"Implementing Continuous Delivery at Yahoo!\" . confreaks.tv . 23 October 2013. ^ \"Velocity 2011: Jon Jenkins, \"Velocity Culture\" \" . youtube.com . 20 June 2011. ^ \"Rapid Release At Massive Scale\" . 2017-08-31. ^ Humble, Jez (13 February 2014). \"The Case for Continuous Delivery\" . thoughtworks.com . Retrieved 16 July 2014 . ^ jFrog (December 2014). \"2014-year-continuous-integration-revolution\" . ^ a b c Chen, Lianping (2017). \"Continuous Delivery: Overcoming adoption challenges\" . Journal of Systems and Software . 128 : 72\u2013 86. doi : 10.1016/j.jss.2017.02.013 . ^ Serverless Architectures on AWS . Manning. 29 March 2022. ISBN 978-1617295423 . ^ Pipeline as Code Continuous Delivery with Jenkins, Kubernetes, and Terraform . Manning. 23 November 2021. ISBN 9781638350378 . ^ Humble, Jez; Farley, David (27 July 2010). Continuous Delivery Reliable Software Releases Through Build, Test, and Deployment Automation . Pearson Education. ISBN 9780321670229 . ^ Humble, Jez; Farley, David (2011). Continuous Delivery: reliable software releases through build, test, and deployment automation . Pearson Education Inc. ISBN 978-0-321-60191-9 . ^ Hammond, Jeffrey (9 September 2011). \"The Relationship between DevOps and Continuous Delivery\" . Forrester Research . Forester. ^ Swartout, Paul (2012). Continuous Delivery and DevOps: A Quickstart guide . Packt Publishing. ISBN 978-1849693684 . ^ \"Continuous Deployment: An Essential Guide\" . IBM . 2019-10-02 . Retrieved 2022-11-28 . Continuous deployment is the natural outcome of continuous delivery done well. Eventually, the manual approval delivers little or no value and is merely slowly things down. At that point, it is done away with and continuous delivery becomes continuous deployment. ^ Shahin, Mojtaba; Babar, Muhammad Ali; Zahedi, Mansooreh; Zhu, Liming (2017). \"Beyond Continuous Delivery: An Empirical Investigation of Continuous Deployment Challenges\". 2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM) . pp. 111\u2013 120. doi : 10.1109/ESEM.2017.18 . ISBN 978-1-5090-4039-1 . S2CID 3479812 . External links [ edit ] Continuous delivery practices [ 1 ] ^ \"Building Evolutionary Architecture\" . Retrieved from \" https://en.wikipedia.org/w/index.php?title=Continuous_delivery&oldid=1322843384 \" Categories : Software release Software design Software development process Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata All articles with unsourced statements Articles with unsourced statements from February 2023 Wikipedia articles needing clarification from September 2017 Articles needing cleanup from January 2022 All pages needing cleanup Articles containing how-to sections This page was last edited on 18 November 2025, at 05:01 (UTC) . Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;\nadditional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Legal & safety contacts Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Continuous delivery 19 languages Add topic"
  }
]